// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/raw.proto

#ifndef PROTOBUF_s2clientprotocol_2fraw_2eproto__INCLUDED
#define PROTOBUF_s2clientprotocol_2fraw_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2007000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
// @@protoc_insertion_point(includes)

namespace SC2APIProtocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

class ActionRaw;
class ActionRawCameraMove;
class ActionRawToggleAutocast;
class ActionRawUnitCommand;
class Event;
class MapState;
class ObservationRaw;
class PassengerUnit;
class PlayerRaw;
class PowerSource;
class StartRaw;
class Unit;
class UnitOrder;

enum DisplayType {
  Visible = 1,
  Snapshot = 2,
  Hidden = 3
};
bool DisplayType_IsValid(int value);
const DisplayType DisplayType_MIN = Visible;
const DisplayType DisplayType_MAX = Hidden;
const int DisplayType_ARRAYSIZE = DisplayType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisplayType_descriptor();
inline const ::std::string& DisplayType_Name(DisplayType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisplayType_descriptor(), value);
}
inline bool DisplayType_Parse(
    const ::std::string& name, DisplayType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplayType>(
    DisplayType_descriptor(), name, value);
}
enum Alliance {
  Self = 1,
  Ally = 2,
  Neutral = 3,
  Enemy = 4
};
bool Alliance_IsValid(int value);
const Alliance Alliance_MIN = Self;
const Alliance Alliance_MAX = Enemy;
const int Alliance_ARRAYSIZE = Alliance_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alliance_descriptor();
inline const ::std::string& Alliance_Name(Alliance value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alliance_descriptor(), value);
}
inline bool Alliance_Parse(
    const ::std::string& name, Alliance* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alliance>(
    Alliance_descriptor(), name, value);
}
enum CloakState {
  Cloaked = 1,
  CloakedDetected = 2,
  NotCloaked = 3
};
bool CloakState_IsValid(int value);
const CloakState CloakState_MIN = Cloaked;
const CloakState CloakState_MAX = NotCloaked;
const int CloakState_ARRAYSIZE = CloakState_MAX + 1;

const ::google::protobuf::EnumDescriptor* CloakState_descriptor();
inline const ::std::string& CloakState_Name(CloakState value) {
  return ::google::protobuf::internal::NameOfEnum(
    CloakState_descriptor(), value);
}
inline bool CloakState_Parse(
    const ::std::string& name, CloakState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CloakState>(
    CloakState_descriptor(), name, value);
}
// ===================================================================

class StartRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.StartRaw) */ {
 public:
  StartRaw();
  virtual ~StartRaw();

  StartRaw(const StartRaw& from);

  inline StartRaw& operator=(const StartRaw& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartRaw& default_instance();

  void Swap(StartRaw* other);

  // implements Message ----------------------------------------------

  inline StartRaw* New() const { return New(NULL); }

  StartRaw* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartRaw& from);
  void MergeFrom(const StartRaw& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.Size2DI map_size = 1;
  bool has_map_size() const;
  void clear_map_size();
  static const int kMapSizeFieldNumber = 1;
  const ::SC2APIProtocol::Size2DI& map_size() const;
  ::SC2APIProtocol::Size2DI* mutable_map_size();
  ::SC2APIProtocol::Size2DI* release_map_size();
  void set_allocated_map_size(::SC2APIProtocol::Size2DI* map_size);

  // optional .SC2APIProtocol.ImageData pathing_grid = 2;
  bool has_pathing_grid() const;
  void clear_pathing_grid();
  static const int kPathingGridFieldNumber = 2;
  const ::SC2APIProtocol::ImageData& pathing_grid() const;
  ::SC2APIProtocol::ImageData* mutable_pathing_grid();
  ::SC2APIProtocol::ImageData* release_pathing_grid();
  void set_allocated_pathing_grid(::SC2APIProtocol::ImageData* pathing_grid);

  // optional .SC2APIProtocol.ImageData terrain_height = 3;
  bool has_terrain_height() const;
  void clear_terrain_height();
  static const int kTerrainHeightFieldNumber = 3;
  const ::SC2APIProtocol::ImageData& terrain_height() const;
  ::SC2APIProtocol::ImageData* mutable_terrain_height();
  ::SC2APIProtocol::ImageData* release_terrain_height();
  void set_allocated_terrain_height(::SC2APIProtocol::ImageData* terrain_height);

  // optional .SC2APIProtocol.ImageData placement_grid = 4;
  bool has_placement_grid() const;
  void clear_placement_grid();
  static const int kPlacementGridFieldNumber = 4;
  const ::SC2APIProtocol::ImageData& placement_grid() const;
  ::SC2APIProtocol::ImageData* mutable_placement_grid();
  ::SC2APIProtocol::ImageData* release_placement_grid();
  void set_allocated_placement_grid(::SC2APIProtocol::ImageData* placement_grid);

  // optional .SC2APIProtocol.RectangleI playable_area = 5;
  bool has_playable_area() const;
  void clear_playable_area();
  static const int kPlayableAreaFieldNumber = 5;
  const ::SC2APIProtocol::RectangleI& playable_area() const;
  ::SC2APIProtocol::RectangleI* mutable_playable_area();
  ::SC2APIProtocol::RectangleI* release_playable_area();
  void set_allocated_playable_area(::SC2APIProtocol::RectangleI* playable_area);

  // repeated .SC2APIProtocol.Point2D start_locations = 6;
  int start_locations_size() const;
  void clear_start_locations();
  static const int kStartLocationsFieldNumber = 6;
  const ::SC2APIProtocol::Point2D& start_locations(int index) const;
  ::SC2APIProtocol::Point2D* mutable_start_locations(int index);
  ::SC2APIProtocol::Point2D* add_start_locations();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Point2D >*
      mutable_start_locations();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Point2D >&
      start_locations() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.StartRaw)
 private:
  inline void set_has_map_size();
  inline void clear_has_map_size();
  inline void set_has_pathing_grid();
  inline void clear_has_pathing_grid();
  inline void set_has_terrain_height();
  inline void clear_has_terrain_height();
  inline void set_has_placement_grid();
  inline void clear_has_placement_grid();
  inline void set_has_playable_area();
  inline void clear_has_playable_area();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::Size2DI* map_size_;
  ::SC2APIProtocol::ImageData* pathing_grid_;
  ::SC2APIProtocol::ImageData* terrain_height_;
  ::SC2APIProtocol::ImageData* placement_grid_;
  ::SC2APIProtocol::RectangleI* playable_area_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Point2D > start_locations_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static StartRaw* default_instance_;
};
// -------------------------------------------------------------------

class ObservationRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObservationRaw) */ {
 public:
  ObservationRaw();
  virtual ~ObservationRaw();

  ObservationRaw(const ObservationRaw& from);

  inline ObservationRaw& operator=(const ObservationRaw& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObservationRaw& default_instance();

  void Swap(ObservationRaw* other);

  // implements Message ----------------------------------------------

  inline ObservationRaw* New() const { return New(NULL); }

  ObservationRaw* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObservationRaw& from);
  void MergeFrom(const ObservationRaw& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservationRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.PlayerRaw player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  const ::SC2APIProtocol::PlayerRaw& player() const;
  ::SC2APIProtocol::PlayerRaw* mutable_player();
  ::SC2APIProtocol::PlayerRaw* release_player();
  void set_allocated_player(::SC2APIProtocol::PlayerRaw* player);

  // repeated .SC2APIProtocol.Unit units = 2;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  const ::SC2APIProtocol::Unit& units(int index) const;
  ::SC2APIProtocol::Unit* mutable_units(int index);
  ::SC2APIProtocol::Unit* add_units();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Unit >*
      mutable_units();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Unit >&
      units() const;

  // optional .SC2APIProtocol.MapState map_state = 3;
  bool has_map_state() const;
  void clear_map_state();
  static const int kMapStateFieldNumber = 3;
  const ::SC2APIProtocol::MapState& map_state() const;
  ::SC2APIProtocol::MapState* mutable_map_state();
  ::SC2APIProtocol::MapState* release_map_state();
  void set_allocated_map_state(::SC2APIProtocol::MapState* map_state);

  // optional .SC2APIProtocol.Event event = 4;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 4;
  const ::SC2APIProtocol::Event& event() const;
  ::SC2APIProtocol::Event* mutable_event();
  ::SC2APIProtocol::Event* release_event();
  void set_allocated_event(::SC2APIProtocol::Event* event);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObservationRaw)
 private:
  inline void set_has_player();
  inline void clear_has_player();
  inline void set_has_map_state();
  inline void clear_has_map_state();
  inline void set_has_event();
  inline void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::PlayerRaw* player_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Unit > units_;
  ::SC2APIProtocol::MapState* map_state_;
  ::SC2APIProtocol::Event* event_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static ObservationRaw* default_instance_;
};
// -------------------------------------------------------------------

class PowerSource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PowerSource) */ {
 public:
  PowerSource();
  virtual ~PowerSource();

  PowerSource(const PowerSource& from);

  inline PowerSource& operator=(const PowerSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerSource& default_instance();

  void Swap(PowerSource* other);

  // implements Message ----------------------------------------------

  inline PowerSource* New() const { return New(NULL); }

  PowerSource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PowerSource& from);
  void MergeFrom(const PowerSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.Point pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  const ::SC2APIProtocol::Point& pos() const;
  ::SC2APIProtocol::Point* mutable_pos();
  ::SC2APIProtocol::Point* release_pos();
  void set_allocated_pos(::SC2APIProtocol::Point* pos);

  // optional float radius = 2;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  float radius() const;
  void set_radius(float value);

  // optional uint64 tag = 3;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 3;
  ::google::protobuf::uint64 tag() const;
  void set_tag(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PowerSource)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::Point* pos_;
  ::google::protobuf::uint64 tag_;
  float radius_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static PowerSource* default_instance_;
};
// -------------------------------------------------------------------

class PlayerRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerRaw) */ {
 public:
  PlayerRaw();
  virtual ~PlayerRaw();

  PlayerRaw(const PlayerRaw& from);

  inline PlayerRaw& operator=(const PlayerRaw& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRaw& default_instance();

  void Swap(PlayerRaw* other);

  // implements Message ----------------------------------------------

  inline PlayerRaw* New() const { return New(NULL); }

  PlayerRaw* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerRaw& from);
  void MergeFrom(const PlayerRaw& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.PowerSource power_sources = 1;
  int power_sources_size() const;
  void clear_power_sources();
  static const int kPowerSourcesFieldNumber = 1;
  const ::SC2APIProtocol::PowerSource& power_sources(int index) const;
  ::SC2APIProtocol::PowerSource* mutable_power_sources(int index);
  ::SC2APIProtocol::PowerSource* add_power_sources();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PowerSource >*
      mutable_power_sources();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PowerSource >&
      power_sources() const;

  // optional .SC2APIProtocol.Point camera = 2;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 2;
  const ::SC2APIProtocol::Point& camera() const;
  ::SC2APIProtocol::Point* mutable_camera();
  ::SC2APIProtocol::Point* release_camera();
  void set_allocated_camera(::SC2APIProtocol::Point* camera);

  // repeated uint32 upgrade_ids = 3;
  int upgrade_ids_size() const;
  void clear_upgrade_ids();
  static const int kUpgradeIdsFieldNumber = 3;
  ::google::protobuf::uint32 upgrade_ids(int index) const;
  void set_upgrade_ids(int index, ::google::protobuf::uint32 value);
  void add_upgrade_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      upgrade_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_upgrade_ids();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerRaw)
 private:
  inline void set_has_camera();
  inline void clear_has_camera();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PowerSource > power_sources_;
  ::SC2APIProtocol::Point* camera_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > upgrade_ids_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static PlayerRaw* default_instance_;
};
// -------------------------------------------------------------------

class UnitOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.UnitOrder) */ {
 public:
  UnitOrder();
  virtual ~UnitOrder();

  UnitOrder(const UnitOrder& from);

  inline UnitOrder& operator=(const UnitOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitOrder& default_instance();

  enum TargetCase {
    kTargetWorldSpacePos = 2,
    kTargetUnitTag = 3,
    TARGET_NOT_SET = 0,
  };

  void Swap(UnitOrder* other);

  // implements Message ----------------------------------------------

  inline UnitOrder* New() const { return New(NULL); }

  UnitOrder* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnitOrder& from);
  void MergeFrom(const UnitOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnitOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::uint32 ability_id() const;
  void set_ability_id(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.Point target_world_space_pos = 2;
  bool has_target_world_space_pos() const;
  void clear_target_world_space_pos();
  static const int kTargetWorldSpacePosFieldNumber = 2;
  const ::SC2APIProtocol::Point& target_world_space_pos() const;
  ::SC2APIProtocol::Point* mutable_target_world_space_pos();
  ::SC2APIProtocol::Point* release_target_world_space_pos();
  void set_allocated_target_world_space_pos(::SC2APIProtocol::Point* target_world_space_pos);

  // optional uint64 target_unit_tag = 3;
  bool has_target_unit_tag() const;
  void clear_target_unit_tag();
  static const int kTargetUnitTagFieldNumber = 3;
  ::google::protobuf::uint64 target_unit_tag() const;
  void set_target_unit_tag(::google::protobuf::uint64 value);

  // optional float progress = 4;
  bool has_progress() const;
  void clear_progress();
  static const int kProgressFieldNumber = 4;
  float progress() const;
  void set_progress(float value);

  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.UnitOrder)
 private:
  inline void set_has_ability_id();
  inline void clear_has_ability_id();
  inline void set_has_target_world_space_pos();
  inline void set_has_target_unit_tag();
  inline void set_has_progress();
  inline void clear_has_progress();

  inline bool has_target() const;
  void clear_target();
  inline void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ability_id_;
  float progress_;
  union TargetUnion {
    TargetUnion() {}
    ::SC2APIProtocol::Point* target_world_space_pos_;
    ::google::protobuf::uint64 target_unit_tag_;
  } target_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static UnitOrder* default_instance_;
};
// -------------------------------------------------------------------

class PassengerUnit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PassengerUnit) */ {
 public:
  PassengerUnit();
  virtual ~PassengerUnit();

  PassengerUnit(const PassengerUnit& from);

  inline PassengerUnit& operator=(const PassengerUnit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassengerUnit& default_instance();

  void Swap(PassengerUnit* other);

  // implements Message ----------------------------------------------

  inline PassengerUnit* New() const { return New(NULL); }

  PassengerUnit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PassengerUnit& from);
  void MergeFrom(const PassengerUnit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PassengerUnit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::uint64 tag() const;
  void set_tag(::google::protobuf::uint64 value);

  // optional float health = 2;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 2;
  float health() const;
  void set_health(float value);

  // optional float health_max = 3;
  bool has_health_max() const;
  void clear_health_max();
  static const int kHealthMaxFieldNumber = 3;
  float health_max() const;
  void set_health_max(float value);

  // optional float shield = 4;
  bool has_shield() const;
  void clear_shield();
  static const int kShieldFieldNumber = 4;
  float shield() const;
  void set_shield(float value);

  // optional float energy = 5;
  bool has_energy() const;
  void clear_energy();
  static const int kEnergyFieldNumber = 5;
  float energy() const;
  void set_energy(float value);

  // optional uint32 unit_type = 6;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 6;
  ::google::protobuf::uint32 unit_type() const;
  void set_unit_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PassengerUnit)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_health_max();
  inline void clear_has_health_max();
  inline void set_has_shield();
  inline void clear_has_shield();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_unit_type();
  inline void clear_has_unit_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 tag_;
  float health_;
  float health_max_;
  float shield_;
  float energy_;
  ::google::protobuf::uint32 unit_type_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static PassengerUnit* default_instance_;
};
// -------------------------------------------------------------------

class Unit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Unit) */ {
 public:
  Unit();
  virtual ~Unit();

  Unit(const Unit& from);

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Unit& default_instance();

  void Swap(Unit* other);

  // implements Message ----------------------------------------------

  inline Unit* New() const { return New(NULL); }

  Unit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Unit& from);
  void MergeFrom(const Unit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Unit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.DisplayType display_type = 1;
  bool has_display_type() const;
  void clear_display_type();
  static const int kDisplayTypeFieldNumber = 1;
  ::SC2APIProtocol::DisplayType display_type() const;
  void set_display_type(::SC2APIProtocol::DisplayType value);

  // optional .SC2APIProtocol.Alliance alliance = 2;
  bool has_alliance() const;
  void clear_alliance();
  static const int kAllianceFieldNumber = 2;
  ::SC2APIProtocol::Alliance alliance() const;
  void set_alliance(::SC2APIProtocol::Alliance value);

  // optional uint64 tag = 3;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 3;
  ::google::protobuf::uint64 tag() const;
  void set_tag(::google::protobuf::uint64 value);

  // optional uint32 unit_type = 4;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 4;
  ::google::protobuf::uint32 unit_type() const;
  void set_unit_type(::google::protobuf::uint32 value);

  // optional int32 owner = 5;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 5;
  ::google::protobuf::int32 owner() const;
  void set_owner(::google::protobuf::int32 value);

  // optional .SC2APIProtocol.Point pos = 6;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 6;
  const ::SC2APIProtocol::Point& pos() const;
  ::SC2APIProtocol::Point* mutable_pos();
  ::SC2APIProtocol::Point* release_pos();
  void set_allocated_pos(::SC2APIProtocol::Point* pos);

  // optional float facing = 7;
  bool has_facing() const;
  void clear_facing();
  static const int kFacingFieldNumber = 7;
  float facing() const;
  void set_facing(float value);

  // optional float radius = 8;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 8;
  float radius() const;
  void set_radius(float value);

  // optional float build_progress = 9;
  bool has_build_progress() const;
  void clear_build_progress();
  static const int kBuildProgressFieldNumber = 9;
  float build_progress() const;
  void set_build_progress(float value);

  // optional .SC2APIProtocol.CloakState cloak = 10;
  bool has_cloak() const;
  void clear_cloak();
  static const int kCloakFieldNumber = 10;
  ::SC2APIProtocol::CloakState cloak() const;
  void set_cloak(::SC2APIProtocol::CloakState value);

  // optional float detect_range = 31;
  bool has_detect_range() const;
  void clear_detect_range();
  static const int kDetectRangeFieldNumber = 31;
  float detect_range() const;
  void set_detect_range(float value);

  // optional float radar_range = 32;
  bool has_radar_range() const;
  void clear_radar_range();
  static const int kRadarRangeFieldNumber = 32;
  float radar_range() const;
  void set_radar_range(float value);

  // optional bool is_selected = 11;
  bool has_is_selected() const;
  void clear_is_selected();
  static const int kIsSelectedFieldNumber = 11;
  bool is_selected() const;
  void set_is_selected(bool value);

  // optional bool is_on_screen = 12;
  bool has_is_on_screen() const;
  void clear_is_on_screen();
  static const int kIsOnScreenFieldNumber = 12;
  bool is_on_screen() const;
  void set_is_on_screen(bool value);

  // optional bool is_blip = 13;
  bool has_is_blip() const;
  void clear_is_blip();
  static const int kIsBlipFieldNumber = 13;
  bool is_blip() const;
  void set_is_blip(bool value);

  // optional bool is_powered = 35;
  bool has_is_powered() const;
  void clear_is_powered();
  static const int kIsPoweredFieldNumber = 35;
  bool is_powered() const;
  void set_is_powered(bool value);

  // optional float health = 14;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 14;
  float health() const;
  void set_health(float value);

  // optional float health_max = 15;
  bool has_health_max() const;
  void clear_health_max();
  static const int kHealthMaxFieldNumber = 15;
  float health_max() const;
  void set_health_max(float value);

  // optional float shield = 16;
  bool has_shield() const;
  void clear_shield();
  static const int kShieldFieldNumber = 16;
  float shield() const;
  void set_shield(float value);

  // optional float energy = 17;
  bool has_energy() const;
  void clear_energy();
  static const int kEnergyFieldNumber = 17;
  float energy() const;
  void set_energy(float value);

  // optional int32 mineral_contents = 18;
  bool has_mineral_contents() const;
  void clear_mineral_contents();
  static const int kMineralContentsFieldNumber = 18;
  ::google::protobuf::int32 mineral_contents() const;
  void set_mineral_contents(::google::protobuf::int32 value);

  // optional int32 vespene_contents = 19;
  bool has_vespene_contents() const;
  void clear_vespene_contents();
  static const int kVespeneContentsFieldNumber = 19;
  ::google::protobuf::int32 vespene_contents() const;
  void set_vespene_contents(::google::protobuf::int32 value);

  // optional bool is_flying = 20;
  bool has_is_flying() const;
  void clear_is_flying();
  static const int kIsFlyingFieldNumber = 20;
  bool is_flying() const;
  void set_is_flying(bool value);

  // optional bool is_burrowed = 21;
  bool has_is_burrowed() const;
  void clear_is_burrowed();
  static const int kIsBurrowedFieldNumber = 21;
  bool is_burrowed() const;
  void set_is_burrowed(bool value);

  // repeated .SC2APIProtocol.UnitOrder orders = 22;
  int orders_size() const;
  void clear_orders();
  static const int kOrdersFieldNumber = 22;
  const ::SC2APIProtocol::UnitOrder& orders(int index) const;
  ::SC2APIProtocol::UnitOrder* mutable_orders(int index);
  ::SC2APIProtocol::UnitOrder* add_orders();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitOrder >*
      mutable_orders();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitOrder >&
      orders() const;

  // optional uint64 add_on_tag = 23;
  bool has_add_on_tag() const;
  void clear_add_on_tag();
  static const int kAddOnTagFieldNumber = 23;
  ::google::protobuf::uint64 add_on_tag() const;
  void set_add_on_tag(::google::protobuf::uint64 value);

  // repeated .SC2APIProtocol.PassengerUnit passengers = 24;
  int passengers_size() const;
  void clear_passengers();
  static const int kPassengersFieldNumber = 24;
  const ::SC2APIProtocol::PassengerUnit& passengers(int index) const;
  ::SC2APIProtocol::PassengerUnit* mutable_passengers(int index);
  ::SC2APIProtocol::PassengerUnit* add_passengers();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit >*
      mutable_passengers();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit >&
      passengers() const;

  // optional int32 cargo_space_taken = 25;
  bool has_cargo_space_taken() const;
  void clear_cargo_space_taken();
  static const int kCargoSpaceTakenFieldNumber = 25;
  ::google::protobuf::int32 cargo_space_taken() const;
  void set_cargo_space_taken(::google::protobuf::int32 value);

  // optional int32 cargo_space_max = 26;
  bool has_cargo_space_max() const;
  void clear_cargo_space_max();
  static const int kCargoSpaceMaxFieldNumber = 26;
  ::google::protobuf::int32 cargo_space_max() const;
  void set_cargo_space_max(::google::protobuf::int32 value);

  // repeated uint32 buff_ids = 27;
  int buff_ids_size() const;
  void clear_buff_ids();
  static const int kBuffIdsFieldNumber = 27;
  ::google::protobuf::uint32 buff_ids(int index) const;
  void set_buff_ids(int index, ::google::protobuf::uint32 value);
  void add_buff_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      buff_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_buff_ids();

  // optional int32 assigned_harvesters = 28;
  bool has_assigned_harvesters() const;
  void clear_assigned_harvesters();
  static const int kAssignedHarvestersFieldNumber = 28;
  ::google::protobuf::int32 assigned_harvesters() const;
  void set_assigned_harvesters(::google::protobuf::int32 value);

  // optional int32 ideal_harvesters = 29;
  bool has_ideal_harvesters() const;
  void clear_ideal_harvesters();
  static const int kIdealHarvestersFieldNumber = 29;
  ::google::protobuf::int32 ideal_harvesters() const;
  void set_ideal_harvesters(::google::protobuf::int32 value);

  // optional float weapon_cooldown = 30;
  bool has_weapon_cooldown() const;
  void clear_weapon_cooldown();
  static const int kWeaponCooldownFieldNumber = 30;
  float weapon_cooldown() const;
  void set_weapon_cooldown(float value);

  // optional uint64 engaged_target_tag = 34;
  bool has_engaged_target_tag() const;
  void clear_engaged_target_tag();
  static const int kEngagedTargetTagFieldNumber = 34;
  ::google::protobuf::uint64 engaged_target_tag() const;
  void set_engaged_target_tag(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Unit)
 private:
  inline void set_has_display_type();
  inline void clear_has_display_type();
  inline void set_has_alliance();
  inline void clear_has_alliance();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_unit_type();
  inline void clear_has_unit_type();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_facing();
  inline void clear_has_facing();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_build_progress();
  inline void clear_has_build_progress();
  inline void set_has_cloak();
  inline void clear_has_cloak();
  inline void set_has_detect_range();
  inline void clear_has_detect_range();
  inline void set_has_radar_range();
  inline void clear_has_radar_range();
  inline void set_has_is_selected();
  inline void clear_has_is_selected();
  inline void set_has_is_on_screen();
  inline void clear_has_is_on_screen();
  inline void set_has_is_blip();
  inline void clear_has_is_blip();
  inline void set_has_is_powered();
  inline void clear_has_is_powered();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_health_max();
  inline void clear_has_health_max();
  inline void set_has_shield();
  inline void clear_has_shield();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_mineral_contents();
  inline void clear_has_mineral_contents();
  inline void set_has_vespene_contents();
  inline void clear_has_vespene_contents();
  inline void set_has_is_flying();
  inline void clear_has_is_flying();
  inline void set_has_is_burrowed();
  inline void clear_has_is_burrowed();
  inline void set_has_add_on_tag();
  inline void clear_has_add_on_tag();
  inline void set_has_cargo_space_taken();
  inline void clear_has_cargo_space_taken();
  inline void set_has_cargo_space_max();
  inline void clear_has_cargo_space_max();
  inline void set_has_assigned_harvesters();
  inline void clear_has_assigned_harvesters();
  inline void set_has_ideal_harvesters();
  inline void clear_has_ideal_harvesters();
  inline void set_has_weapon_cooldown();
  inline void clear_has_weapon_cooldown();
  inline void set_has_engaged_target_tag();
  inline void clear_has_engaged_target_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[2];
  int display_type_;
  int alliance_;
  ::google::protobuf::uint64 tag_;
  ::google::protobuf::uint32 unit_type_;
  ::google::protobuf::int32 owner_;
  ::SC2APIProtocol::Point* pos_;
  float facing_;
  float radius_;
  float build_progress_;
  int cloak_;
  float detect_range_;
  float radar_range_;
  bool is_selected_;
  bool is_on_screen_;
  bool is_blip_;
  bool is_powered_;
  float health_;
  float health_max_;
  float shield_;
  float energy_;
  ::google::protobuf::int32 mineral_contents_;
  ::google::protobuf::int32 vespene_contents_;
  bool is_flying_;
  bool is_burrowed_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitOrder > orders_;
  ::google::protobuf::uint64 add_on_tag_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit > passengers_;
  ::google::protobuf::int32 cargo_space_taken_;
  ::google::protobuf::int32 cargo_space_max_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > buff_ids_;
  ::google::protobuf::int32 assigned_harvesters_;
  ::google::protobuf::int32 ideal_harvesters_;
  ::google::protobuf::uint64 engaged_target_tag_;
  float weapon_cooldown_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static Unit* default_instance_;
};
// -------------------------------------------------------------------

class MapState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.MapState) */ {
 public:
  MapState();
  virtual ~MapState();

  MapState(const MapState& from);

  inline MapState& operator=(const MapState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapState& default_instance();

  void Swap(MapState* other);

  // implements Message ----------------------------------------------

  inline MapState* New() const { return New(NULL); }

  MapState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapState& from);
  void MergeFrom(const MapState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ImageData visibility = 1;
  bool has_visibility() const;
  void clear_visibility();
  static const int kVisibilityFieldNumber = 1;
  const ::SC2APIProtocol::ImageData& visibility() const;
  ::SC2APIProtocol::ImageData* mutable_visibility();
  ::SC2APIProtocol::ImageData* release_visibility();
  void set_allocated_visibility(::SC2APIProtocol::ImageData* visibility);

  // optional .SC2APIProtocol.ImageData creep = 2;
  bool has_creep() const;
  void clear_creep();
  static const int kCreepFieldNumber = 2;
  const ::SC2APIProtocol::ImageData& creep() const;
  ::SC2APIProtocol::ImageData* mutable_creep();
  ::SC2APIProtocol::ImageData* release_creep();
  void set_allocated_creep(::SC2APIProtocol::ImageData* creep);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.MapState)
 private:
  inline void set_has_visibility();
  inline void clear_has_visibility();
  inline void set_has_creep();
  inline void clear_has_creep();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::ImageData* visibility_;
  ::SC2APIProtocol::ImageData* creep_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static MapState* default_instance_;
};
// -------------------------------------------------------------------

class ActionRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionRaw) */ {
 public:
  ActionRaw();
  virtual ~ActionRaw();

  ActionRaw(const ActionRaw& from);

  inline ActionRaw& operator=(const ActionRaw& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRaw& default_instance();

  enum ActionCase {
    kUnitCommand = 1,
    kCameraMove = 2,
    kToggleAutocast = 3,
    ACTION_NOT_SET = 0,
  };

  void Swap(ActionRaw* other);

  // implements Message ----------------------------------------------

  inline ActionRaw* New() const { return New(NULL); }

  ActionRaw* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionRaw& from);
  void MergeFrom(const ActionRaw& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;
  bool has_unit_command() const;
  void clear_unit_command();
  static const int kUnitCommandFieldNumber = 1;
  const ::SC2APIProtocol::ActionRawUnitCommand& unit_command() const;
  ::SC2APIProtocol::ActionRawUnitCommand* mutable_unit_command();
  ::SC2APIProtocol::ActionRawUnitCommand* release_unit_command();
  void set_allocated_unit_command(::SC2APIProtocol::ActionRawUnitCommand* unit_command);

  // optional .SC2APIProtocol.ActionRawCameraMove camera_move = 2;
  bool has_camera_move() const;
  void clear_camera_move();
  static const int kCameraMoveFieldNumber = 2;
  const ::SC2APIProtocol::ActionRawCameraMove& camera_move() const;
  ::SC2APIProtocol::ActionRawCameraMove* mutable_camera_move();
  ::SC2APIProtocol::ActionRawCameraMove* release_camera_move();
  void set_allocated_camera_move(::SC2APIProtocol::ActionRawCameraMove* camera_move);

  // optional .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
  bool has_toggle_autocast() const;
  void clear_toggle_autocast();
  static const int kToggleAutocastFieldNumber = 3;
  const ::SC2APIProtocol::ActionRawToggleAutocast& toggle_autocast() const;
  ::SC2APIProtocol::ActionRawToggleAutocast* mutable_toggle_autocast();
  ::SC2APIProtocol::ActionRawToggleAutocast* release_toggle_autocast();
  void set_allocated_toggle_autocast(::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast);

  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionRaw)
 private:
  inline void set_has_unit_command();
  inline void set_has_camera_move();
  inline void set_has_toggle_autocast();

  inline bool has_action() const;
  void clear_action();
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SC2APIProtocol::ActionRawUnitCommand* unit_command_;
    ::SC2APIProtocol::ActionRawCameraMove* camera_move_;
    ::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast_;
  } action_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static ActionRaw* default_instance_;
};
// -------------------------------------------------------------------

class ActionRawUnitCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionRawUnitCommand) */ {
 public:
  ActionRawUnitCommand();
  virtual ~ActionRawUnitCommand();

  ActionRawUnitCommand(const ActionRawUnitCommand& from);

  inline ActionRawUnitCommand& operator=(const ActionRawUnitCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRawUnitCommand& default_instance();

  enum TargetCase {
    kTargetWorldSpacePos = 2,
    kTargetUnitTag = 3,
    TARGET_NOT_SET = 0,
  };

  void Swap(ActionRawUnitCommand* other);

  // implements Message ----------------------------------------------

  inline ActionRawUnitCommand* New() const { return New(NULL); }

  ActionRawUnitCommand* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionRawUnitCommand& from);
  void MergeFrom(const ActionRawUnitCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionRawUnitCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::int32 ability_id() const;
  void set_ability_id(::google::protobuf::int32 value);

  // optional .SC2APIProtocol.Point2D target_world_space_pos = 2;
  bool has_target_world_space_pos() const;
  void clear_target_world_space_pos();
  static const int kTargetWorldSpacePosFieldNumber = 2;
  const ::SC2APIProtocol::Point2D& target_world_space_pos() const;
  ::SC2APIProtocol::Point2D* mutable_target_world_space_pos();
  ::SC2APIProtocol::Point2D* release_target_world_space_pos();
  void set_allocated_target_world_space_pos(::SC2APIProtocol::Point2D* target_world_space_pos);

  // optional uint64 target_unit_tag = 3;
  bool has_target_unit_tag() const;
  void clear_target_unit_tag();
  static const int kTargetUnitTagFieldNumber = 3;
  ::google::protobuf::uint64 target_unit_tag() const;
  void set_target_unit_tag(::google::protobuf::uint64 value);

  // repeated uint64 unit_tags = 4;
  int unit_tags_size() const;
  void clear_unit_tags();
  static const int kUnitTagsFieldNumber = 4;
  ::google::protobuf::uint64 unit_tags(int index) const;
  void set_unit_tags(int index, ::google::protobuf::uint64 value);
  void add_unit_tags(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      unit_tags() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_unit_tags();

  // optional bool queue_command = 5;
  bool has_queue_command() const;
  void clear_queue_command();
  static const int kQueueCommandFieldNumber = 5;
  bool queue_command() const;
  void set_queue_command(bool value);

  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionRawUnitCommand)
 private:
  inline void set_has_ability_id();
  inline void clear_has_ability_id();
  inline void set_has_target_world_space_pos();
  inline void set_has_target_unit_tag();
  inline void set_has_queue_command();
  inline void clear_has_queue_command();

  inline bool has_target() const;
  void clear_target();
  inline void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > unit_tags_;
  ::google::protobuf::int32 ability_id_;
  bool queue_command_;
  union TargetUnion {
    TargetUnion() {}
    ::SC2APIProtocol::Point2D* target_world_space_pos_;
    ::google::protobuf::uint64 target_unit_tag_;
  } target_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static ActionRawUnitCommand* default_instance_;
};
// -------------------------------------------------------------------

class ActionRawCameraMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionRawCameraMove) */ {
 public:
  ActionRawCameraMove();
  virtual ~ActionRawCameraMove();

  ActionRawCameraMove(const ActionRawCameraMove& from);

  inline ActionRawCameraMove& operator=(const ActionRawCameraMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRawCameraMove& default_instance();

  void Swap(ActionRawCameraMove* other);

  // implements Message ----------------------------------------------

  inline ActionRawCameraMove* New() const { return New(NULL); }

  ActionRawCameraMove* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionRawCameraMove& from);
  void MergeFrom(const ActionRawCameraMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionRawCameraMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.Point center_world_space = 1;
  bool has_center_world_space() const;
  void clear_center_world_space();
  static const int kCenterWorldSpaceFieldNumber = 1;
  const ::SC2APIProtocol::Point& center_world_space() const;
  ::SC2APIProtocol::Point* mutable_center_world_space();
  ::SC2APIProtocol::Point* release_center_world_space();
  void set_allocated_center_world_space(::SC2APIProtocol::Point* center_world_space);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionRawCameraMove)
 private:
  inline void set_has_center_world_space();
  inline void clear_has_center_world_space();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::Point* center_world_space_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static ActionRawCameraMove* default_instance_;
};
// -------------------------------------------------------------------

class ActionRawToggleAutocast : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionRawToggleAutocast) */ {
 public:
  ActionRawToggleAutocast();
  virtual ~ActionRawToggleAutocast();

  ActionRawToggleAutocast(const ActionRawToggleAutocast& from);

  inline ActionRawToggleAutocast& operator=(const ActionRawToggleAutocast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRawToggleAutocast& default_instance();

  void Swap(ActionRawToggleAutocast* other);

  // implements Message ----------------------------------------------

  inline ActionRawToggleAutocast* New() const { return New(NULL); }

  ActionRawToggleAutocast* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionRawToggleAutocast& from);
  void MergeFrom(const ActionRawToggleAutocast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionRawToggleAutocast* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::int32 ability_id() const;
  void set_ability_id(::google::protobuf::int32 value);

  // repeated uint64 unit_tags = 2;
  int unit_tags_size() const;
  void clear_unit_tags();
  static const int kUnitTagsFieldNumber = 2;
  ::google::protobuf::uint64 unit_tags(int index) const;
  void set_unit_tags(int index, ::google::protobuf::uint64 value);
  void add_unit_tags(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      unit_tags() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_unit_tags();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionRawToggleAutocast)
 private:
  inline void set_has_ability_id();
  inline void clear_has_ability_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > unit_tags_;
  ::google::protobuf::int32 ability_id_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static ActionRawToggleAutocast* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  inline Event* New() const { return New(NULL); }

  Event* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 dead_units = 1;
  int dead_units_size() const;
  void clear_dead_units();
  static const int kDeadUnitsFieldNumber = 1;
  ::google::protobuf::uint64 dead_units(int index) const;
  void set_dead_units(int index, ::google::protobuf::uint64 value);
  void add_dead_units(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      dead_units() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_dead_units();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > dead_units_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fraw_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fraw_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// StartRaw

// optional .SC2APIProtocol.Size2DI map_size = 1;
inline bool StartRaw::has_map_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartRaw::set_has_map_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartRaw::clear_has_map_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartRaw::clear_map_size() {
  if (map_size_ != NULL) map_size_->::SC2APIProtocol::Size2DI::Clear();
  clear_has_map_size();
}
inline const ::SC2APIProtocol::Size2DI& StartRaw::map_size() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.map_size)
  return map_size_ != NULL ? *map_size_ : *default_instance_->map_size_;
}
inline ::SC2APIProtocol::Size2DI* StartRaw::mutable_map_size() {
  set_has_map_size();
  if (map_size_ == NULL) {
    map_size_ = new ::SC2APIProtocol::Size2DI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.map_size)
  return map_size_;
}
inline ::SC2APIProtocol::Size2DI* StartRaw::release_map_size() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.map_size)
  clear_has_map_size();
  ::SC2APIProtocol::Size2DI* temp = map_size_;
  map_size_ = NULL;
  return temp;
}
inline void StartRaw::set_allocated_map_size(::SC2APIProtocol::Size2DI* map_size) {
  delete map_size_;
  map_size_ = map_size;
  if (map_size) {
    set_has_map_size();
  } else {
    clear_has_map_size();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.map_size)
}

// optional .SC2APIProtocol.ImageData pathing_grid = 2;
inline bool StartRaw::has_pathing_grid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartRaw::set_has_pathing_grid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartRaw::clear_has_pathing_grid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartRaw::clear_pathing_grid() {
  if (pathing_grid_ != NULL) pathing_grid_->::SC2APIProtocol::ImageData::Clear();
  clear_has_pathing_grid();
}
inline const ::SC2APIProtocol::ImageData& StartRaw::pathing_grid() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.pathing_grid)
  return pathing_grid_ != NULL ? *pathing_grid_ : *default_instance_->pathing_grid_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::mutable_pathing_grid() {
  set_has_pathing_grid();
  if (pathing_grid_ == NULL) {
    pathing_grid_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.pathing_grid)
  return pathing_grid_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::release_pathing_grid() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.pathing_grid)
  clear_has_pathing_grid();
  ::SC2APIProtocol::ImageData* temp = pathing_grid_;
  pathing_grid_ = NULL;
  return temp;
}
inline void StartRaw::set_allocated_pathing_grid(::SC2APIProtocol::ImageData* pathing_grid) {
  delete pathing_grid_;
  pathing_grid_ = pathing_grid;
  if (pathing_grid) {
    set_has_pathing_grid();
  } else {
    clear_has_pathing_grid();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.pathing_grid)
}

// optional .SC2APIProtocol.ImageData terrain_height = 3;
inline bool StartRaw::has_terrain_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartRaw::set_has_terrain_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartRaw::clear_has_terrain_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartRaw::clear_terrain_height() {
  if (terrain_height_ != NULL) terrain_height_->::SC2APIProtocol::ImageData::Clear();
  clear_has_terrain_height();
}
inline const ::SC2APIProtocol::ImageData& StartRaw::terrain_height() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.terrain_height)
  return terrain_height_ != NULL ? *terrain_height_ : *default_instance_->terrain_height_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::mutable_terrain_height() {
  set_has_terrain_height();
  if (terrain_height_ == NULL) {
    terrain_height_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.terrain_height)
  return terrain_height_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::release_terrain_height() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.terrain_height)
  clear_has_terrain_height();
  ::SC2APIProtocol::ImageData* temp = terrain_height_;
  terrain_height_ = NULL;
  return temp;
}
inline void StartRaw::set_allocated_terrain_height(::SC2APIProtocol::ImageData* terrain_height) {
  delete terrain_height_;
  terrain_height_ = terrain_height;
  if (terrain_height) {
    set_has_terrain_height();
  } else {
    clear_has_terrain_height();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.terrain_height)
}

// optional .SC2APIProtocol.ImageData placement_grid = 4;
inline bool StartRaw::has_placement_grid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartRaw::set_has_placement_grid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartRaw::clear_has_placement_grid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartRaw::clear_placement_grid() {
  if (placement_grid_ != NULL) placement_grid_->::SC2APIProtocol::ImageData::Clear();
  clear_has_placement_grid();
}
inline const ::SC2APIProtocol::ImageData& StartRaw::placement_grid() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.placement_grid)
  return placement_grid_ != NULL ? *placement_grid_ : *default_instance_->placement_grid_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::mutable_placement_grid() {
  set_has_placement_grid();
  if (placement_grid_ == NULL) {
    placement_grid_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.placement_grid)
  return placement_grid_;
}
inline ::SC2APIProtocol::ImageData* StartRaw::release_placement_grid() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.placement_grid)
  clear_has_placement_grid();
  ::SC2APIProtocol::ImageData* temp = placement_grid_;
  placement_grid_ = NULL;
  return temp;
}
inline void StartRaw::set_allocated_placement_grid(::SC2APIProtocol::ImageData* placement_grid) {
  delete placement_grid_;
  placement_grid_ = placement_grid;
  if (placement_grid) {
    set_has_placement_grid();
  } else {
    clear_has_placement_grid();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.placement_grid)
}

// optional .SC2APIProtocol.RectangleI playable_area = 5;
inline bool StartRaw::has_playable_area() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartRaw::set_has_playable_area() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartRaw::clear_has_playable_area() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartRaw::clear_playable_area() {
  if (playable_area_ != NULL) playable_area_->::SC2APIProtocol::RectangleI::Clear();
  clear_has_playable_area();
}
inline const ::SC2APIProtocol::RectangleI& StartRaw::playable_area() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.playable_area)
  return playable_area_ != NULL ? *playable_area_ : *default_instance_->playable_area_;
}
inline ::SC2APIProtocol::RectangleI* StartRaw::mutable_playable_area() {
  set_has_playable_area();
  if (playable_area_ == NULL) {
    playable_area_ = new ::SC2APIProtocol::RectangleI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.playable_area)
  return playable_area_;
}
inline ::SC2APIProtocol::RectangleI* StartRaw::release_playable_area() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.StartRaw.playable_area)
  clear_has_playable_area();
  ::SC2APIProtocol::RectangleI* temp = playable_area_;
  playable_area_ = NULL;
  return temp;
}
inline void StartRaw::set_allocated_playable_area(::SC2APIProtocol::RectangleI* playable_area) {
  delete playable_area_;
  playable_area_ = playable_area;
  if (playable_area) {
    set_has_playable_area();
  } else {
    clear_has_playable_area();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.StartRaw.playable_area)
}

// repeated .SC2APIProtocol.Point2D start_locations = 6;
inline int StartRaw::start_locations_size() const {
  return start_locations_.size();
}
inline void StartRaw::clear_start_locations() {
  start_locations_.Clear();
}
inline const ::SC2APIProtocol::Point2D& StartRaw::start_locations(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.StartRaw.start_locations)
  return start_locations_.Get(index);
}
inline ::SC2APIProtocol::Point2D* StartRaw::mutable_start_locations(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.StartRaw.start_locations)
  return start_locations_.Mutable(index);
}
inline ::SC2APIProtocol::Point2D* StartRaw::add_start_locations() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.StartRaw.start_locations)
  return start_locations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Point2D >*
StartRaw::mutable_start_locations() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.StartRaw.start_locations)
  return &start_locations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Point2D >&
StartRaw::start_locations() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.StartRaw.start_locations)
  return start_locations_;
}

// -------------------------------------------------------------------

// ObservationRaw

// optional .SC2APIProtocol.PlayerRaw player = 1;
inline bool ObservationRaw::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservationRaw::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservationRaw::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservationRaw::clear_player() {
  if (player_ != NULL) player_->::SC2APIProtocol::PlayerRaw::Clear();
  clear_has_player();
}
inline const ::SC2APIProtocol::PlayerRaw& ObservationRaw::player() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.player)
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::SC2APIProtocol::PlayerRaw* ObservationRaw::mutable_player() {
  set_has_player();
  if (player_ == NULL) {
    player_ = new ::SC2APIProtocol::PlayerRaw;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.player)
  return player_;
}
inline ::SC2APIProtocol::PlayerRaw* ObservationRaw::release_player() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRaw.player)
  clear_has_player();
  ::SC2APIProtocol::PlayerRaw* temp = player_;
  player_ = NULL;
  return temp;
}
inline void ObservationRaw::set_allocated_player(::SC2APIProtocol::PlayerRaw* player) {
  delete player_;
  player_ = player;
  if (player) {
    set_has_player();
  } else {
    clear_has_player();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRaw.player)
}

// repeated .SC2APIProtocol.Unit units = 2;
inline int ObservationRaw::units_size() const {
  return units_.size();
}
inline void ObservationRaw::clear_units() {
  units_.Clear();
}
inline const ::SC2APIProtocol::Unit& ObservationRaw::units(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.units)
  return units_.Get(index);
}
inline ::SC2APIProtocol::Unit* ObservationRaw::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.units)
  return units_.Mutable(index);
}
inline ::SC2APIProtocol::Unit* ObservationRaw::add_units() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ObservationRaw.units)
  return units_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Unit >*
ObservationRaw::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ObservationRaw.units)
  return &units_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Unit >&
ObservationRaw::units() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ObservationRaw.units)
  return units_;
}

// optional .SC2APIProtocol.MapState map_state = 3;
inline bool ObservationRaw::has_map_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObservationRaw::set_has_map_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObservationRaw::clear_has_map_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObservationRaw::clear_map_state() {
  if (map_state_ != NULL) map_state_->::SC2APIProtocol::MapState::Clear();
  clear_has_map_state();
}
inline const ::SC2APIProtocol::MapState& ObservationRaw::map_state() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.map_state)
  return map_state_ != NULL ? *map_state_ : *default_instance_->map_state_;
}
inline ::SC2APIProtocol::MapState* ObservationRaw::mutable_map_state() {
  set_has_map_state();
  if (map_state_ == NULL) {
    map_state_ = new ::SC2APIProtocol::MapState;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.map_state)
  return map_state_;
}
inline ::SC2APIProtocol::MapState* ObservationRaw::release_map_state() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRaw.map_state)
  clear_has_map_state();
  ::SC2APIProtocol::MapState* temp = map_state_;
  map_state_ = NULL;
  return temp;
}
inline void ObservationRaw::set_allocated_map_state(::SC2APIProtocol::MapState* map_state) {
  delete map_state_;
  map_state_ = map_state;
  if (map_state) {
    set_has_map_state();
  } else {
    clear_has_map_state();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRaw.map_state)
}

// optional .SC2APIProtocol.Event event = 4;
inline bool ObservationRaw::has_event() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObservationRaw::set_has_event() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObservationRaw::clear_has_event() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObservationRaw::clear_event() {
  if (event_ != NULL) event_->::SC2APIProtocol::Event::Clear();
  clear_has_event();
}
inline const ::SC2APIProtocol::Event& ObservationRaw::event() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRaw.event)
  return event_ != NULL ? *event_ : *default_instance_->event_;
}
inline ::SC2APIProtocol::Event* ObservationRaw::mutable_event() {
  set_has_event();
  if (event_ == NULL) {
    event_ = new ::SC2APIProtocol::Event;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRaw.event)
  return event_;
}
inline ::SC2APIProtocol::Event* ObservationRaw::release_event() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRaw.event)
  clear_has_event();
  ::SC2APIProtocol::Event* temp = event_;
  event_ = NULL;
  return temp;
}
inline void ObservationRaw::set_allocated_event(::SC2APIProtocol::Event* event) {
  delete event_;
  event_ = event;
  if (event) {
    set_has_event();
  } else {
    clear_has_event();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRaw.event)
}

// -------------------------------------------------------------------

// PowerSource

// optional .SC2APIProtocol.Point pos = 1;
inline bool PowerSource::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PowerSource::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PowerSource::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PowerSource::clear_pos() {
  if (pos_ != NULL) pos_->::SC2APIProtocol::Point::Clear();
  clear_has_pos();
}
inline const ::SC2APIProtocol::Point& PowerSource::pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PowerSource.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::SC2APIProtocol::Point* PowerSource::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::SC2APIProtocol::Point;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PowerSource.pos)
  return pos_;
}
inline ::SC2APIProtocol::Point* PowerSource::release_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PowerSource.pos)
  clear_has_pos();
  ::SC2APIProtocol::Point* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void PowerSource::set_allocated_pos(::SC2APIProtocol::Point* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PowerSource.pos)
}

// optional float radius = 2;
inline bool PowerSource::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PowerSource::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PowerSource::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PowerSource::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float PowerSource::radius() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PowerSource.radius)
  return radius_;
}
inline void PowerSource::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PowerSource.radius)
}

// optional uint64 tag = 3;
inline bool PowerSource::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PowerSource::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PowerSource::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PowerSource::clear_tag() {
  tag_ = GOOGLE_ULONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::uint64 PowerSource::tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PowerSource.tag)
  return tag_;
}
inline void PowerSource::set_tag(::google::protobuf::uint64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PowerSource.tag)
}

// -------------------------------------------------------------------

// PlayerRaw

// repeated .SC2APIProtocol.PowerSource power_sources = 1;
inline int PlayerRaw::power_sources_size() const {
  return power_sources_.size();
}
inline void PlayerRaw::clear_power_sources() {
  power_sources_.Clear();
}
inline const ::SC2APIProtocol::PowerSource& PlayerRaw::power_sources(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerRaw.power_sources)
  return power_sources_.Get(index);
}
inline ::SC2APIProtocol::PowerSource* PlayerRaw::mutable_power_sources(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerRaw.power_sources)
  return power_sources_.Mutable(index);
}
inline ::SC2APIProtocol::PowerSource* PlayerRaw::add_power_sources() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.PlayerRaw.power_sources)
  return power_sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PowerSource >*
PlayerRaw::mutable_power_sources() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.PlayerRaw.power_sources)
  return &power_sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PowerSource >&
PlayerRaw::power_sources() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.PlayerRaw.power_sources)
  return power_sources_;
}

// optional .SC2APIProtocol.Point camera = 2;
inline bool PlayerRaw::has_camera() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerRaw::set_has_camera() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerRaw::clear_has_camera() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerRaw::clear_camera() {
  if (camera_ != NULL) camera_->::SC2APIProtocol::Point::Clear();
  clear_has_camera();
}
inline const ::SC2APIProtocol::Point& PlayerRaw::camera() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerRaw.camera)
  return camera_ != NULL ? *camera_ : *default_instance_->camera_;
}
inline ::SC2APIProtocol::Point* PlayerRaw::mutable_camera() {
  set_has_camera();
  if (camera_ == NULL) {
    camera_ = new ::SC2APIProtocol::Point;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerRaw.camera)
  return camera_;
}
inline ::SC2APIProtocol::Point* PlayerRaw::release_camera() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerRaw.camera)
  clear_has_camera();
  ::SC2APIProtocol::Point* temp = camera_;
  camera_ = NULL;
  return temp;
}
inline void PlayerRaw::set_allocated_camera(::SC2APIProtocol::Point* camera) {
  delete camera_;
  camera_ = camera;
  if (camera) {
    set_has_camera();
  } else {
    clear_has_camera();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerRaw.camera)
}

// repeated uint32 upgrade_ids = 3;
inline int PlayerRaw::upgrade_ids_size() const {
  return upgrade_ids_.size();
}
inline void PlayerRaw::clear_upgrade_ids() {
  upgrade_ids_.Clear();
}
inline ::google::protobuf::uint32 PlayerRaw::upgrade_ids(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerRaw.upgrade_ids)
  return upgrade_ids_.Get(index);
}
inline void PlayerRaw::set_upgrade_ids(int index, ::google::protobuf::uint32 value) {
  upgrade_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerRaw.upgrade_ids)
}
inline void PlayerRaw::add_upgrade_ids(::google::protobuf::uint32 value) {
  upgrade_ids_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.PlayerRaw.upgrade_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerRaw::upgrade_ids() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.PlayerRaw.upgrade_ids)
  return upgrade_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerRaw::mutable_upgrade_ids() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.PlayerRaw.upgrade_ids)
  return &upgrade_ids_;
}

// -------------------------------------------------------------------

// UnitOrder

// optional uint32 ability_id = 1;
inline bool UnitOrder::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitOrder::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitOrder::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitOrder::clear_ability_id() {
  ability_id_ = 0u;
  clear_has_ability_id();
}
inline ::google::protobuf::uint32 UnitOrder::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitOrder.ability_id)
  return ability_id_;
}
inline void UnitOrder::set_ability_id(::google::protobuf::uint32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitOrder.ability_id)
}

// optional .SC2APIProtocol.Point target_world_space_pos = 2;
inline bool UnitOrder::has_target_world_space_pos() const {
  return target_case() == kTargetWorldSpacePos;
}
inline void UnitOrder::set_has_target_world_space_pos() {
  _oneof_case_[0] = kTargetWorldSpacePos;
}
inline void UnitOrder::clear_target_world_space_pos() {
  if (has_target_world_space_pos()) {
    delete target_.target_world_space_pos_;
    clear_has_target();
  }
}
inline  const ::SC2APIProtocol::Point& UnitOrder::target_world_space_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitOrder.target_world_space_pos)
  return has_target_world_space_pos()
      ? *target_.target_world_space_pos_
      : ::SC2APIProtocol::Point::default_instance();
}
inline ::SC2APIProtocol::Point* UnitOrder::mutable_target_world_space_pos() {
  if (!has_target_world_space_pos()) {
    clear_target();
    set_has_target_world_space_pos();
    target_.target_world_space_pos_ = new ::SC2APIProtocol::Point;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.UnitOrder.target_world_space_pos)
  return target_.target_world_space_pos_;
}
inline ::SC2APIProtocol::Point* UnitOrder::release_target_world_space_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.UnitOrder.target_world_space_pos)
  if (has_target_world_space_pos()) {
    clear_has_target();
    ::SC2APIProtocol::Point* temp = target_.target_world_space_pos_;
    target_.target_world_space_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void UnitOrder::set_allocated_target_world_space_pos(::SC2APIProtocol::Point* target_world_space_pos) {
  clear_target();
  if (target_world_space_pos) {
    set_has_target_world_space_pos();
    target_.target_world_space_pos_ = target_world_space_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.UnitOrder.target_world_space_pos)
}

// optional uint64 target_unit_tag = 3;
inline bool UnitOrder::has_target_unit_tag() const {
  return target_case() == kTargetUnitTag;
}
inline void UnitOrder::set_has_target_unit_tag() {
  _oneof_case_[0] = kTargetUnitTag;
}
inline void UnitOrder::clear_target_unit_tag() {
  if (has_target_unit_tag()) {
    target_.target_unit_tag_ = GOOGLE_ULONGLONG(0);
    clear_has_target();
  }
}
inline ::google::protobuf::uint64 UnitOrder::target_unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitOrder.target_unit_tag)
  if (has_target_unit_tag()) {
    return target_.target_unit_tag_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void UnitOrder::set_target_unit_tag(::google::protobuf::uint64 value) {
  if (!has_target_unit_tag()) {
    clear_target();
    set_has_target_unit_tag();
  }
  target_.target_unit_tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitOrder.target_unit_tag)
}

// optional float progress = 4;
inline bool UnitOrder::has_progress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnitOrder::set_has_progress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnitOrder::clear_has_progress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnitOrder::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline float UnitOrder::progress() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitOrder.progress)
  return progress_;
}
inline void UnitOrder::set_progress(float value) {
  set_has_progress();
  progress_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitOrder.progress)
}

inline bool UnitOrder::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void UnitOrder::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline UnitOrder::TargetCase UnitOrder::target_case() const {
  return UnitOrder::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PassengerUnit

// optional uint64 tag = 1;
inline bool PassengerUnit::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassengerUnit::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassengerUnit::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassengerUnit::clear_tag() {
  tag_ = GOOGLE_ULONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::uint64 PassengerUnit::tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.tag)
  return tag_;
}
inline void PassengerUnit::set_tag(::google::protobuf::uint64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.tag)
}

// optional float health = 2;
inline bool PassengerUnit::has_health() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PassengerUnit::set_has_health() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PassengerUnit::clear_has_health() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PassengerUnit::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float PassengerUnit::health() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.health)
  return health_;
}
inline void PassengerUnit::set_health(float value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.health)
}

// optional float health_max = 3;
inline bool PassengerUnit::has_health_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PassengerUnit::set_has_health_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PassengerUnit::clear_has_health_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PassengerUnit::clear_health_max() {
  health_max_ = 0;
  clear_has_health_max();
}
inline float PassengerUnit::health_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.health_max)
  return health_max_;
}
inline void PassengerUnit::set_health_max(float value) {
  set_has_health_max();
  health_max_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.health_max)
}

// optional float shield = 4;
inline bool PassengerUnit::has_shield() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PassengerUnit::set_has_shield() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PassengerUnit::clear_has_shield() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PassengerUnit::clear_shield() {
  shield_ = 0;
  clear_has_shield();
}
inline float PassengerUnit::shield() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.shield)
  return shield_;
}
inline void PassengerUnit::set_shield(float value) {
  set_has_shield();
  shield_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.shield)
}

// optional float energy = 5;
inline bool PassengerUnit::has_energy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PassengerUnit::set_has_energy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PassengerUnit::clear_has_energy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PassengerUnit::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline float PassengerUnit::energy() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.energy)
  return energy_;
}
inline void PassengerUnit::set_energy(float value) {
  set_has_energy();
  energy_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.energy)
}

// optional uint32 unit_type = 6;
inline bool PassengerUnit::has_unit_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PassengerUnit::set_has_unit_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PassengerUnit::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PassengerUnit::clear_unit_type() {
  unit_type_ = 0u;
  clear_has_unit_type();
}
inline ::google::protobuf::uint32 PassengerUnit::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PassengerUnit.unit_type)
  return unit_type_;
}
inline void PassengerUnit::set_unit_type(::google::protobuf::uint32 value) {
  set_has_unit_type();
  unit_type_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PassengerUnit.unit_type)
}

// -------------------------------------------------------------------

// Unit

// optional .SC2APIProtocol.DisplayType display_type = 1;
inline bool Unit::has_display_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Unit::set_has_display_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Unit::clear_has_display_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Unit::clear_display_type() {
  display_type_ = 1;
  clear_has_display_type();
}
inline ::SC2APIProtocol::DisplayType Unit::display_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.display_type)
  return static_cast< ::SC2APIProtocol::DisplayType >(display_type_);
}
inline void Unit::set_display_type(::SC2APIProtocol::DisplayType value) {
  assert(::SC2APIProtocol::DisplayType_IsValid(value));
  set_has_display_type();
  display_type_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.display_type)
}

// optional .SC2APIProtocol.Alliance alliance = 2;
inline bool Unit::has_alliance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Unit::set_has_alliance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Unit::clear_has_alliance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Unit::clear_alliance() {
  alliance_ = 1;
  clear_has_alliance();
}
inline ::SC2APIProtocol::Alliance Unit::alliance() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.alliance)
  return static_cast< ::SC2APIProtocol::Alliance >(alliance_);
}
inline void Unit::set_alliance(::SC2APIProtocol::Alliance value) {
  assert(::SC2APIProtocol::Alliance_IsValid(value));
  set_has_alliance();
  alliance_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.alliance)
}

// optional uint64 tag = 3;
inline bool Unit::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Unit::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Unit::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Unit::clear_tag() {
  tag_ = GOOGLE_ULONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::uint64 Unit::tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.tag)
  return tag_;
}
inline void Unit::set_tag(::google::protobuf::uint64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.tag)
}

// optional uint32 unit_type = 4;
inline bool Unit::has_unit_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Unit::set_has_unit_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Unit::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Unit::clear_unit_type() {
  unit_type_ = 0u;
  clear_has_unit_type();
}
inline ::google::protobuf::uint32 Unit::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.unit_type)
  return unit_type_;
}
inline void Unit::set_unit_type(::google::protobuf::uint32 value) {
  set_has_unit_type();
  unit_type_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.unit_type)
}

// optional int32 owner = 5;
inline bool Unit::has_owner() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Unit::set_has_owner() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Unit::clear_has_owner() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Unit::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Unit::owner() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.owner)
  return owner_;
}
inline void Unit::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.owner)
}

// optional .SC2APIProtocol.Point pos = 6;
inline bool Unit::has_pos() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Unit::set_has_pos() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Unit::clear_has_pos() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Unit::clear_pos() {
  if (pos_ != NULL) pos_->::SC2APIProtocol::Point::Clear();
  clear_has_pos();
}
inline const ::SC2APIProtocol::Point& Unit::pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::SC2APIProtocol::Point* Unit::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::SC2APIProtocol::Point;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Unit.pos)
  return pos_;
}
inline ::SC2APIProtocol::Point* Unit::release_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Unit.pos)
  clear_has_pos();
  ::SC2APIProtocol::Point* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Unit::set_allocated_pos(::SC2APIProtocol::Point* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Unit.pos)
}

// optional float facing = 7;
inline bool Unit::has_facing() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Unit::set_has_facing() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Unit::clear_has_facing() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Unit::clear_facing() {
  facing_ = 0;
  clear_has_facing();
}
inline float Unit::facing() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.facing)
  return facing_;
}
inline void Unit::set_facing(float value) {
  set_has_facing();
  facing_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.facing)
}

// optional float radius = 8;
inline bool Unit::has_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Unit::set_has_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Unit::clear_has_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Unit::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float Unit::radius() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.radius)
  return radius_;
}
inline void Unit::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.radius)
}

// optional float build_progress = 9;
inline bool Unit::has_build_progress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Unit::set_has_build_progress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Unit::clear_has_build_progress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Unit::clear_build_progress() {
  build_progress_ = 0;
  clear_has_build_progress();
}
inline float Unit::build_progress() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.build_progress)
  return build_progress_;
}
inline void Unit::set_build_progress(float value) {
  set_has_build_progress();
  build_progress_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.build_progress)
}

// optional .SC2APIProtocol.CloakState cloak = 10;
inline bool Unit::has_cloak() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Unit::set_has_cloak() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Unit::clear_has_cloak() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Unit::clear_cloak() {
  cloak_ = 1;
  clear_has_cloak();
}
inline ::SC2APIProtocol::CloakState Unit::cloak() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.cloak)
  return static_cast< ::SC2APIProtocol::CloakState >(cloak_);
}
inline void Unit::set_cloak(::SC2APIProtocol::CloakState value) {
  assert(::SC2APIProtocol::CloakState_IsValid(value));
  set_has_cloak();
  cloak_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.cloak)
}

// optional float detect_range = 31;
inline bool Unit::has_detect_range() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Unit::set_has_detect_range() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Unit::clear_has_detect_range() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Unit::clear_detect_range() {
  detect_range_ = 0;
  clear_has_detect_range();
}
inline float Unit::detect_range() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.detect_range)
  return detect_range_;
}
inline void Unit::set_detect_range(float value) {
  set_has_detect_range();
  detect_range_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.detect_range)
}

// optional float radar_range = 32;
inline bool Unit::has_radar_range() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Unit::set_has_radar_range() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Unit::clear_has_radar_range() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Unit::clear_radar_range() {
  radar_range_ = 0;
  clear_has_radar_range();
}
inline float Unit::radar_range() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.radar_range)
  return radar_range_;
}
inline void Unit::set_radar_range(float value) {
  set_has_radar_range();
  radar_range_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.radar_range)
}

// optional bool is_selected = 11;
inline bool Unit::has_is_selected() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Unit::set_has_is_selected() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Unit::clear_has_is_selected() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Unit::clear_is_selected() {
  is_selected_ = false;
  clear_has_is_selected();
}
inline bool Unit::is_selected() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_selected)
  return is_selected_;
}
inline void Unit::set_is_selected(bool value) {
  set_has_is_selected();
  is_selected_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_selected)
}

// optional bool is_on_screen = 12;
inline bool Unit::has_is_on_screen() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Unit::set_has_is_on_screen() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Unit::clear_has_is_on_screen() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Unit::clear_is_on_screen() {
  is_on_screen_ = false;
  clear_has_is_on_screen();
}
inline bool Unit::is_on_screen() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_on_screen)
  return is_on_screen_;
}
inline void Unit::set_is_on_screen(bool value) {
  set_has_is_on_screen();
  is_on_screen_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_on_screen)
}

// optional bool is_blip = 13;
inline bool Unit::has_is_blip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Unit::set_has_is_blip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Unit::clear_has_is_blip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Unit::clear_is_blip() {
  is_blip_ = false;
  clear_has_is_blip();
}
inline bool Unit::is_blip() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_blip)
  return is_blip_;
}
inline void Unit::set_is_blip(bool value) {
  set_has_is_blip();
  is_blip_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_blip)
}

// optional bool is_powered = 35;
inline bool Unit::has_is_powered() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Unit::set_has_is_powered() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Unit::clear_has_is_powered() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Unit::clear_is_powered() {
  is_powered_ = false;
  clear_has_is_powered();
}
inline bool Unit::is_powered() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_powered)
  return is_powered_;
}
inline void Unit::set_is_powered(bool value) {
  set_has_is_powered();
  is_powered_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_powered)
}

// optional float health = 14;
inline bool Unit::has_health() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Unit::set_has_health() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Unit::clear_has_health() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Unit::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float Unit::health() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.health)
  return health_;
}
inline void Unit::set_health(float value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.health)
}

// optional float health_max = 15;
inline bool Unit::has_health_max() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Unit::set_has_health_max() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Unit::clear_has_health_max() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Unit::clear_health_max() {
  health_max_ = 0;
  clear_has_health_max();
}
inline float Unit::health_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.health_max)
  return health_max_;
}
inline void Unit::set_health_max(float value) {
  set_has_health_max();
  health_max_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.health_max)
}

// optional float shield = 16;
inline bool Unit::has_shield() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Unit::set_has_shield() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Unit::clear_has_shield() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Unit::clear_shield() {
  shield_ = 0;
  clear_has_shield();
}
inline float Unit::shield() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.shield)
  return shield_;
}
inline void Unit::set_shield(float value) {
  set_has_shield();
  shield_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.shield)
}

// optional float energy = 17;
inline bool Unit::has_energy() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Unit::set_has_energy() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Unit::clear_has_energy() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Unit::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline float Unit::energy() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.energy)
  return energy_;
}
inline void Unit::set_energy(float value) {
  set_has_energy();
  energy_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.energy)
}

// optional int32 mineral_contents = 18;
inline bool Unit::has_mineral_contents() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Unit::set_has_mineral_contents() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Unit::clear_has_mineral_contents() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Unit::clear_mineral_contents() {
  mineral_contents_ = 0;
  clear_has_mineral_contents();
}
inline ::google::protobuf::int32 Unit::mineral_contents() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.mineral_contents)
  return mineral_contents_;
}
inline void Unit::set_mineral_contents(::google::protobuf::int32 value) {
  set_has_mineral_contents();
  mineral_contents_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.mineral_contents)
}

// optional int32 vespene_contents = 19;
inline bool Unit::has_vespene_contents() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Unit::set_has_vespene_contents() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Unit::clear_has_vespene_contents() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Unit::clear_vespene_contents() {
  vespene_contents_ = 0;
  clear_has_vespene_contents();
}
inline ::google::protobuf::int32 Unit::vespene_contents() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.vespene_contents)
  return vespene_contents_;
}
inline void Unit::set_vespene_contents(::google::protobuf::int32 value) {
  set_has_vespene_contents();
  vespene_contents_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.vespene_contents)
}

// optional bool is_flying = 20;
inline bool Unit::has_is_flying() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Unit::set_has_is_flying() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Unit::clear_has_is_flying() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Unit::clear_is_flying() {
  is_flying_ = false;
  clear_has_is_flying();
}
inline bool Unit::is_flying() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_flying)
  return is_flying_;
}
inline void Unit::set_is_flying(bool value) {
  set_has_is_flying();
  is_flying_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_flying)
}

// optional bool is_burrowed = 21;
inline bool Unit::has_is_burrowed() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Unit::set_has_is_burrowed() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Unit::clear_has_is_burrowed() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Unit::clear_is_burrowed() {
  is_burrowed_ = false;
  clear_has_is_burrowed();
}
inline bool Unit::is_burrowed() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.is_burrowed)
  return is_burrowed_;
}
inline void Unit::set_is_burrowed(bool value) {
  set_has_is_burrowed();
  is_burrowed_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.is_burrowed)
}

// repeated .SC2APIProtocol.UnitOrder orders = 22;
inline int Unit::orders_size() const {
  return orders_.size();
}
inline void Unit::clear_orders() {
  orders_.Clear();
}
inline const ::SC2APIProtocol::UnitOrder& Unit::orders(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.orders)
  return orders_.Get(index);
}
inline ::SC2APIProtocol::UnitOrder* Unit::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Unit.orders)
  return orders_.Mutable(index);
}
inline ::SC2APIProtocol::UnitOrder* Unit::add_orders() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Unit.orders)
  return orders_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitOrder >*
Unit::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Unit.orders)
  return &orders_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitOrder >&
Unit::orders() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Unit.orders)
  return orders_;
}

// optional uint64 add_on_tag = 23;
inline bool Unit::has_add_on_tag() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Unit::set_has_add_on_tag() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Unit::clear_has_add_on_tag() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Unit::clear_add_on_tag() {
  add_on_tag_ = GOOGLE_ULONGLONG(0);
  clear_has_add_on_tag();
}
inline ::google::protobuf::uint64 Unit::add_on_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.add_on_tag)
  return add_on_tag_;
}
inline void Unit::set_add_on_tag(::google::protobuf::uint64 value) {
  set_has_add_on_tag();
  add_on_tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.add_on_tag)
}

// repeated .SC2APIProtocol.PassengerUnit passengers = 24;
inline int Unit::passengers_size() const {
  return passengers_.size();
}
inline void Unit::clear_passengers() {
  passengers_.Clear();
}
inline const ::SC2APIProtocol::PassengerUnit& Unit::passengers(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.passengers)
  return passengers_.Get(index);
}
inline ::SC2APIProtocol::PassengerUnit* Unit::mutable_passengers(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Unit.passengers)
  return passengers_.Mutable(index);
}
inline ::SC2APIProtocol::PassengerUnit* Unit::add_passengers() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Unit.passengers)
  return passengers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit >*
Unit::mutable_passengers() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Unit.passengers)
  return &passengers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PassengerUnit >&
Unit::passengers() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Unit.passengers)
  return passengers_;
}

// optional int32 cargo_space_taken = 25;
inline bool Unit::has_cargo_space_taken() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Unit::set_has_cargo_space_taken() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Unit::clear_has_cargo_space_taken() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Unit::clear_cargo_space_taken() {
  cargo_space_taken_ = 0;
  clear_has_cargo_space_taken();
}
inline ::google::protobuf::int32 Unit::cargo_space_taken() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.cargo_space_taken)
  return cargo_space_taken_;
}
inline void Unit::set_cargo_space_taken(::google::protobuf::int32 value) {
  set_has_cargo_space_taken();
  cargo_space_taken_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.cargo_space_taken)
}

// optional int32 cargo_space_max = 26;
inline bool Unit::has_cargo_space_max() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Unit::set_has_cargo_space_max() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Unit::clear_has_cargo_space_max() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Unit::clear_cargo_space_max() {
  cargo_space_max_ = 0;
  clear_has_cargo_space_max();
}
inline ::google::protobuf::int32 Unit::cargo_space_max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.cargo_space_max)
  return cargo_space_max_;
}
inline void Unit::set_cargo_space_max(::google::protobuf::int32 value) {
  set_has_cargo_space_max();
  cargo_space_max_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.cargo_space_max)
}

// repeated uint32 buff_ids = 27;
inline int Unit::buff_ids_size() const {
  return buff_ids_.size();
}
inline void Unit::clear_buff_ids() {
  buff_ids_.Clear();
}
inline ::google::protobuf::uint32 Unit::buff_ids(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.buff_ids)
  return buff_ids_.Get(index);
}
inline void Unit::set_buff_ids(int index, ::google::protobuf::uint32 value) {
  buff_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.buff_ids)
}
inline void Unit::add_buff_ids(::google::protobuf::uint32 value) {
  buff_ids_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Unit.buff_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Unit::buff_ids() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Unit.buff_ids)
  return buff_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Unit::mutable_buff_ids() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Unit.buff_ids)
  return &buff_ids_;
}

// optional int32 assigned_harvesters = 28;
inline bool Unit::has_assigned_harvesters() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Unit::set_has_assigned_harvesters() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Unit::clear_has_assigned_harvesters() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Unit::clear_assigned_harvesters() {
  assigned_harvesters_ = 0;
  clear_has_assigned_harvesters();
}
inline ::google::protobuf::int32 Unit::assigned_harvesters() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.assigned_harvesters)
  return assigned_harvesters_;
}
inline void Unit::set_assigned_harvesters(::google::protobuf::int32 value) {
  set_has_assigned_harvesters();
  assigned_harvesters_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.assigned_harvesters)
}

// optional int32 ideal_harvesters = 29;
inline bool Unit::has_ideal_harvesters() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Unit::set_has_ideal_harvesters() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Unit::clear_has_ideal_harvesters() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Unit::clear_ideal_harvesters() {
  ideal_harvesters_ = 0;
  clear_has_ideal_harvesters();
}
inline ::google::protobuf::int32 Unit::ideal_harvesters() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.ideal_harvesters)
  return ideal_harvesters_;
}
inline void Unit::set_ideal_harvesters(::google::protobuf::int32 value) {
  set_has_ideal_harvesters();
  ideal_harvesters_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.ideal_harvesters)
}

// optional float weapon_cooldown = 30;
inline bool Unit::has_weapon_cooldown() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Unit::set_has_weapon_cooldown() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Unit::clear_has_weapon_cooldown() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Unit::clear_weapon_cooldown() {
  weapon_cooldown_ = 0;
  clear_has_weapon_cooldown();
}
inline float Unit::weapon_cooldown() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.weapon_cooldown)
  return weapon_cooldown_;
}
inline void Unit::set_weapon_cooldown(float value) {
  set_has_weapon_cooldown();
  weapon_cooldown_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.weapon_cooldown)
}

// optional uint64 engaged_target_tag = 34;
inline bool Unit::has_engaged_target_tag() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Unit::set_has_engaged_target_tag() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Unit::clear_has_engaged_target_tag() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Unit::clear_engaged_target_tag() {
  engaged_target_tag_ = GOOGLE_ULONGLONG(0);
  clear_has_engaged_target_tag();
}
inline ::google::protobuf::uint64 Unit::engaged_target_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Unit.engaged_target_tag)
  return engaged_target_tag_;
}
inline void Unit::set_engaged_target_tag(::google::protobuf::uint64 value) {
  set_has_engaged_target_tag();
  engaged_target_tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Unit.engaged_target_tag)
}

// -------------------------------------------------------------------

// MapState

// optional .SC2APIProtocol.ImageData visibility = 1;
inline bool MapState::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapState::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapState::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapState::clear_visibility() {
  if (visibility_ != NULL) visibility_->::SC2APIProtocol::ImageData::Clear();
  clear_has_visibility();
}
inline const ::SC2APIProtocol::ImageData& MapState::visibility() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.MapState.visibility)
  return visibility_ != NULL ? *visibility_ : *default_instance_->visibility_;
}
inline ::SC2APIProtocol::ImageData* MapState::mutable_visibility() {
  set_has_visibility();
  if (visibility_ == NULL) {
    visibility_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.MapState.visibility)
  return visibility_;
}
inline ::SC2APIProtocol::ImageData* MapState::release_visibility() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.MapState.visibility)
  clear_has_visibility();
  ::SC2APIProtocol::ImageData* temp = visibility_;
  visibility_ = NULL;
  return temp;
}
inline void MapState::set_allocated_visibility(::SC2APIProtocol::ImageData* visibility) {
  delete visibility_;
  visibility_ = visibility;
  if (visibility) {
    set_has_visibility();
  } else {
    clear_has_visibility();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.MapState.visibility)
}

// optional .SC2APIProtocol.ImageData creep = 2;
inline bool MapState::has_creep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapState::set_has_creep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapState::clear_has_creep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapState::clear_creep() {
  if (creep_ != NULL) creep_->::SC2APIProtocol::ImageData::Clear();
  clear_has_creep();
}
inline const ::SC2APIProtocol::ImageData& MapState::creep() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.MapState.creep)
  return creep_ != NULL ? *creep_ : *default_instance_->creep_;
}
inline ::SC2APIProtocol::ImageData* MapState::mutable_creep() {
  set_has_creep();
  if (creep_ == NULL) {
    creep_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.MapState.creep)
  return creep_;
}
inline ::SC2APIProtocol::ImageData* MapState::release_creep() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.MapState.creep)
  clear_has_creep();
  ::SC2APIProtocol::ImageData* temp = creep_;
  creep_ = NULL;
  return temp;
}
inline void MapState::set_allocated_creep(::SC2APIProtocol::ImageData* creep) {
  delete creep_;
  creep_ = creep;
  if (creep) {
    set_has_creep();
  } else {
    clear_has_creep();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.MapState.creep)
}

// -------------------------------------------------------------------

// ActionRaw

// optional .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;
inline bool ActionRaw::has_unit_command() const {
  return action_case() == kUnitCommand;
}
inline void ActionRaw::set_has_unit_command() {
  _oneof_case_[0] = kUnitCommand;
}
inline void ActionRaw::clear_unit_command() {
  if (has_unit_command()) {
    delete action_.unit_command_;
    clear_has_action();
  }
}
inline  const ::SC2APIProtocol::ActionRawUnitCommand& ActionRaw::unit_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRaw.unit_command)
  return has_unit_command()
      ? *action_.unit_command_
      : ::SC2APIProtocol::ActionRawUnitCommand::default_instance();
}
inline ::SC2APIProtocol::ActionRawUnitCommand* ActionRaw::mutable_unit_command() {
  if (!has_unit_command()) {
    clear_action();
    set_has_unit_command();
    action_.unit_command_ = new ::SC2APIProtocol::ActionRawUnitCommand;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRaw.unit_command)
  return action_.unit_command_;
}
inline ::SC2APIProtocol::ActionRawUnitCommand* ActionRaw::release_unit_command() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRaw.unit_command)
  if (has_unit_command()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawUnitCommand* temp = action_.unit_command_;
    action_.unit_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionRaw::set_allocated_unit_command(::SC2APIProtocol::ActionRawUnitCommand* unit_command) {
  clear_action();
  if (unit_command) {
    set_has_unit_command();
    action_.unit_command_ = unit_command;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.unit_command)
}

// optional .SC2APIProtocol.ActionRawCameraMove camera_move = 2;
inline bool ActionRaw::has_camera_move() const {
  return action_case() == kCameraMove;
}
inline void ActionRaw::set_has_camera_move() {
  _oneof_case_[0] = kCameraMove;
}
inline void ActionRaw::clear_camera_move() {
  if (has_camera_move()) {
    delete action_.camera_move_;
    clear_has_action();
  }
}
inline  const ::SC2APIProtocol::ActionRawCameraMove& ActionRaw::camera_move() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRaw.camera_move)
  return has_camera_move()
      ? *action_.camera_move_
      : ::SC2APIProtocol::ActionRawCameraMove::default_instance();
}
inline ::SC2APIProtocol::ActionRawCameraMove* ActionRaw::mutable_camera_move() {
  if (!has_camera_move()) {
    clear_action();
    set_has_camera_move();
    action_.camera_move_ = new ::SC2APIProtocol::ActionRawCameraMove;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRaw.camera_move)
  return action_.camera_move_;
}
inline ::SC2APIProtocol::ActionRawCameraMove* ActionRaw::release_camera_move() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRaw.camera_move)
  if (has_camera_move()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawCameraMove* temp = action_.camera_move_;
    action_.camera_move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionRaw::set_allocated_camera_move(::SC2APIProtocol::ActionRawCameraMove* camera_move) {
  clear_action();
  if (camera_move) {
    set_has_camera_move();
    action_.camera_move_ = camera_move;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.camera_move)
}

// optional .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
inline bool ActionRaw::has_toggle_autocast() const {
  return action_case() == kToggleAutocast;
}
inline void ActionRaw::set_has_toggle_autocast() {
  _oneof_case_[0] = kToggleAutocast;
}
inline void ActionRaw::clear_toggle_autocast() {
  if (has_toggle_autocast()) {
    delete action_.toggle_autocast_;
    clear_has_action();
  }
}
inline  const ::SC2APIProtocol::ActionRawToggleAutocast& ActionRaw::toggle_autocast() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRaw.toggle_autocast)
  return has_toggle_autocast()
      ? *action_.toggle_autocast_
      : ::SC2APIProtocol::ActionRawToggleAutocast::default_instance();
}
inline ::SC2APIProtocol::ActionRawToggleAutocast* ActionRaw::mutable_toggle_autocast() {
  if (!has_toggle_autocast()) {
    clear_action();
    set_has_toggle_autocast();
    action_.toggle_autocast_ = new ::SC2APIProtocol::ActionRawToggleAutocast;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRaw.toggle_autocast)
  return action_.toggle_autocast_;
}
inline ::SC2APIProtocol::ActionRawToggleAutocast* ActionRaw::release_toggle_autocast() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRaw.toggle_autocast)
  if (has_toggle_autocast()) {
    clear_has_action();
    ::SC2APIProtocol::ActionRawToggleAutocast* temp = action_.toggle_autocast_;
    action_.toggle_autocast_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionRaw::set_allocated_toggle_autocast(::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast) {
  clear_action();
  if (toggle_autocast) {
    set_has_toggle_autocast();
    action_.toggle_autocast_ = toggle_autocast;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.toggle_autocast)
}

inline bool ActionRaw::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionRaw::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionRaw::ActionCase ActionRaw::action_case() const {
  return ActionRaw::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionRawUnitCommand

// optional int32 ability_id = 1;
inline bool ActionRawUnitCommand::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionRawUnitCommand::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionRawUnitCommand::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionRawUnitCommand::clear_ability_id() {
  ability_id_ = 0;
  clear_has_ability_id();
}
inline ::google::protobuf::int32 ActionRawUnitCommand::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.ability_id)
  return ability_id_;
}
inline void ActionRawUnitCommand::set_ability_id(::google::protobuf::int32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawUnitCommand.ability_id)
}

// optional .SC2APIProtocol.Point2D target_world_space_pos = 2;
inline bool ActionRawUnitCommand::has_target_world_space_pos() const {
  return target_case() == kTargetWorldSpacePos;
}
inline void ActionRawUnitCommand::set_has_target_world_space_pos() {
  _oneof_case_[0] = kTargetWorldSpacePos;
}
inline void ActionRawUnitCommand::clear_target_world_space_pos() {
  if (has_target_world_space_pos()) {
    delete target_.target_world_space_pos_;
    clear_has_target();
  }
}
inline  const ::SC2APIProtocol::Point2D& ActionRawUnitCommand::target_world_space_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
  return has_target_world_space_pos()
      ? *target_.target_world_space_pos_
      : ::SC2APIProtocol::Point2D::default_instance();
}
inline ::SC2APIProtocol::Point2D* ActionRawUnitCommand::mutable_target_world_space_pos() {
  if (!has_target_world_space_pos()) {
    clear_target();
    set_has_target_world_space_pos();
    target_.target_world_space_pos_ = new ::SC2APIProtocol::Point2D;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
  return target_.target_world_space_pos_;
}
inline ::SC2APIProtocol::Point2D* ActionRawUnitCommand::release_target_world_space_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
  if (has_target_world_space_pos()) {
    clear_has_target();
    ::SC2APIProtocol::Point2D* temp = target_.target_world_space_pos_;
    target_.target_world_space_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionRawUnitCommand::set_allocated_target_world_space_pos(::SC2APIProtocol::Point2D* target_world_space_pos) {
  clear_target();
  if (target_world_space_pos) {
    set_has_target_world_space_pos();
    target_.target_world_space_pos_ = target_world_space_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
}

// optional uint64 target_unit_tag = 3;
inline bool ActionRawUnitCommand::has_target_unit_tag() const {
  return target_case() == kTargetUnitTag;
}
inline void ActionRawUnitCommand::set_has_target_unit_tag() {
  _oneof_case_[0] = kTargetUnitTag;
}
inline void ActionRawUnitCommand::clear_target_unit_tag() {
  if (has_target_unit_tag()) {
    target_.target_unit_tag_ = GOOGLE_ULONGLONG(0);
    clear_has_target();
  }
}
inline ::google::protobuf::uint64 ActionRawUnitCommand::target_unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.target_unit_tag)
  if (has_target_unit_tag()) {
    return target_.target_unit_tag_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void ActionRawUnitCommand::set_target_unit_tag(::google::protobuf::uint64 value) {
  if (!has_target_unit_tag()) {
    clear_target();
    set_has_target_unit_tag();
  }
  target_.target_unit_tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawUnitCommand.target_unit_tag)
}

// repeated uint64 unit_tags = 4;
inline int ActionRawUnitCommand::unit_tags_size() const {
  return unit_tags_.size();
}
inline void ActionRawUnitCommand::clear_unit_tags() {
  unit_tags_.Clear();
}
inline ::google::protobuf::uint64 ActionRawUnitCommand::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
  return unit_tags_.Get(index);
}
inline void ActionRawUnitCommand::set_unit_tags(int index, ::google::protobuf::uint64 value) {
  unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
}
inline void ActionRawUnitCommand::add_unit_tags(::google::protobuf::uint64 value) {
  unit_tags_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ActionRawUnitCommand::unit_tags() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
  return unit_tags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ActionRawUnitCommand::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
  return &unit_tags_;
}

// optional bool queue_command = 5;
inline bool ActionRawUnitCommand::has_queue_command() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActionRawUnitCommand::set_has_queue_command() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActionRawUnitCommand::clear_has_queue_command() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActionRawUnitCommand::clear_queue_command() {
  queue_command_ = false;
  clear_has_queue_command();
}
inline bool ActionRawUnitCommand::queue_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawUnitCommand.queue_command)
  return queue_command_;
}
inline void ActionRawUnitCommand::set_queue_command(bool value) {
  set_has_queue_command();
  queue_command_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawUnitCommand.queue_command)
}

inline bool ActionRawUnitCommand::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ActionRawUnitCommand::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline ActionRawUnitCommand::TargetCase ActionRawUnitCommand::target_case() const {
  return ActionRawUnitCommand::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionRawCameraMove

// optional .SC2APIProtocol.Point center_world_space = 1;
inline bool ActionRawCameraMove::has_center_world_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionRawCameraMove::set_has_center_world_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionRawCameraMove::clear_has_center_world_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionRawCameraMove::clear_center_world_space() {
  if (center_world_space_ != NULL) center_world_space_->::SC2APIProtocol::Point::Clear();
  clear_has_center_world_space();
}
inline const ::SC2APIProtocol::Point& ActionRawCameraMove::center_world_space() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawCameraMove.center_world_space)
  return center_world_space_ != NULL ? *center_world_space_ : *default_instance_->center_world_space_;
}
inline ::SC2APIProtocol::Point* ActionRawCameraMove::mutable_center_world_space() {
  set_has_center_world_space();
  if (center_world_space_ == NULL) {
    center_world_space_ = new ::SC2APIProtocol::Point;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionRawCameraMove.center_world_space)
  return center_world_space_;
}
inline ::SC2APIProtocol::Point* ActionRawCameraMove::release_center_world_space() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionRawCameraMove.center_world_space)
  clear_has_center_world_space();
  ::SC2APIProtocol::Point* temp = center_world_space_;
  center_world_space_ = NULL;
  return temp;
}
inline void ActionRawCameraMove::set_allocated_center_world_space(::SC2APIProtocol::Point* center_world_space) {
  delete center_world_space_;
  center_world_space_ = center_world_space;
  if (center_world_space) {
    set_has_center_world_space();
  } else {
    clear_has_center_world_space();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRawCameraMove.center_world_space)
}

// -------------------------------------------------------------------

// ActionRawToggleAutocast

// optional int32 ability_id = 1;
inline bool ActionRawToggleAutocast::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionRawToggleAutocast::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionRawToggleAutocast::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionRawToggleAutocast::clear_ability_id() {
  ability_id_ = 0;
  clear_has_ability_id();
}
inline ::google::protobuf::int32 ActionRawToggleAutocast::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawToggleAutocast.ability_id)
  return ability_id_;
}
inline void ActionRawToggleAutocast::set_ability_id(::google::protobuf::int32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawToggleAutocast.ability_id)
}

// repeated uint64 unit_tags = 2;
inline int ActionRawToggleAutocast::unit_tags_size() const {
  return unit_tags_.size();
}
inline void ActionRawToggleAutocast::clear_unit_tags() {
  unit_tags_.Clear();
}
inline ::google::protobuf::uint64 ActionRawToggleAutocast::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
  return unit_tags_.Get(index);
}
inline void ActionRawToggleAutocast::set_unit_tags(int index, ::google::protobuf::uint64 value) {
  unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
}
inline void ActionRawToggleAutocast::add_unit_tags(::google::protobuf::uint64 value) {
  unit_tags_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ActionRawToggleAutocast::unit_tags() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
  return unit_tags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ActionRawToggleAutocast::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
  return &unit_tags_;
}

// -------------------------------------------------------------------

// Event

// repeated uint64 dead_units = 1;
inline int Event::dead_units_size() const {
  return dead_units_.size();
}
inline void Event::clear_dead_units() {
  dead_units_.Clear();
}
inline ::google::protobuf::uint64 Event::dead_units(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Event.dead_units)
  return dead_units_.Get(index);
}
inline void Event::set_dead_units(int index, ::google::protobuf::uint64 value) {
  dead_units_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Event.dead_units)
}
inline void Event::add_dead_units(::google::protobuf::uint64 value) {
  dead_units_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Event.dead_units)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Event::dead_units() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Event.dead_units)
  return dead_units_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Event::mutable_dead_units() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Event.dead_units)
  return &dead_units_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SC2APIProtocol::DisplayType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DisplayType>() {
  return ::SC2APIProtocol::DisplayType_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Alliance> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Alliance>() {
  return ::SC2APIProtocol::Alliance_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::CloakState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::CloakState>() {
  return ::SC2APIProtocol::CloakState_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_s2clientprotocol_2fraw_2eproto__INCLUDED
