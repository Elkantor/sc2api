// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/sc2api.proto

#ifndef PROTOBUF_s2clientprotocol_2fsc2api_2eproto__INCLUDED
#define PROTOBUF_s2clientprotocol_2fsc2api_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2007000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
#include "s2clientprotocol/data.pb.h"
#include "s2clientprotocol/debug.pb.h"
#include "s2clientprotocol/error.pb.h"
#include "s2clientprotocol/query.pb.h"
#include "s2clientprotocol/raw.pb.h"
#include "s2clientprotocol/score.pb.h"
#include "s2clientprotocol/spatial.pb.h"
#include "s2clientprotocol/ui.pb.h"
// @@protoc_insertion_point(includes)

namespace SC2APIProtocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

class Action;
class ActionChat;
class ActionError;
class ChatReceived;
class InterfaceOptions;
class LocalMap;
class Observation;
class PlayerCommon;
class PlayerInfo;
class PlayerInfoExtra;
class PlayerResult;
class PlayerSetup;
class PortSet;
class Request;
class RequestAction;
class RequestAvailableMaps;
class RequestCreateGame;
class RequestData;
class RequestDebug;
class RequestGameInfo;
class RequestJoinGame;
class RequestLeaveGame;
class RequestObservation;
class RequestPing;
class RequestQuickLoad;
class RequestQuickSave;
class RequestQuit;
class RequestReplayInfo;
class RequestRestartGame;
class RequestSaveMap;
class RequestSaveReplay;
class RequestStartReplay;
class RequestStep;
class Response;
class ResponseAction;
class ResponseAvailableMaps;
class ResponseCreateGame;
class ResponseData;
class ResponseDebug;
class ResponseGameInfo;
class ResponseJoinGame;
class ResponseLeaveGame;
class ResponseObservation;
class ResponsePing;
class ResponseQuickLoad;
class ResponseQuickSave;
class ResponseQuit;
class ResponseReplayInfo;
class ResponseRestartGame;
class ResponseSaveMap;
class ResponseSaveReplay;
class ResponseStartReplay;
class ResponseStep;
class SpatialCameraSetup;

enum ResponseCreateGame_Error {
  ResponseCreateGame_Error_MissingMap = 1,
  ResponseCreateGame_Error_InvalidMapPath = 2,
  ResponseCreateGame_Error_InvalidMapData = 3,
  ResponseCreateGame_Error_InvalidMapName = 4,
  ResponseCreateGame_Error_InvalidMapHandle = 5,
  ResponseCreateGame_Error_MissingPlayerSetup = 6,
  ResponseCreateGame_Error_InvalidPlayerSetup = 7,
  ResponseCreateGame_Error_MultiplayerUnsupported = 8
};
bool ResponseCreateGame_Error_IsValid(int value);
const ResponseCreateGame_Error ResponseCreateGame_Error_Error_MIN = ResponseCreateGame_Error_MissingMap;
const ResponseCreateGame_Error ResponseCreateGame_Error_Error_MAX = ResponseCreateGame_Error_MultiplayerUnsupported;
const int ResponseCreateGame_Error_Error_ARRAYSIZE = ResponseCreateGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseCreateGame_Error_descriptor();
inline const ::std::string& ResponseCreateGame_Error_Name(ResponseCreateGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseCreateGame_Error_descriptor(), value);
}
inline bool ResponseCreateGame_Error_Parse(
    const ::std::string& name, ResponseCreateGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseCreateGame_Error>(
    ResponseCreateGame_Error_descriptor(), name, value);
}
enum ResponseJoinGame_Error {
  ResponseJoinGame_Error_MissingParticipation = 1,
  ResponseJoinGame_Error_InvalidObservedPlayerId = 2,
  ResponseJoinGame_Error_MissingOptions = 3,
  ResponseJoinGame_Error_MissingPorts = 4,
  ResponseJoinGame_Error_GameFull = 5,
  ResponseJoinGame_Error_LaunchError = 6,
  ResponseJoinGame_Error_FeatureUnsupported = 7,
  ResponseJoinGame_Error_NoSpaceForUser = 8,
  ResponseJoinGame_Error_MapDoesNotExist = 9,
  ResponseJoinGame_Error_CannotOpenMap = 10,
  ResponseJoinGame_Error_ChecksumError = 11,
  ResponseJoinGame_Error_NetworkError = 12,
  ResponseJoinGame_Error_OtherError = 13
};
bool ResponseJoinGame_Error_IsValid(int value);
const ResponseJoinGame_Error ResponseJoinGame_Error_Error_MIN = ResponseJoinGame_Error_MissingParticipation;
const ResponseJoinGame_Error ResponseJoinGame_Error_Error_MAX = ResponseJoinGame_Error_OtherError;
const int ResponseJoinGame_Error_Error_ARRAYSIZE = ResponseJoinGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseJoinGame_Error_descriptor();
inline const ::std::string& ResponseJoinGame_Error_Name(ResponseJoinGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseJoinGame_Error_descriptor(), value);
}
inline bool ResponseJoinGame_Error_Parse(
    const ::std::string& name, ResponseJoinGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseJoinGame_Error>(
    ResponseJoinGame_Error_descriptor(), name, value);
}
enum ResponseRestartGame_Error {
  ResponseRestartGame_Error_LaunchError = 1
};
bool ResponseRestartGame_Error_IsValid(int value);
const ResponseRestartGame_Error ResponseRestartGame_Error_Error_MIN = ResponseRestartGame_Error_LaunchError;
const ResponseRestartGame_Error ResponseRestartGame_Error_Error_MAX = ResponseRestartGame_Error_LaunchError;
const int ResponseRestartGame_Error_Error_ARRAYSIZE = ResponseRestartGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseRestartGame_Error_descriptor();
inline const ::std::string& ResponseRestartGame_Error_Name(ResponseRestartGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseRestartGame_Error_descriptor(), value);
}
inline bool ResponseRestartGame_Error_Parse(
    const ::std::string& name, ResponseRestartGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseRestartGame_Error>(
    ResponseRestartGame_Error_descriptor(), name, value);
}
enum ResponseStartReplay_Error {
  ResponseStartReplay_Error_MissingReplay = 1,
  ResponseStartReplay_Error_InvalidReplayPath = 2,
  ResponseStartReplay_Error_InvalidReplayData = 3,
  ResponseStartReplay_Error_InvalidMapData = 4,
  ResponseStartReplay_Error_InvalidObservedPlayerId = 5,
  ResponseStartReplay_Error_MissingOptions = 6,
  ResponseStartReplay_Error_LaunchError = 7
};
bool ResponseStartReplay_Error_IsValid(int value);
const ResponseStartReplay_Error ResponseStartReplay_Error_Error_MIN = ResponseStartReplay_Error_MissingReplay;
const ResponseStartReplay_Error ResponseStartReplay_Error_Error_MAX = ResponseStartReplay_Error_LaunchError;
const int ResponseStartReplay_Error_Error_ARRAYSIZE = ResponseStartReplay_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseStartReplay_Error_descriptor();
inline const ::std::string& ResponseStartReplay_Error_Name(ResponseStartReplay_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseStartReplay_Error_descriptor(), value);
}
inline bool ResponseStartReplay_Error_Parse(
    const ::std::string& name, ResponseStartReplay_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseStartReplay_Error>(
    ResponseStartReplay_Error_descriptor(), name, value);
}
enum ResponseReplayInfo_Error {
  ResponseReplayInfo_Error_MissingReplay = 1,
  ResponseReplayInfo_Error_InvalidReplayPath = 2,
  ResponseReplayInfo_Error_InvalidReplayData = 3,
  ResponseReplayInfo_Error_ParsingError = 4,
  ResponseReplayInfo_Error_DownloadError = 5
};
bool ResponseReplayInfo_Error_IsValid(int value);
const ResponseReplayInfo_Error ResponseReplayInfo_Error_Error_MIN = ResponseReplayInfo_Error_MissingReplay;
const ResponseReplayInfo_Error ResponseReplayInfo_Error_Error_MAX = ResponseReplayInfo_Error_DownloadError;
const int ResponseReplayInfo_Error_Error_ARRAYSIZE = ResponseReplayInfo_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseReplayInfo_Error_descriptor();
inline const ::std::string& ResponseReplayInfo_Error_Name(ResponseReplayInfo_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseReplayInfo_Error_descriptor(), value);
}
inline bool ResponseReplayInfo_Error_Parse(
    const ::std::string& name, ResponseReplayInfo_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseReplayInfo_Error>(
    ResponseReplayInfo_Error_descriptor(), name, value);
}
enum ResponseSaveMap_Error {
  ResponseSaveMap_Error_InvalidMapData = 1
};
bool ResponseSaveMap_Error_IsValid(int value);
const ResponseSaveMap_Error ResponseSaveMap_Error_Error_MIN = ResponseSaveMap_Error_InvalidMapData;
const ResponseSaveMap_Error ResponseSaveMap_Error_Error_MAX = ResponseSaveMap_Error_InvalidMapData;
const int ResponseSaveMap_Error_Error_ARRAYSIZE = ResponseSaveMap_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseSaveMap_Error_descriptor();
inline const ::std::string& ResponseSaveMap_Error_Name(ResponseSaveMap_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseSaveMap_Error_descriptor(), value);
}
inline bool ResponseSaveMap_Error_Parse(
    const ::std::string& name, ResponseSaveMap_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseSaveMap_Error>(
    ResponseSaveMap_Error_descriptor(), name, value);
}
enum ActionChat_Channel {
  ActionChat_Channel_Broadcast = 1,
  ActionChat_Channel_Team = 2
};
bool ActionChat_Channel_IsValid(int value);
const ActionChat_Channel ActionChat_Channel_Channel_MIN = ActionChat_Channel_Broadcast;
const ActionChat_Channel ActionChat_Channel_Channel_MAX = ActionChat_Channel_Team;
const int ActionChat_Channel_Channel_ARRAYSIZE = ActionChat_Channel_Channel_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionChat_Channel_descriptor();
inline const ::std::string& ActionChat_Channel_Name(ActionChat_Channel value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionChat_Channel_descriptor(), value);
}
inline bool ActionChat_Channel_Parse(
    const ::std::string& name, ActionChat_Channel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionChat_Channel>(
    ActionChat_Channel_descriptor(), name, value);
}
enum Status {
  launched = 1,
  init_game = 2,
  in_game = 3,
  in_replay = 4,
  ended = 5,
  quit = 6,
  unknown = 99
};
bool Status_IsValid(int value);
const Status Status_MIN = launched;
const Status Status_MAX = unknown;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum Difficulty {
  VeryEasy = 1,
  Easy = 2,
  Medium = 3,
  MediumHard = 4,
  Hard = 5,
  Harder = 6,
  VeryHard = 7,
  CheatVision = 8,
  CheatMoney = 9,
  CheatInsane = 10
};
bool Difficulty_IsValid(int value);
const Difficulty Difficulty_MIN = VeryEasy;
const Difficulty Difficulty_MAX = CheatInsane;
const int Difficulty_ARRAYSIZE = Difficulty_MAX + 1;

const ::google::protobuf::EnumDescriptor* Difficulty_descriptor();
inline const ::std::string& Difficulty_Name(Difficulty value) {
  return ::google::protobuf::internal::NameOfEnum(
    Difficulty_descriptor(), value);
}
inline bool Difficulty_Parse(
    const ::std::string& name, Difficulty* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Difficulty>(
    Difficulty_descriptor(), name, value);
}
enum PlayerType {
  Participant = 1,
  Computer = 2,
  Observer = 3
};
bool PlayerType_IsValid(int value);
const PlayerType PlayerType_MIN = Participant;
const PlayerType PlayerType_MAX = Observer;
const int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerType_descriptor();
inline const ::std::string& PlayerType_Name(PlayerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerType_descriptor(), value);
}
inline bool PlayerType_Parse(
    const ::std::string& name, PlayerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum Alert {
  NuclearLaunchDetected = 1,
  NydusWormDetected = 2
};
bool Alert_IsValid(int value);
const Alert Alert_MIN = NuclearLaunchDetected;
const Alert Alert_MAX = NydusWormDetected;
const int Alert_ARRAYSIZE = Alert_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alert_descriptor();
inline const ::std::string& Alert_Name(Alert value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alert_descriptor(), value);
}
inline bool Alert_Parse(
    const ::std::string& name, Alert* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert>(
    Alert_descriptor(), name, value);
}
enum Result {
  Victory = 1,
  Defeat = 2,
  Tie = 3,
  Undecided = 4
};
bool Result_IsValid(int value);
const Result Result_MIN = Victory;
const Result Result_MAX = Undecided;
const int Result_ARRAYSIZE = Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* Result_descriptor();
inline const ::std::string& Result_Name(Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    Result_descriptor(), value);
}
inline bool Result_Parse(
    const ::std::string& name, Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum RequestCase {
    kCreateGame = 1,
    kJoinGame = 2,
    kRestartGame = 3,
    kStartReplay = 4,
    kLeaveGame = 5,
    kQuickSave = 6,
    kQuickLoad = 7,
    kQuit = 8,
    kGameInfo = 9,
    kObservation = 10,
    kAction = 11,
    kStep = 12,
    kData = 13,
    kQuery = 14,
    kSaveReplay = 15,
    kReplayInfo = 16,
    kAvailableMaps = 17,
    kSaveMap = 18,
    kPing = 19,
    kDebug = 20,
    REQUEST_NOT_SET = 0,
  };

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.RequestCreateGame create_game = 1;
  bool has_create_game() const;
  void clear_create_game();
  static const int kCreateGameFieldNumber = 1;
  const ::SC2APIProtocol::RequestCreateGame& create_game() const;
  ::SC2APIProtocol::RequestCreateGame* mutable_create_game();
  ::SC2APIProtocol::RequestCreateGame* release_create_game();
  void set_allocated_create_game(::SC2APIProtocol::RequestCreateGame* create_game);

  // optional .SC2APIProtocol.RequestJoinGame join_game = 2;
  bool has_join_game() const;
  void clear_join_game();
  static const int kJoinGameFieldNumber = 2;
  const ::SC2APIProtocol::RequestJoinGame& join_game() const;
  ::SC2APIProtocol::RequestJoinGame* mutable_join_game();
  ::SC2APIProtocol::RequestJoinGame* release_join_game();
  void set_allocated_join_game(::SC2APIProtocol::RequestJoinGame* join_game);

  // optional .SC2APIProtocol.RequestRestartGame restart_game = 3;
  bool has_restart_game() const;
  void clear_restart_game();
  static const int kRestartGameFieldNumber = 3;
  const ::SC2APIProtocol::RequestRestartGame& restart_game() const;
  ::SC2APIProtocol::RequestRestartGame* mutable_restart_game();
  ::SC2APIProtocol::RequestRestartGame* release_restart_game();
  void set_allocated_restart_game(::SC2APIProtocol::RequestRestartGame* restart_game);

  // optional .SC2APIProtocol.RequestStartReplay start_replay = 4;
  bool has_start_replay() const;
  void clear_start_replay();
  static const int kStartReplayFieldNumber = 4;
  const ::SC2APIProtocol::RequestStartReplay& start_replay() const;
  ::SC2APIProtocol::RequestStartReplay* mutable_start_replay();
  ::SC2APIProtocol::RequestStartReplay* release_start_replay();
  void set_allocated_start_replay(::SC2APIProtocol::RequestStartReplay* start_replay);

  // optional .SC2APIProtocol.RequestLeaveGame leave_game = 5;
  bool has_leave_game() const;
  void clear_leave_game();
  static const int kLeaveGameFieldNumber = 5;
  const ::SC2APIProtocol::RequestLeaveGame& leave_game() const;
  ::SC2APIProtocol::RequestLeaveGame* mutable_leave_game();
  ::SC2APIProtocol::RequestLeaveGame* release_leave_game();
  void set_allocated_leave_game(::SC2APIProtocol::RequestLeaveGame* leave_game);

  // optional .SC2APIProtocol.RequestQuickSave quick_save = 6;
  bool has_quick_save() const;
  void clear_quick_save();
  static const int kQuickSaveFieldNumber = 6;
  const ::SC2APIProtocol::RequestQuickSave& quick_save() const;
  ::SC2APIProtocol::RequestQuickSave* mutable_quick_save();
  ::SC2APIProtocol::RequestQuickSave* release_quick_save();
  void set_allocated_quick_save(::SC2APIProtocol::RequestQuickSave* quick_save);

  // optional .SC2APIProtocol.RequestQuickLoad quick_load = 7;
  bool has_quick_load() const;
  void clear_quick_load();
  static const int kQuickLoadFieldNumber = 7;
  const ::SC2APIProtocol::RequestQuickLoad& quick_load() const;
  ::SC2APIProtocol::RequestQuickLoad* mutable_quick_load();
  ::SC2APIProtocol::RequestQuickLoad* release_quick_load();
  void set_allocated_quick_load(::SC2APIProtocol::RequestQuickLoad* quick_load);

  // optional .SC2APIProtocol.RequestQuit quit = 8;
  bool has_quit() const;
  void clear_quit();
  static const int kQuitFieldNumber = 8;
  const ::SC2APIProtocol::RequestQuit& quit() const;
  ::SC2APIProtocol::RequestQuit* mutable_quit();
  ::SC2APIProtocol::RequestQuit* release_quit();
  void set_allocated_quit(::SC2APIProtocol::RequestQuit* quit);

  // optional .SC2APIProtocol.RequestGameInfo game_info = 9;
  bool has_game_info() const;
  void clear_game_info();
  static const int kGameInfoFieldNumber = 9;
  const ::SC2APIProtocol::RequestGameInfo& game_info() const;
  ::SC2APIProtocol::RequestGameInfo* mutable_game_info();
  ::SC2APIProtocol::RequestGameInfo* release_game_info();
  void set_allocated_game_info(::SC2APIProtocol::RequestGameInfo* game_info);

  // optional .SC2APIProtocol.RequestObservation observation = 10;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 10;
  const ::SC2APIProtocol::RequestObservation& observation() const;
  ::SC2APIProtocol::RequestObservation* mutable_observation();
  ::SC2APIProtocol::RequestObservation* release_observation();
  void set_allocated_observation(::SC2APIProtocol::RequestObservation* observation);

  // optional .SC2APIProtocol.RequestAction action = 11;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 11;
  const ::SC2APIProtocol::RequestAction& action() const;
  ::SC2APIProtocol::RequestAction* mutable_action();
  ::SC2APIProtocol::RequestAction* release_action();
  void set_allocated_action(::SC2APIProtocol::RequestAction* action);

  // optional .SC2APIProtocol.RequestStep step = 12;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 12;
  const ::SC2APIProtocol::RequestStep& step() const;
  ::SC2APIProtocol::RequestStep* mutable_step();
  ::SC2APIProtocol::RequestStep* release_step();
  void set_allocated_step(::SC2APIProtocol::RequestStep* step);

  // optional .SC2APIProtocol.RequestData data = 13;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 13;
  const ::SC2APIProtocol::RequestData& data() const;
  ::SC2APIProtocol::RequestData* mutable_data();
  ::SC2APIProtocol::RequestData* release_data();
  void set_allocated_data(::SC2APIProtocol::RequestData* data);

  // optional .SC2APIProtocol.RequestQuery query = 14;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 14;
  const ::SC2APIProtocol::RequestQuery& query() const;
  ::SC2APIProtocol::RequestQuery* mutable_query();
  ::SC2APIProtocol::RequestQuery* release_query();
  void set_allocated_query(::SC2APIProtocol::RequestQuery* query);

  // optional .SC2APIProtocol.RequestSaveReplay save_replay = 15;
  bool has_save_replay() const;
  void clear_save_replay();
  static const int kSaveReplayFieldNumber = 15;
  const ::SC2APIProtocol::RequestSaveReplay& save_replay() const;
  ::SC2APIProtocol::RequestSaveReplay* mutable_save_replay();
  ::SC2APIProtocol::RequestSaveReplay* release_save_replay();
  void set_allocated_save_replay(::SC2APIProtocol::RequestSaveReplay* save_replay);

  // optional .SC2APIProtocol.RequestReplayInfo replay_info = 16;
  bool has_replay_info() const;
  void clear_replay_info();
  static const int kReplayInfoFieldNumber = 16;
  const ::SC2APIProtocol::RequestReplayInfo& replay_info() const;
  ::SC2APIProtocol::RequestReplayInfo* mutable_replay_info();
  ::SC2APIProtocol::RequestReplayInfo* release_replay_info();
  void set_allocated_replay_info(::SC2APIProtocol::RequestReplayInfo* replay_info);

  // optional .SC2APIProtocol.RequestAvailableMaps available_maps = 17;
  bool has_available_maps() const;
  void clear_available_maps();
  static const int kAvailableMapsFieldNumber = 17;
  const ::SC2APIProtocol::RequestAvailableMaps& available_maps() const;
  ::SC2APIProtocol::RequestAvailableMaps* mutable_available_maps();
  ::SC2APIProtocol::RequestAvailableMaps* release_available_maps();
  void set_allocated_available_maps(::SC2APIProtocol::RequestAvailableMaps* available_maps);

  // optional .SC2APIProtocol.RequestSaveMap save_map = 18;
  bool has_save_map() const;
  void clear_save_map();
  static const int kSaveMapFieldNumber = 18;
  const ::SC2APIProtocol::RequestSaveMap& save_map() const;
  ::SC2APIProtocol::RequestSaveMap* mutable_save_map();
  ::SC2APIProtocol::RequestSaveMap* release_save_map();
  void set_allocated_save_map(::SC2APIProtocol::RequestSaveMap* save_map);

  // optional .SC2APIProtocol.RequestPing ping = 19;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 19;
  const ::SC2APIProtocol::RequestPing& ping() const;
  ::SC2APIProtocol::RequestPing* mutable_ping();
  ::SC2APIProtocol::RequestPing* release_ping();
  void set_allocated_ping(::SC2APIProtocol::RequestPing* ping);

  // optional .SC2APIProtocol.RequestDebug debug = 20;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 20;
  const ::SC2APIProtocol::RequestDebug& debug() const;
  ::SC2APIProtocol::RequestDebug* mutable_debug();
  ::SC2APIProtocol::RequestDebug* release_debug();
  void set_allocated_debug(::SC2APIProtocol::RequestDebug* debug);

  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Request)
 private:
  inline void set_has_create_game();
  inline void set_has_join_game();
  inline void set_has_restart_game();
  inline void set_has_start_replay();
  inline void set_has_leave_game();
  inline void set_has_quick_save();
  inline void set_has_quick_load();
  inline void set_has_quit();
  inline void set_has_game_info();
  inline void set_has_observation();
  inline void set_has_action();
  inline void set_has_step();
  inline void set_has_data();
  inline void set_has_query();
  inline void set_has_save_replay();
  inline void set_has_replay_info();
  inline void set_has_available_maps();
  inline void set_has_save_map();
  inline void set_has_ping();
  inline void set_has_debug();

  inline bool has_request() const;
  void clear_request();
  inline void clear_has_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union RequestUnion {
    RequestUnion() {}
    ::SC2APIProtocol::RequestCreateGame* create_game_;
    ::SC2APIProtocol::RequestJoinGame* join_game_;
    ::SC2APIProtocol::RequestRestartGame* restart_game_;
    ::SC2APIProtocol::RequestStartReplay* start_replay_;
    ::SC2APIProtocol::RequestLeaveGame* leave_game_;
    ::SC2APIProtocol::RequestQuickSave* quick_save_;
    ::SC2APIProtocol::RequestQuickLoad* quick_load_;
    ::SC2APIProtocol::RequestQuit* quit_;
    ::SC2APIProtocol::RequestGameInfo* game_info_;
    ::SC2APIProtocol::RequestObservation* observation_;
    ::SC2APIProtocol::RequestAction* action_;
    ::SC2APIProtocol::RequestStep* step_;
    ::SC2APIProtocol::RequestData* data_;
    ::SC2APIProtocol::RequestQuery* query_;
    ::SC2APIProtocol::RequestSaveReplay* save_replay_;
    ::SC2APIProtocol::RequestReplayInfo* replay_info_;
    ::SC2APIProtocol::RequestAvailableMaps* available_maps_;
    ::SC2APIProtocol::RequestSaveMap* save_map_;
    ::SC2APIProtocol::RequestPing* ping_;
    ::SC2APIProtocol::RequestDebug* debug_;
  } request_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ResponseCase {
    kCreateGame = 1,
    kJoinGame = 2,
    kRestartGame = 3,
    kStartReplay = 4,
    kLeaveGame = 5,
    kQuickSave = 6,
    kQuickLoad = 7,
    kQuit = 8,
    kGameInfo = 9,
    kObservation = 10,
    kAction = 11,
    kStep = 12,
    kData = 13,
    kQuery = 14,
    kSaveReplay = 15,
    kReplayInfo = 16,
    kAvailableMaps = 17,
    kSaveMap = 18,
    kPing = 19,
    kDebug = 20,
    RESPONSE_NOT_SET = 0,
  };

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ResponseCreateGame create_game = 1;
  bool has_create_game() const;
  void clear_create_game();
  static const int kCreateGameFieldNumber = 1;
  const ::SC2APIProtocol::ResponseCreateGame& create_game() const;
  ::SC2APIProtocol::ResponseCreateGame* mutable_create_game();
  ::SC2APIProtocol::ResponseCreateGame* release_create_game();
  void set_allocated_create_game(::SC2APIProtocol::ResponseCreateGame* create_game);

  // optional .SC2APIProtocol.ResponseJoinGame join_game = 2;
  bool has_join_game() const;
  void clear_join_game();
  static const int kJoinGameFieldNumber = 2;
  const ::SC2APIProtocol::ResponseJoinGame& join_game() const;
  ::SC2APIProtocol::ResponseJoinGame* mutable_join_game();
  ::SC2APIProtocol::ResponseJoinGame* release_join_game();
  void set_allocated_join_game(::SC2APIProtocol::ResponseJoinGame* join_game);

  // optional .SC2APIProtocol.ResponseRestartGame restart_game = 3;
  bool has_restart_game() const;
  void clear_restart_game();
  static const int kRestartGameFieldNumber = 3;
  const ::SC2APIProtocol::ResponseRestartGame& restart_game() const;
  ::SC2APIProtocol::ResponseRestartGame* mutable_restart_game();
  ::SC2APIProtocol::ResponseRestartGame* release_restart_game();
  void set_allocated_restart_game(::SC2APIProtocol::ResponseRestartGame* restart_game);

  // optional .SC2APIProtocol.ResponseStartReplay start_replay = 4;
  bool has_start_replay() const;
  void clear_start_replay();
  static const int kStartReplayFieldNumber = 4;
  const ::SC2APIProtocol::ResponseStartReplay& start_replay() const;
  ::SC2APIProtocol::ResponseStartReplay* mutable_start_replay();
  ::SC2APIProtocol::ResponseStartReplay* release_start_replay();
  void set_allocated_start_replay(::SC2APIProtocol::ResponseStartReplay* start_replay);

  // optional .SC2APIProtocol.ResponseLeaveGame leave_game = 5;
  bool has_leave_game() const;
  void clear_leave_game();
  static const int kLeaveGameFieldNumber = 5;
  const ::SC2APIProtocol::ResponseLeaveGame& leave_game() const;
  ::SC2APIProtocol::ResponseLeaveGame* mutable_leave_game();
  ::SC2APIProtocol::ResponseLeaveGame* release_leave_game();
  void set_allocated_leave_game(::SC2APIProtocol::ResponseLeaveGame* leave_game);

  // optional .SC2APIProtocol.ResponseQuickSave quick_save = 6;
  bool has_quick_save() const;
  void clear_quick_save();
  static const int kQuickSaveFieldNumber = 6;
  const ::SC2APIProtocol::ResponseQuickSave& quick_save() const;
  ::SC2APIProtocol::ResponseQuickSave* mutable_quick_save();
  ::SC2APIProtocol::ResponseQuickSave* release_quick_save();
  void set_allocated_quick_save(::SC2APIProtocol::ResponseQuickSave* quick_save);

  // optional .SC2APIProtocol.ResponseQuickLoad quick_load = 7;
  bool has_quick_load() const;
  void clear_quick_load();
  static const int kQuickLoadFieldNumber = 7;
  const ::SC2APIProtocol::ResponseQuickLoad& quick_load() const;
  ::SC2APIProtocol::ResponseQuickLoad* mutable_quick_load();
  ::SC2APIProtocol::ResponseQuickLoad* release_quick_load();
  void set_allocated_quick_load(::SC2APIProtocol::ResponseQuickLoad* quick_load);

  // optional .SC2APIProtocol.ResponseQuit quit = 8;
  bool has_quit() const;
  void clear_quit();
  static const int kQuitFieldNumber = 8;
  const ::SC2APIProtocol::ResponseQuit& quit() const;
  ::SC2APIProtocol::ResponseQuit* mutable_quit();
  ::SC2APIProtocol::ResponseQuit* release_quit();
  void set_allocated_quit(::SC2APIProtocol::ResponseQuit* quit);

  // optional .SC2APIProtocol.ResponseGameInfo game_info = 9;
  bool has_game_info() const;
  void clear_game_info();
  static const int kGameInfoFieldNumber = 9;
  const ::SC2APIProtocol::ResponseGameInfo& game_info() const;
  ::SC2APIProtocol::ResponseGameInfo* mutable_game_info();
  ::SC2APIProtocol::ResponseGameInfo* release_game_info();
  void set_allocated_game_info(::SC2APIProtocol::ResponseGameInfo* game_info);

  // optional .SC2APIProtocol.ResponseObservation observation = 10;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 10;
  const ::SC2APIProtocol::ResponseObservation& observation() const;
  ::SC2APIProtocol::ResponseObservation* mutable_observation();
  ::SC2APIProtocol::ResponseObservation* release_observation();
  void set_allocated_observation(::SC2APIProtocol::ResponseObservation* observation);

  // optional .SC2APIProtocol.ResponseAction action = 11;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 11;
  const ::SC2APIProtocol::ResponseAction& action() const;
  ::SC2APIProtocol::ResponseAction* mutable_action();
  ::SC2APIProtocol::ResponseAction* release_action();
  void set_allocated_action(::SC2APIProtocol::ResponseAction* action);

  // optional .SC2APIProtocol.ResponseStep step = 12;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 12;
  const ::SC2APIProtocol::ResponseStep& step() const;
  ::SC2APIProtocol::ResponseStep* mutable_step();
  ::SC2APIProtocol::ResponseStep* release_step();
  void set_allocated_step(::SC2APIProtocol::ResponseStep* step);

  // optional .SC2APIProtocol.ResponseData data = 13;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 13;
  const ::SC2APIProtocol::ResponseData& data() const;
  ::SC2APIProtocol::ResponseData* mutable_data();
  ::SC2APIProtocol::ResponseData* release_data();
  void set_allocated_data(::SC2APIProtocol::ResponseData* data);

  // optional .SC2APIProtocol.ResponseQuery query = 14;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 14;
  const ::SC2APIProtocol::ResponseQuery& query() const;
  ::SC2APIProtocol::ResponseQuery* mutable_query();
  ::SC2APIProtocol::ResponseQuery* release_query();
  void set_allocated_query(::SC2APIProtocol::ResponseQuery* query);

  // optional .SC2APIProtocol.ResponseSaveReplay save_replay = 15;
  bool has_save_replay() const;
  void clear_save_replay();
  static const int kSaveReplayFieldNumber = 15;
  const ::SC2APIProtocol::ResponseSaveReplay& save_replay() const;
  ::SC2APIProtocol::ResponseSaveReplay* mutable_save_replay();
  ::SC2APIProtocol::ResponseSaveReplay* release_save_replay();
  void set_allocated_save_replay(::SC2APIProtocol::ResponseSaveReplay* save_replay);

  // optional .SC2APIProtocol.ResponseReplayInfo replay_info = 16;
  bool has_replay_info() const;
  void clear_replay_info();
  static const int kReplayInfoFieldNumber = 16;
  const ::SC2APIProtocol::ResponseReplayInfo& replay_info() const;
  ::SC2APIProtocol::ResponseReplayInfo* mutable_replay_info();
  ::SC2APIProtocol::ResponseReplayInfo* release_replay_info();
  void set_allocated_replay_info(::SC2APIProtocol::ResponseReplayInfo* replay_info);

  // optional .SC2APIProtocol.ResponseAvailableMaps available_maps = 17;
  bool has_available_maps() const;
  void clear_available_maps();
  static const int kAvailableMapsFieldNumber = 17;
  const ::SC2APIProtocol::ResponseAvailableMaps& available_maps() const;
  ::SC2APIProtocol::ResponseAvailableMaps* mutable_available_maps();
  ::SC2APIProtocol::ResponseAvailableMaps* release_available_maps();
  void set_allocated_available_maps(::SC2APIProtocol::ResponseAvailableMaps* available_maps);

  // optional .SC2APIProtocol.ResponseSaveMap save_map = 18;
  bool has_save_map() const;
  void clear_save_map();
  static const int kSaveMapFieldNumber = 18;
  const ::SC2APIProtocol::ResponseSaveMap& save_map() const;
  ::SC2APIProtocol::ResponseSaveMap* mutable_save_map();
  ::SC2APIProtocol::ResponseSaveMap* release_save_map();
  void set_allocated_save_map(::SC2APIProtocol::ResponseSaveMap* save_map);

  // optional .SC2APIProtocol.ResponsePing ping = 19;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 19;
  const ::SC2APIProtocol::ResponsePing& ping() const;
  ::SC2APIProtocol::ResponsePing* mutable_ping();
  ::SC2APIProtocol::ResponsePing* release_ping();
  void set_allocated_ping(::SC2APIProtocol::ResponsePing* ping);

  // optional .SC2APIProtocol.ResponseDebug debug = 20;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 20;
  const ::SC2APIProtocol::ResponseDebug& debug() const;
  ::SC2APIProtocol::ResponseDebug* mutable_debug();
  ::SC2APIProtocol::ResponseDebug* release_debug();
  void set_allocated_debug(::SC2APIProtocol::ResponseDebug* debug);

  // repeated string error = 98;
  int error_size() const;
  void clear_error();
  static const int kErrorFieldNumber = 98;
  const ::std::string& error(int index) const;
  ::std::string* mutable_error(int index);
  void set_error(int index, const ::std::string& value);
  void set_error(int index, const char* value);
  void set_error(int index, const char* value, size_t size);
  ::std::string* add_error();
  void add_error(const ::std::string& value);
  void add_error(const char* value);
  void add_error(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& error() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_error();

  // optional .SC2APIProtocol.Status status = 99;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 99;
  ::SC2APIProtocol::Status status() const;
  void set_status(::SC2APIProtocol::Status value);

  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Response)
 private:
  inline void set_has_create_game();
  inline void set_has_join_game();
  inline void set_has_restart_game();
  inline void set_has_start_replay();
  inline void set_has_leave_game();
  inline void set_has_quick_save();
  inline void set_has_quick_load();
  inline void set_has_quit();
  inline void set_has_game_info();
  inline void set_has_observation();
  inline void set_has_action();
  inline void set_has_step();
  inline void set_has_data();
  inline void set_has_query();
  inline void set_has_save_replay();
  inline void set_has_replay_info();
  inline void set_has_available_maps();
  inline void set_has_save_map();
  inline void set_has_ping();
  inline void set_has_debug();
  inline void set_has_status();
  inline void clear_has_status();

  inline bool has_response() const;
  void clear_response();
  inline void clear_has_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> error_;
  int status_;
  union ResponseUnion {
    ResponseUnion() {}
    ::SC2APIProtocol::ResponseCreateGame* create_game_;
    ::SC2APIProtocol::ResponseJoinGame* join_game_;
    ::SC2APIProtocol::ResponseRestartGame* restart_game_;
    ::SC2APIProtocol::ResponseStartReplay* start_replay_;
    ::SC2APIProtocol::ResponseLeaveGame* leave_game_;
    ::SC2APIProtocol::ResponseQuickSave* quick_save_;
    ::SC2APIProtocol::ResponseQuickLoad* quick_load_;
    ::SC2APIProtocol::ResponseQuit* quit_;
    ::SC2APIProtocol::ResponseGameInfo* game_info_;
    ::SC2APIProtocol::ResponseObservation* observation_;
    ::SC2APIProtocol::ResponseAction* action_;
    ::SC2APIProtocol::ResponseStep* step_;
    ::SC2APIProtocol::ResponseData* data_;
    ::SC2APIProtocol::ResponseQuery* query_;
    ::SC2APIProtocol::ResponseSaveReplay* save_replay_;
    ::SC2APIProtocol::ResponseReplayInfo* replay_info_;
    ::SC2APIProtocol::ResponseAvailableMaps* available_maps_;
    ::SC2APIProtocol::ResponseSaveMap* save_map_;
    ::SC2APIProtocol::ResponsePing* ping_;
    ::SC2APIProtocol::ResponseDebug* debug_;
  } response_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class RequestCreateGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestCreateGame) */ {
 public:
  RequestCreateGame();
  virtual ~RequestCreateGame();

  RequestCreateGame(const RequestCreateGame& from);

  inline RequestCreateGame& operator=(const RequestCreateGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCreateGame& default_instance();

  enum MapCase {
    kLocalMap = 1,
    kBattlenetMapName = 2,
    MAP_NOT_SET = 0,
  };

  void Swap(RequestCreateGame* other);

  // implements Message ----------------------------------------------

  inline RequestCreateGame* New() const { return New(NULL); }

  RequestCreateGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestCreateGame& from);
  void MergeFrom(const RequestCreateGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestCreateGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.LocalMap local_map = 1;
  bool has_local_map() const;
  void clear_local_map();
  static const int kLocalMapFieldNumber = 1;
  const ::SC2APIProtocol::LocalMap& local_map() const;
  ::SC2APIProtocol::LocalMap* mutable_local_map();
  ::SC2APIProtocol::LocalMap* release_local_map();
  void set_allocated_local_map(::SC2APIProtocol::LocalMap* local_map);

  // optional string battlenet_map_name = 2;
  bool has_battlenet_map_name() const;
  void clear_battlenet_map_name();
  static const int kBattlenetMapNameFieldNumber = 2;
  const ::std::string& battlenet_map_name() const;
  void set_battlenet_map_name(const ::std::string& value);
  void set_battlenet_map_name(const char* value);
  void set_battlenet_map_name(const char* value, size_t size);
  ::std::string* mutable_battlenet_map_name();
  ::std::string* release_battlenet_map_name();
  void set_allocated_battlenet_map_name(::std::string* battlenet_map_name);

  // repeated .SC2APIProtocol.PlayerSetup player_setup = 3;
  int player_setup_size() const;
  void clear_player_setup();
  static const int kPlayerSetupFieldNumber = 3;
  const ::SC2APIProtocol::PlayerSetup& player_setup(int index) const;
  ::SC2APIProtocol::PlayerSetup* mutable_player_setup(int index);
  ::SC2APIProtocol::PlayerSetup* add_player_setup();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >*
      mutable_player_setup();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >&
      player_setup() const;

  // optional bool disable_fog = 4;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 4;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  // optional uint32 random_seed = 5;
  bool has_random_seed() const;
  void clear_random_seed();
  static const int kRandomSeedFieldNumber = 5;
  ::google::protobuf::uint32 random_seed() const;
  void set_random_seed(::google::protobuf::uint32 value);

  // optional bool realtime = 6;
  bool has_realtime() const;
  void clear_realtime();
  static const int kRealtimeFieldNumber = 6;
  bool realtime() const;
  void set_realtime(bool value);

  MapCase Map_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestCreateGame)
 private:
  inline void set_has_local_map();
  inline void set_has_battlenet_map_name();
  inline void set_has_disable_fog();
  inline void clear_has_disable_fog();
  inline void set_has_random_seed();
  inline void clear_has_random_seed();
  inline void set_has_realtime();
  inline void clear_has_realtime();

  inline bool has_Map() const;
  void clear_Map();
  inline void clear_has_Map();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup > player_setup_;
  ::google::protobuf::uint32 random_seed_;
  bool disable_fog_;
  bool realtime_;
  union MapUnion {
    MapUnion() {}
    ::SC2APIProtocol::LocalMap* local_map_;
    ::google::protobuf::internal::ArenaStringPtr battlenet_map_name_;
  } Map_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestCreateGame* default_instance_;
};
// -------------------------------------------------------------------

class LocalMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.LocalMap) */ {
 public:
  LocalMap();
  virtual ~LocalMap();

  LocalMap(const LocalMap& from);

  inline LocalMap& operator=(const LocalMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalMap& default_instance();

  void Swap(LocalMap* other);

  // implements Message ----------------------------------------------

  inline LocalMap* New() const { return New(NULL); }

  LocalMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalMap& from);
  void MergeFrom(const LocalMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_path = 1;
  bool has_map_path() const;
  void clear_map_path();
  static const int kMapPathFieldNumber = 1;
  const ::std::string& map_path() const;
  void set_map_path(const ::std::string& value);
  void set_map_path(const char* value);
  void set_map_path(const char* value, size_t size);
  ::std::string* mutable_map_path();
  ::std::string* release_map_path();
  void set_allocated_map_path(::std::string* map_path);

  // optional bytes map_data = 7;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 7;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.LocalMap)
 private:
  inline void set_has_map_path();
  inline void clear_has_map_path();
  inline void set_has_map_data();
  inline void clear_has_map_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_path_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static LocalMap* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCreateGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseCreateGame) */ {
 public:
  ResponseCreateGame();
  virtual ~ResponseCreateGame();

  ResponseCreateGame(const ResponseCreateGame& from);

  inline ResponseCreateGame& operator=(const ResponseCreateGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCreateGame& default_instance();

  void Swap(ResponseCreateGame* other);

  // implements Message ----------------------------------------------

  inline ResponseCreateGame* New() const { return New(NULL); }

  ResponseCreateGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseCreateGame& from);
  void MergeFrom(const ResponseCreateGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseCreateGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResponseCreateGame_Error Error;
  static const Error MissingMap =
    ResponseCreateGame_Error_MissingMap;
  static const Error InvalidMapPath =
    ResponseCreateGame_Error_InvalidMapPath;
  static const Error InvalidMapData =
    ResponseCreateGame_Error_InvalidMapData;
  static const Error InvalidMapName =
    ResponseCreateGame_Error_InvalidMapName;
  static const Error InvalidMapHandle =
    ResponseCreateGame_Error_InvalidMapHandle;
  static const Error MissingPlayerSetup =
    ResponseCreateGame_Error_MissingPlayerSetup;
  static const Error InvalidPlayerSetup =
    ResponseCreateGame_Error_InvalidPlayerSetup;
  static const Error MultiplayerUnsupported =
    ResponseCreateGame_Error_MultiplayerUnsupported;
  static inline bool Error_IsValid(int value) {
    return ResponseCreateGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseCreateGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseCreateGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseCreateGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseCreateGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseCreateGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseCreateGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ResponseCreateGame.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SC2APIProtocol::ResponseCreateGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseCreateGame_Error value);

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseCreateGame)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_error_details();
  inline void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseCreateGame* default_instance_;
};
// -------------------------------------------------------------------

class RequestJoinGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestJoinGame) */ {
 public:
  RequestJoinGame();
  virtual ~RequestJoinGame();

  RequestJoinGame(const RequestJoinGame& from);

  inline RequestJoinGame& operator=(const RequestJoinGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestJoinGame& default_instance();

  enum ParticipationCase {
    kRace = 1,
    kObservedPlayerId = 2,
    PARTICIPATION_NOT_SET = 0,
  };

  void Swap(RequestJoinGame* other);

  // implements Message ----------------------------------------------

  inline RequestJoinGame* New() const { return New(NULL); }

  RequestJoinGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestJoinGame& from);
  void MergeFrom(const RequestJoinGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestJoinGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.Race race = 1;
  bool has_race() const;
  void clear_race();
  static const int kRaceFieldNumber = 1;
  ::SC2APIProtocol::Race race() const;
  void set_race(::SC2APIProtocol::Race value);

  // optional uint32 observed_player_id = 2;
  bool has_observed_player_id() const;
  void clear_observed_player_id();
  static const int kObservedPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 observed_player_id() const;
  void set_observed_player_id(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.InterfaceOptions options = 3;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  ::SC2APIProtocol::InterfaceOptions* release_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);

  // optional .SC2APIProtocol.PortSet server_ports = 4;
  bool has_server_ports() const;
  void clear_server_ports();
  static const int kServerPortsFieldNumber = 4;
  const ::SC2APIProtocol::PortSet& server_ports() const;
  ::SC2APIProtocol::PortSet* mutable_server_ports();
  ::SC2APIProtocol::PortSet* release_server_ports();
  void set_allocated_server_ports(::SC2APIProtocol::PortSet* server_ports);

  // repeated .SC2APIProtocol.PortSet client_ports = 5;
  int client_ports_size() const;
  void clear_client_ports();
  static const int kClientPortsFieldNumber = 5;
  const ::SC2APIProtocol::PortSet& client_ports(int index) const;
  ::SC2APIProtocol::PortSet* mutable_client_ports(int index);
  ::SC2APIProtocol::PortSet* add_client_ports();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet >*
      mutable_client_ports();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet >&
      client_ports() const;

  // optional int32 shared_port = 6;
  bool has_shared_port() const;
  void clear_shared_port();
  static const int kSharedPortFieldNumber = 6;
  ::google::protobuf::int32 shared_port() const;
  void set_shared_port(::google::protobuf::int32 value);

  ParticipationCase participation_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestJoinGame)
 private:
  inline void set_has_race();
  inline void set_has_observed_player_id();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_server_ports();
  inline void clear_has_server_ports();
  inline void set_has_shared_port();
  inline void clear_has_shared_port();

  inline bool has_participation() const;
  void clear_participation();
  inline void clear_has_participation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  ::SC2APIProtocol::PortSet* server_ports_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet > client_ports_;
  ::google::protobuf::int32 shared_port_;
  union ParticipationUnion {
    ParticipationUnion() {}
    int race_;
    ::google::protobuf::uint32 observed_player_id_;
  } participation_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestJoinGame* default_instance_;
};
// -------------------------------------------------------------------

class PortSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PortSet) */ {
 public:
  PortSet();
  virtual ~PortSet();

  PortSet(const PortSet& from);

  inline PortSet& operator=(const PortSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PortSet& default_instance();

  void Swap(PortSet* other);

  // implements Message ----------------------------------------------

  inline PortSet* New() const { return New(NULL); }

  PortSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortSet& from);
  void MergeFrom(const PortSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PortSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 game_port = 1;
  bool has_game_port() const;
  void clear_game_port();
  static const int kGamePortFieldNumber = 1;
  ::google::protobuf::int32 game_port() const;
  void set_game_port(::google::protobuf::int32 value);

  // optional int32 base_port = 2;
  bool has_base_port() const;
  void clear_base_port();
  static const int kBasePortFieldNumber = 2;
  ::google::protobuf::int32 base_port() const;
  void set_base_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PortSet)
 private:
  inline void set_has_game_port();
  inline void clear_has_game_port();
  inline void set_has_base_port();
  inline void clear_has_base_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 game_port_;
  ::google::protobuf::int32 base_port_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static PortSet* default_instance_;
};
// -------------------------------------------------------------------

class ResponseJoinGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseJoinGame) */ {
 public:
  ResponseJoinGame();
  virtual ~ResponseJoinGame();

  ResponseJoinGame(const ResponseJoinGame& from);

  inline ResponseJoinGame& operator=(const ResponseJoinGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseJoinGame& default_instance();

  void Swap(ResponseJoinGame* other);

  // implements Message ----------------------------------------------

  inline ResponseJoinGame* New() const { return New(NULL); }

  ResponseJoinGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseJoinGame& from);
  void MergeFrom(const ResponseJoinGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseJoinGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResponseJoinGame_Error Error;
  static const Error MissingParticipation =
    ResponseJoinGame_Error_MissingParticipation;
  static const Error InvalidObservedPlayerId =
    ResponseJoinGame_Error_InvalidObservedPlayerId;
  static const Error MissingOptions =
    ResponseJoinGame_Error_MissingOptions;
  static const Error MissingPorts =
    ResponseJoinGame_Error_MissingPorts;
  static const Error GameFull =
    ResponseJoinGame_Error_GameFull;
  static const Error LaunchError =
    ResponseJoinGame_Error_LaunchError;
  static const Error FeatureUnsupported =
    ResponseJoinGame_Error_FeatureUnsupported;
  static const Error NoSpaceForUser =
    ResponseJoinGame_Error_NoSpaceForUser;
  static const Error MapDoesNotExist =
    ResponseJoinGame_Error_MapDoesNotExist;
  static const Error CannotOpenMap =
    ResponseJoinGame_Error_CannotOpenMap;
  static const Error ChecksumError =
    ResponseJoinGame_Error_ChecksumError;
  static const Error NetworkError =
    ResponseJoinGame_Error_NetworkError;
  static const Error OtherError =
    ResponseJoinGame_Error_OtherError;
  static inline bool Error_IsValid(int value) {
    return ResponseJoinGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseJoinGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseJoinGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseJoinGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseJoinGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseJoinGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseJoinGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.ResponseJoinGame.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  ::SC2APIProtocol::ResponseJoinGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseJoinGame_Error value);

  // optional string error_details = 3;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 3;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseJoinGame)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_error_details();
  inline void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  int error_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseJoinGame* default_instance_;
};
// -------------------------------------------------------------------

class RequestRestartGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestRestartGame) */ {
 public:
  RequestRestartGame();
  virtual ~RequestRestartGame();

  RequestRestartGame(const RequestRestartGame& from);

  inline RequestRestartGame& operator=(const RequestRestartGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRestartGame& default_instance();

  void Swap(RequestRestartGame* other);

  // implements Message ----------------------------------------------

  inline RequestRestartGame* New() const { return New(NULL); }

  RequestRestartGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRestartGame& from);
  void MergeFrom(const RequestRestartGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestRestartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestRestartGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestRestartGame* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRestartGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseRestartGame) */ {
 public:
  ResponseRestartGame();
  virtual ~ResponseRestartGame();

  ResponseRestartGame(const ResponseRestartGame& from);

  inline ResponseRestartGame& operator=(const ResponseRestartGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRestartGame& default_instance();

  void Swap(ResponseRestartGame* other);

  // implements Message ----------------------------------------------

  inline ResponseRestartGame* New() const { return New(NULL); }

  ResponseRestartGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRestartGame& from);
  void MergeFrom(const ResponseRestartGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseRestartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResponseRestartGame_Error Error;
  static const Error LaunchError =
    ResponseRestartGame_Error_LaunchError;
  static inline bool Error_IsValid(int value) {
    return ResponseRestartGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseRestartGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseRestartGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseRestartGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseRestartGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseRestartGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseRestartGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ResponseRestartGame.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SC2APIProtocol::ResponseRestartGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseRestartGame_Error value);

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseRestartGame)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_error_details();
  inline void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseRestartGame* default_instance_;
};
// -------------------------------------------------------------------

class RequestStartReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestStartReplay) */ {
 public:
  RequestStartReplay();
  virtual ~RequestStartReplay();

  RequestStartReplay(const RequestStartReplay& from);

  inline RequestStartReplay& operator=(const RequestStartReplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStartReplay& default_instance();

  enum ReplayCase {
    kReplayPath = 1,
    kReplayData = 5,
    REPLAY_NOT_SET = 0,
  };

  void Swap(RequestStartReplay* other);

  // implements Message ----------------------------------------------

  inline RequestStartReplay* New() const { return New(NULL); }

  RequestStartReplay* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestStartReplay& from);
  void MergeFrom(const RequestStartReplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestStartReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string replay_path = 1;
  bool has_replay_path() const;
  void clear_replay_path();
  static const int kReplayPathFieldNumber = 1;
  const ::std::string& replay_path() const;
  void set_replay_path(const ::std::string& value);
  void set_replay_path(const char* value);
  void set_replay_path(const char* value, size_t size);
  ::std::string* mutable_replay_path();
  ::std::string* release_replay_path();
  void set_allocated_replay_path(::std::string* replay_path);

  // optional bytes replay_data = 5;
  bool has_replay_data() const;
  void clear_replay_data();
  static const int kReplayDataFieldNumber = 5;
  const ::std::string& replay_data() const;
  void set_replay_data(const ::std::string& value);
  void set_replay_data(const char* value);
  void set_replay_data(const void* value, size_t size);
  ::std::string* mutable_replay_data();
  ::std::string* release_replay_data();
  void set_allocated_replay_data(::std::string* replay_data);

  // optional bytes map_data = 6;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 6;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // optional int32 observed_player_id = 2;
  bool has_observed_player_id() const;
  void clear_observed_player_id();
  static const int kObservedPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 observed_player_id() const;
  void set_observed_player_id(::google::protobuf::int32 value);

  // optional .SC2APIProtocol.InterfaceOptions options = 3;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  ::SC2APIProtocol::InterfaceOptions* release_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);

  // optional bool disable_fog = 4;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 4;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  ReplayCase replay_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestStartReplay)
 private:
  inline void set_has_replay_path();
  inline void set_has_replay_data();
  inline void set_has_map_data();
  inline void clear_has_map_data();
  inline void set_has_observed_player_id();
  inline void clear_has_observed_player_id();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_disable_fog();
  inline void clear_has_disable_fog();

  inline bool has_replay() const;
  void clear_replay();
  inline void clear_has_replay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  ::google::protobuf::int32 observed_player_id_;
  bool disable_fog_;
  union ReplayUnion {
    ReplayUnion() {}
    ::google::protobuf::internal::ArenaStringPtr replay_path_;
    ::google::protobuf::internal::ArenaStringPtr replay_data_;
  } replay_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestStartReplay* default_instance_;
};
// -------------------------------------------------------------------

class ResponseStartReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseStartReplay) */ {
 public:
  ResponseStartReplay();
  virtual ~ResponseStartReplay();

  ResponseStartReplay(const ResponseStartReplay& from);

  inline ResponseStartReplay& operator=(const ResponseStartReplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStartReplay& default_instance();

  void Swap(ResponseStartReplay* other);

  // implements Message ----------------------------------------------

  inline ResponseStartReplay* New() const { return New(NULL); }

  ResponseStartReplay* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseStartReplay& from);
  void MergeFrom(const ResponseStartReplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseStartReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResponseStartReplay_Error Error;
  static const Error MissingReplay =
    ResponseStartReplay_Error_MissingReplay;
  static const Error InvalidReplayPath =
    ResponseStartReplay_Error_InvalidReplayPath;
  static const Error InvalidReplayData =
    ResponseStartReplay_Error_InvalidReplayData;
  static const Error InvalidMapData =
    ResponseStartReplay_Error_InvalidMapData;
  static const Error InvalidObservedPlayerId =
    ResponseStartReplay_Error_InvalidObservedPlayerId;
  static const Error MissingOptions =
    ResponseStartReplay_Error_MissingOptions;
  static const Error LaunchError =
    ResponseStartReplay_Error_LaunchError;
  static inline bool Error_IsValid(int value) {
    return ResponseStartReplay_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseStartReplay_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseStartReplay_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseStartReplay_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseStartReplay_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseStartReplay_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseStartReplay_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ResponseStartReplay.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SC2APIProtocol::ResponseStartReplay_Error error() const;
  void set_error(::SC2APIProtocol::ResponseStartReplay_Error value);

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseStartReplay)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_error_details();
  inline void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseStartReplay* default_instance_;
};
// -------------------------------------------------------------------

class RequestLeaveGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestLeaveGame) */ {
 public:
  RequestLeaveGame();
  virtual ~RequestLeaveGame();

  RequestLeaveGame(const RequestLeaveGame& from);

  inline RequestLeaveGame& operator=(const RequestLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLeaveGame& default_instance();

  void Swap(RequestLeaveGame* other);

  // implements Message ----------------------------------------------

  inline RequestLeaveGame* New() const { return New(NULL); }

  RequestLeaveGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestLeaveGame& from);
  void MergeFrom(const RequestLeaveGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestLeaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestLeaveGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestLeaveGame* default_instance_;
};
// -------------------------------------------------------------------

class ResponseLeaveGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseLeaveGame) */ {
 public:
  ResponseLeaveGame();
  virtual ~ResponseLeaveGame();

  ResponseLeaveGame(const ResponseLeaveGame& from);

  inline ResponseLeaveGame& operator=(const ResponseLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseLeaveGame& default_instance();

  void Swap(ResponseLeaveGame* other);

  // implements Message ----------------------------------------------

  inline ResponseLeaveGame* New() const { return New(NULL); }

  ResponseLeaveGame* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseLeaveGame& from);
  void MergeFrom(const ResponseLeaveGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseLeaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseLeaveGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseLeaveGame* default_instance_;
};
// -------------------------------------------------------------------

class RequestQuickSave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuickSave) */ {
 public:
  RequestQuickSave();
  virtual ~RequestQuickSave();

  RequestQuickSave(const RequestQuickSave& from);

  inline RequestQuickSave& operator=(const RequestQuickSave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuickSave& default_instance();

  void Swap(RequestQuickSave* other);

  // implements Message ----------------------------------------------

  inline RequestQuickSave* New() const { return New(NULL); }

  RequestQuickSave* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestQuickSave& from);
  void MergeFrom(const RequestQuickSave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestQuickSave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuickSave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestQuickSave* default_instance_;
};
// -------------------------------------------------------------------

class ResponseQuickSave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuickSave) */ {
 public:
  ResponseQuickSave();
  virtual ~ResponseQuickSave();

  ResponseQuickSave(const ResponseQuickSave& from);

  inline ResponseQuickSave& operator=(const ResponseQuickSave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuickSave& default_instance();

  void Swap(ResponseQuickSave* other);

  // implements Message ----------------------------------------------

  inline ResponseQuickSave* New() const { return New(NULL); }

  ResponseQuickSave* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseQuickSave& from);
  void MergeFrom(const ResponseQuickSave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseQuickSave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuickSave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseQuickSave* default_instance_;
};
// -------------------------------------------------------------------

class RequestQuickLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuickLoad) */ {
 public:
  RequestQuickLoad();
  virtual ~RequestQuickLoad();

  RequestQuickLoad(const RequestQuickLoad& from);

  inline RequestQuickLoad& operator=(const RequestQuickLoad& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuickLoad& default_instance();

  void Swap(RequestQuickLoad* other);

  // implements Message ----------------------------------------------

  inline RequestQuickLoad* New() const { return New(NULL); }

  RequestQuickLoad* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestQuickLoad& from);
  void MergeFrom(const RequestQuickLoad& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestQuickLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuickLoad)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestQuickLoad* default_instance_;
};
// -------------------------------------------------------------------

class ResponseQuickLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuickLoad) */ {
 public:
  ResponseQuickLoad();
  virtual ~ResponseQuickLoad();

  ResponseQuickLoad(const ResponseQuickLoad& from);

  inline ResponseQuickLoad& operator=(const ResponseQuickLoad& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuickLoad& default_instance();

  void Swap(ResponseQuickLoad* other);

  // implements Message ----------------------------------------------

  inline ResponseQuickLoad* New() const { return New(NULL); }

  ResponseQuickLoad* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseQuickLoad& from);
  void MergeFrom(const ResponseQuickLoad& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseQuickLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuickLoad)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseQuickLoad* default_instance_;
};
// -------------------------------------------------------------------

class RequestQuit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuit) */ {
 public:
  RequestQuit();
  virtual ~RequestQuit();

  RequestQuit(const RequestQuit& from);

  inline RequestQuit& operator=(const RequestQuit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuit& default_instance();

  void Swap(RequestQuit* other);

  // implements Message ----------------------------------------------

  inline RequestQuit* New() const { return New(NULL); }

  RequestQuit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestQuit& from);
  void MergeFrom(const RequestQuit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestQuit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestQuit* default_instance_;
};
// -------------------------------------------------------------------

class ResponseQuit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuit) */ {
 public:
  ResponseQuit();
  virtual ~ResponseQuit();

  ResponseQuit(const ResponseQuit& from);

  inline ResponseQuit& operator=(const ResponseQuit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuit& default_instance();

  void Swap(ResponseQuit* other);

  // implements Message ----------------------------------------------

  inline ResponseQuit* New() const { return New(NULL); }

  ResponseQuit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseQuit& from);
  void MergeFrom(const ResponseQuit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseQuit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseQuit* default_instance_;
};
// -------------------------------------------------------------------

class RequestGameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestGameInfo) */ {
 public:
  RequestGameInfo();
  virtual ~RequestGameInfo();

  RequestGameInfo(const RequestGameInfo& from);

  inline RequestGameInfo& operator=(const RequestGameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGameInfo& default_instance();

  void Swap(RequestGameInfo* other);

  // implements Message ----------------------------------------------

  inline RequestGameInfo* New() const { return New(NULL); }

  RequestGameInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestGameInfo& from);
  void MergeFrom(const RequestGameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestGameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestGameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestGameInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseGameInfo) */ {
 public:
  ResponseGameInfo();
  virtual ~ResponseGameInfo();

  ResponseGameInfo(const ResponseGameInfo& from);

  inline ResponseGameInfo& operator=(const ResponseGameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseGameInfo& default_instance();

  void Swap(ResponseGameInfo* other);

  // implements Message ----------------------------------------------

  inline ResponseGameInfo* New() const { return New(NULL); }

  ResponseGameInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseGameInfo& from);
  void MergeFrom(const ResponseGameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseGameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // repeated string mod_names = 6;
  int mod_names_size() const;
  void clear_mod_names();
  static const int kModNamesFieldNumber = 6;
  const ::std::string& mod_names(int index) const;
  ::std::string* mutable_mod_names(int index);
  void set_mod_names(int index, const ::std::string& value);
  void set_mod_names(int index, const char* value);
  void set_mod_names(int index, const char* value, size_t size);
  ::std::string* add_mod_names();
  void add_mod_names(const ::std::string& value);
  void add_mod_names(const char* value);
  void add_mod_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mod_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mod_names();

  // optional string local_map_path = 2;
  bool has_local_map_path() const;
  void clear_local_map_path();
  static const int kLocalMapPathFieldNumber = 2;
  const ::std::string& local_map_path() const;
  void set_local_map_path(const ::std::string& value);
  void set_local_map_path(const char* value);
  void set_local_map_path(const char* value, size_t size);
  ::std::string* mutable_local_map_path();
  ::std::string* release_local_map_path();
  void set_allocated_local_map_path(::std::string* local_map_path);

  // repeated .SC2APIProtocol.PlayerInfo player_info = 3;
  int player_info_size() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 3;
  const ::SC2APIProtocol::PlayerInfo& player_info(int index) const;
  ::SC2APIProtocol::PlayerInfo* mutable_player_info(int index);
  ::SC2APIProtocol::PlayerInfo* add_player_info();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >*
      mutable_player_info();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >&
      player_info() const;

  // optional .SC2APIProtocol.StartRaw start_raw = 4;
  bool has_start_raw() const;
  void clear_start_raw();
  static const int kStartRawFieldNumber = 4;
  const ::SC2APIProtocol::StartRaw& start_raw() const;
  ::SC2APIProtocol::StartRaw* mutable_start_raw();
  ::SC2APIProtocol::StartRaw* release_start_raw();
  void set_allocated_start_raw(::SC2APIProtocol::StartRaw* start_raw);

  // optional .SC2APIProtocol.InterfaceOptions options = 5;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 5;
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  ::SC2APIProtocol::InterfaceOptions* release_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseGameInfo)
 private:
  inline void set_has_map_name();
  inline void clear_has_map_name();
  inline void set_has_local_map_path();
  inline void clear_has_local_map_path();
  inline void set_has_start_raw();
  inline void clear_has_start_raw();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mod_names_;
  ::google::protobuf::internal::ArenaStringPtr local_map_path_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo > player_info_;
  ::SC2APIProtocol::StartRaw* start_raw_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseGameInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestObservation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestObservation) */ {
 public:
  RequestObservation();
  virtual ~RequestObservation();

  RequestObservation(const RequestObservation& from);

  inline RequestObservation& operator=(const RequestObservation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestObservation& default_instance();

  void Swap(RequestObservation* other);

  // implements Message ----------------------------------------------

  inline RequestObservation* New() const { return New(NULL); }

  RequestObservation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestObservation& from);
  void MergeFrom(const RequestObservation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestObservation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disable_fog = 1;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 1;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestObservation)
 private:
  inline void set_has_disable_fog();
  inline void clear_has_disable_fog();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool disable_fog_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestObservation* default_instance_;
};
// -------------------------------------------------------------------

class ResponseObservation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseObservation) */ {
 public:
  ResponseObservation();
  virtual ~ResponseObservation();

  ResponseObservation(const ResponseObservation& from);

  inline ResponseObservation& operator=(const ResponseObservation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseObservation& default_instance();

  void Swap(ResponseObservation* other);

  // implements Message ----------------------------------------------

  inline ResponseObservation* New() const { return New(NULL); }

  ResponseObservation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseObservation& from);
  void MergeFrom(const ResponseObservation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseObservation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.Action actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  const ::SC2APIProtocol::Action& actions(int index) const;
  ::SC2APIProtocol::Action* mutable_actions(int index);
  ::SC2APIProtocol::Action* add_actions();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >*
      mutable_actions();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >&
      actions() const;

  // repeated .SC2APIProtocol.ActionError action_errors = 2;
  int action_errors_size() const;
  void clear_action_errors();
  static const int kActionErrorsFieldNumber = 2;
  const ::SC2APIProtocol::ActionError& action_errors(int index) const;
  ::SC2APIProtocol::ActionError* mutable_action_errors(int index);
  ::SC2APIProtocol::ActionError* add_action_errors();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError >*
      mutable_action_errors();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError >&
      action_errors() const;

  // optional .SC2APIProtocol.Observation observation = 3;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 3;
  const ::SC2APIProtocol::Observation& observation() const;
  ::SC2APIProtocol::Observation* mutable_observation();
  ::SC2APIProtocol::Observation* release_observation();
  void set_allocated_observation(::SC2APIProtocol::Observation* observation);

  // repeated .SC2APIProtocol.PlayerResult player_result = 4;
  int player_result_size() const;
  void clear_player_result();
  static const int kPlayerResultFieldNumber = 4;
  const ::SC2APIProtocol::PlayerResult& player_result(int index) const;
  ::SC2APIProtocol::PlayerResult* mutable_player_result(int index);
  ::SC2APIProtocol::PlayerResult* add_player_result();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >*
      mutable_player_result();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >&
      player_result() const;

  // repeated .SC2APIProtocol.ChatReceived chat = 5;
  int chat_size() const;
  void clear_chat();
  static const int kChatFieldNumber = 5;
  const ::SC2APIProtocol::ChatReceived& chat(int index) const;
  ::SC2APIProtocol::ChatReceived* mutable_chat(int index);
  ::SC2APIProtocol::ChatReceived* add_chat();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >*
      mutable_chat();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >&
      chat() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseObservation)
 private:
  inline void set_has_observation();
  inline void clear_has_observation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action > actions_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError > action_errors_;
  ::SC2APIProtocol::Observation* observation_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult > player_result_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived > chat_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseObservation* default_instance_;
};
// -------------------------------------------------------------------

class ChatReceived : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ChatReceived) */ {
 public:
  ChatReceived();
  virtual ~ChatReceived();

  ChatReceived(const ChatReceived& from);

  inline ChatReceived& operator=(const ChatReceived& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReceived& default_instance();

  void Swap(ChatReceived* other);

  // implements Message ----------------------------------------------

  inline ChatReceived* New() const { return New(NULL); }

  ChatReceived* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatReceived& from);
  void MergeFrom(const ChatReceived& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatReceived* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 player_id() const;
  void set_player_id(::google::protobuf::int32 value);

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ChatReceived)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 player_id_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ChatReceived* default_instance_;
};
// -------------------------------------------------------------------

class RequestAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestAction) */ {
 public:
  RequestAction();
  virtual ~RequestAction();

  RequestAction(const RequestAction& from);

  inline RequestAction& operator=(const RequestAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestAction& default_instance();

  void Swap(RequestAction* other);

  // implements Message ----------------------------------------------

  inline RequestAction* New() const { return New(NULL); }

  RequestAction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestAction& from);
  void MergeFrom(const RequestAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.Action actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  const ::SC2APIProtocol::Action& actions(int index) const;
  ::SC2APIProtocol::Action* mutable_actions(int index);
  ::SC2APIProtocol::Action* add_actions();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >*
      mutable_actions();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >&
      actions() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action > actions_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestAction* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseAction) */ {
 public:
  ResponseAction();
  virtual ~ResponseAction();

  ResponseAction(const ResponseAction& from);

  inline ResponseAction& operator=(const ResponseAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseAction& default_instance();

  void Swap(ResponseAction* other);

  // implements Message ----------------------------------------------

  inline ResponseAction* New() const { return New(NULL); }

  ResponseAction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseAction& from);
  void MergeFrom(const ResponseAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.ActionResult result = 1;
  int result_size() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::SC2APIProtocol::ActionResult result(int index) const;
  void set_result(int index, ::SC2APIProtocol::ActionResult value);
  void add_result(::SC2APIProtocol::ActionResult value);
  const ::google::protobuf::RepeatedField<int>& result() const;
  ::google::protobuf::RepeatedField<int>* mutable_result();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> result_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseAction* default_instance_;
};
// -------------------------------------------------------------------

class RequestStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestStep) */ {
 public:
  RequestStep();
  virtual ~RequestStep();

  RequestStep(const RequestStep& from);

  inline RequestStep& operator=(const RequestStep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStep& default_instance();

  void Swap(RequestStep* other);

  // implements Message ----------------------------------------------

  inline RequestStep* New() const { return New(NULL); }

  RequestStep* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestStep& from);
  void MergeFrom(const RequestStep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestStep)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestStep* default_instance_;
};
// -------------------------------------------------------------------

class ResponseStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseStep) */ {
 public:
  ResponseStep();
  virtual ~ResponseStep();

  ResponseStep(const ResponseStep& from);

  inline ResponseStep& operator=(const ResponseStep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStep& default_instance();

  void Swap(ResponseStep* other);

  // implements Message ----------------------------------------------

  inline ResponseStep* New() const { return New(NULL); }

  ResponseStep* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseStep& from);
  void MergeFrom(const ResponseStep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseStep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseStep* default_instance_;
};
// -------------------------------------------------------------------

class RequestData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestData) */ {
 public:
  RequestData();
  virtual ~RequestData();

  RequestData(const RequestData& from);

  inline RequestData& operator=(const RequestData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestData& default_instance();

  void Swap(RequestData* other);

  // implements Message ----------------------------------------------

  inline RequestData* New() const { return New(NULL); }

  RequestData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestData& from);
  void MergeFrom(const RequestData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  bool ability_id() const;
  void set_ability_id(bool value);

  // optional bool unit_type_id = 2;
  bool has_unit_type_id() const;
  void clear_unit_type_id();
  static const int kUnitTypeIdFieldNumber = 2;
  bool unit_type_id() const;
  void set_unit_type_id(bool value);

  // optional bool upgrade_id = 3;
  bool has_upgrade_id() const;
  void clear_upgrade_id();
  static const int kUpgradeIdFieldNumber = 3;
  bool upgrade_id() const;
  void set_upgrade_id(bool value);

  // optional bool buff_id = 4;
  bool has_buff_id() const;
  void clear_buff_id();
  static const int kBuffIdFieldNumber = 4;
  bool buff_id() const;
  void set_buff_id(bool value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestData)
 private:
  inline void set_has_ability_id();
  inline void clear_has_ability_id();
  inline void set_has_unit_type_id();
  inline void clear_has_unit_type_id();
  inline void set_has_upgrade_id();
  inline void clear_has_upgrade_id();
  inline void set_has_buff_id();
  inline void clear_has_buff_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool ability_id_;
  bool unit_type_id_;
  bool upgrade_id_;
  bool buff_id_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestData* default_instance_;
};
// -------------------------------------------------------------------

class ResponseData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseData) */ {
 public:
  ResponseData();
  virtual ~ResponseData();

  ResponseData(const ResponseData& from);

  inline ResponseData& operator=(const ResponseData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseData& default_instance();

  void Swap(ResponseData* other);

  // implements Message ----------------------------------------------

  inline ResponseData* New() const { return New(NULL); }

  ResponseData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseData& from);
  void MergeFrom(const ResponseData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.AbilityData abilities = 1;
  int abilities_size() const;
  void clear_abilities();
  static const int kAbilitiesFieldNumber = 1;
  const ::SC2APIProtocol::AbilityData& abilities(int index) const;
  ::SC2APIProtocol::AbilityData* mutable_abilities(int index);
  ::SC2APIProtocol::AbilityData* add_abilities();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData >*
      mutable_abilities();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData >&
      abilities() const;

  // repeated .SC2APIProtocol.UnitTypeData units = 2;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  const ::SC2APIProtocol::UnitTypeData& units(int index) const;
  ::SC2APIProtocol::UnitTypeData* mutable_units(int index);
  ::SC2APIProtocol::UnitTypeData* add_units();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >*
      mutable_units();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >&
      units() const;

  // repeated .SC2APIProtocol.UpgradeData upgrades = 3;
  int upgrades_size() const;
  void clear_upgrades();
  static const int kUpgradesFieldNumber = 3;
  const ::SC2APIProtocol::UpgradeData& upgrades(int index) const;
  ::SC2APIProtocol::UpgradeData* mutable_upgrades(int index);
  ::SC2APIProtocol::UpgradeData* add_upgrades();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >*
      mutable_upgrades();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >&
      upgrades() const;

  // repeated .SC2APIProtocol.BuffData buffs = 4;
  int buffs_size() const;
  void clear_buffs();
  static const int kBuffsFieldNumber = 4;
  const ::SC2APIProtocol::BuffData& buffs(int index) const;
  ::SC2APIProtocol::BuffData* mutable_buffs(int index);
  ::SC2APIProtocol::BuffData* add_buffs();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData >*
      mutable_buffs();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData >&
      buffs() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData > abilities_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData > units_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData > upgrades_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData > buffs_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseData* default_instance_;
};
// -------------------------------------------------------------------

class RequestSaveReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestSaveReplay) */ {
 public:
  RequestSaveReplay();
  virtual ~RequestSaveReplay();

  RequestSaveReplay(const RequestSaveReplay& from);

  inline RequestSaveReplay& operator=(const RequestSaveReplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSaveReplay& default_instance();

  void Swap(RequestSaveReplay* other);

  // implements Message ----------------------------------------------

  inline RequestSaveReplay* New() const { return New(NULL); }

  RequestSaveReplay* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestSaveReplay& from);
  void MergeFrom(const RequestSaveReplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestSaveReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestSaveReplay)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestSaveReplay* default_instance_;
};
// -------------------------------------------------------------------

class ResponseSaveReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseSaveReplay) */ {
 public:
  ResponseSaveReplay();
  virtual ~ResponseSaveReplay();

  ResponseSaveReplay(const ResponseSaveReplay& from);

  inline ResponseSaveReplay& operator=(const ResponseSaveReplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSaveReplay& default_instance();

  void Swap(ResponseSaveReplay* other);

  // implements Message ----------------------------------------------

  inline ResponseSaveReplay* New() const { return New(NULL); }

  ResponseSaveReplay* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseSaveReplay& from);
  void MergeFrom(const ResponseSaveReplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseSaveReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseSaveReplay)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseSaveReplay* default_instance_;
};
// -------------------------------------------------------------------

class RequestReplayInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestReplayInfo) */ {
 public:
  RequestReplayInfo();
  virtual ~RequestReplayInfo();

  RequestReplayInfo(const RequestReplayInfo& from);

  inline RequestReplayInfo& operator=(const RequestReplayInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestReplayInfo& default_instance();

  enum ReplayCase {
    kReplayPath = 1,
    kReplayData = 2,
    REPLAY_NOT_SET = 0,
  };

  void Swap(RequestReplayInfo* other);

  // implements Message ----------------------------------------------

  inline RequestReplayInfo* New() const { return New(NULL); }

  RequestReplayInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestReplayInfo& from);
  void MergeFrom(const RequestReplayInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestReplayInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string replay_path = 1;
  bool has_replay_path() const;
  void clear_replay_path();
  static const int kReplayPathFieldNumber = 1;
  const ::std::string& replay_path() const;
  void set_replay_path(const ::std::string& value);
  void set_replay_path(const char* value);
  void set_replay_path(const char* value, size_t size);
  ::std::string* mutable_replay_path();
  ::std::string* release_replay_path();
  void set_allocated_replay_path(::std::string* replay_path);

  // optional bytes replay_data = 2;
  bool has_replay_data() const;
  void clear_replay_data();
  static const int kReplayDataFieldNumber = 2;
  const ::std::string& replay_data() const;
  void set_replay_data(const ::std::string& value);
  void set_replay_data(const char* value);
  void set_replay_data(const void* value, size_t size);
  ::std::string* mutable_replay_data();
  ::std::string* release_replay_data();
  void set_allocated_replay_data(::std::string* replay_data);

  // optional bool download_data = 3;
  bool has_download_data() const;
  void clear_download_data();
  static const int kDownloadDataFieldNumber = 3;
  bool download_data() const;
  void set_download_data(bool value);

  ReplayCase replay_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestReplayInfo)
 private:
  inline void set_has_replay_path();
  inline void set_has_replay_data();
  inline void set_has_download_data();
  inline void clear_has_download_data();

  inline bool has_replay() const;
  void clear_replay();
  inline void clear_has_replay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool download_data_;
  union ReplayUnion {
    ReplayUnion() {}
    ::google::protobuf::internal::ArenaStringPtr replay_path_;
    ::google::protobuf::internal::ArenaStringPtr replay_data_;
  } replay_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestReplayInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfoExtra : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerInfoExtra) */ {
 public:
  PlayerInfoExtra();
  virtual ~PlayerInfoExtra();

  PlayerInfoExtra(const PlayerInfoExtra& from);

  inline PlayerInfoExtra& operator=(const PlayerInfoExtra& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfoExtra& default_instance();

  void Swap(PlayerInfoExtra* other);

  // implements Message ----------------------------------------------

  inline PlayerInfoExtra* New() const { return New(NULL); }

  PlayerInfoExtra* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfoExtra& from);
  void MergeFrom(const PlayerInfoExtra& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoExtra* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.PlayerInfo player_info = 1;
  bool has_player_info() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 1;
  const ::SC2APIProtocol::PlayerInfo& player_info() const;
  ::SC2APIProtocol::PlayerInfo* mutable_player_info();
  ::SC2APIProtocol::PlayerInfo* release_player_info();
  void set_allocated_player_info(::SC2APIProtocol::PlayerInfo* player_info);

  // optional .SC2APIProtocol.PlayerResult player_result = 2;
  bool has_player_result() const;
  void clear_player_result();
  static const int kPlayerResultFieldNumber = 2;
  const ::SC2APIProtocol::PlayerResult& player_result() const;
  ::SC2APIProtocol::PlayerResult* mutable_player_result();
  ::SC2APIProtocol::PlayerResult* release_player_result();
  void set_allocated_player_result(::SC2APIProtocol::PlayerResult* player_result);

  // optional int32 player_mmr = 3;
  bool has_player_mmr() const;
  void clear_player_mmr();
  static const int kPlayerMmrFieldNumber = 3;
  ::google::protobuf::int32 player_mmr() const;
  void set_player_mmr(::google::protobuf::int32 value);

  // optional int32 player_apm = 4;
  bool has_player_apm() const;
  void clear_player_apm();
  static const int kPlayerApmFieldNumber = 4;
  ::google::protobuf::int32 player_apm() const;
  void set_player_apm(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerInfoExtra)
 private:
  inline void set_has_player_info();
  inline void clear_has_player_info();
  inline void set_has_player_result();
  inline void clear_has_player_result();
  inline void set_has_player_mmr();
  inline void clear_has_player_mmr();
  inline void set_has_player_apm();
  inline void clear_has_player_apm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::PlayerInfo* player_info_;
  ::SC2APIProtocol::PlayerResult* player_result_;
  ::google::protobuf::int32 player_mmr_;
  ::google::protobuf::int32 player_apm_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfoExtra* default_instance_;
};
// -------------------------------------------------------------------

class ResponseReplayInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseReplayInfo) */ {
 public:
  ResponseReplayInfo();
  virtual ~ResponseReplayInfo();

  ResponseReplayInfo(const ResponseReplayInfo& from);

  inline ResponseReplayInfo& operator=(const ResponseReplayInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseReplayInfo& default_instance();

  void Swap(ResponseReplayInfo* other);

  // implements Message ----------------------------------------------

  inline ResponseReplayInfo* New() const { return New(NULL); }

  ResponseReplayInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseReplayInfo& from);
  void MergeFrom(const ResponseReplayInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseReplayInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResponseReplayInfo_Error Error;
  static const Error MissingReplay =
    ResponseReplayInfo_Error_MissingReplay;
  static const Error InvalidReplayPath =
    ResponseReplayInfo_Error_InvalidReplayPath;
  static const Error InvalidReplayData =
    ResponseReplayInfo_Error_InvalidReplayData;
  static const Error ParsingError =
    ResponseReplayInfo_Error_ParsingError;
  static const Error DownloadError =
    ResponseReplayInfo_Error_DownloadError;
  static inline bool Error_IsValid(int value) {
    return ResponseReplayInfo_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseReplayInfo_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseReplayInfo_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseReplayInfo_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseReplayInfo_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseReplayInfo_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseReplayInfo_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional string local_map_path = 2;
  bool has_local_map_path() const;
  void clear_local_map_path();
  static const int kLocalMapPathFieldNumber = 2;
  const ::std::string& local_map_path() const;
  void set_local_map_path(const ::std::string& value);
  void set_local_map_path(const char* value);
  void set_local_map_path(const char* value, size_t size);
  ::std::string* mutable_local_map_path();
  ::std::string* release_local_map_path();
  void set_allocated_local_map_path(::std::string* local_map_path);

  // repeated .SC2APIProtocol.PlayerInfoExtra player_info = 3;
  int player_info_size() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 3;
  const ::SC2APIProtocol::PlayerInfoExtra& player_info(int index) const;
  ::SC2APIProtocol::PlayerInfoExtra* mutable_player_info(int index);
  ::SC2APIProtocol::PlayerInfoExtra* add_player_info();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >*
      mutable_player_info();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >&
      player_info() const;

  // optional uint32 game_duration_loops = 4;
  bool has_game_duration_loops() const;
  void clear_game_duration_loops();
  static const int kGameDurationLoopsFieldNumber = 4;
  ::google::protobuf::uint32 game_duration_loops() const;
  void set_game_duration_loops(::google::protobuf::uint32 value);

  // optional float game_duration_seconds = 5;
  bool has_game_duration_seconds() const;
  void clear_game_duration_seconds();
  static const int kGameDurationSecondsFieldNumber = 5;
  float game_duration_seconds() const;
  void set_game_duration_seconds(float value);

  // optional string game_version = 6;
  bool has_game_version() const;
  void clear_game_version();
  static const int kGameVersionFieldNumber = 6;
  const ::std::string& game_version() const;
  void set_game_version(const ::std::string& value);
  void set_game_version(const char* value);
  void set_game_version(const char* value, size_t size);
  ::std::string* mutable_game_version();
  ::std::string* release_game_version();
  void set_allocated_game_version(::std::string* game_version);

  // optional string data_version = 11;
  bool has_data_version() const;
  void clear_data_version();
  static const int kDataVersionFieldNumber = 11;
  const ::std::string& data_version() const;
  void set_data_version(const ::std::string& value);
  void set_data_version(const char* value);
  void set_data_version(const char* value, size_t size);
  ::std::string* mutable_data_version();
  ::std::string* release_data_version();
  void set_allocated_data_version(::std::string* data_version);

  // optional uint32 data_build = 7;
  bool has_data_build() const;
  void clear_data_build();
  static const int kDataBuildFieldNumber = 7;
  ::google::protobuf::uint32 data_build() const;
  void set_data_build(::google::protobuf::uint32 value);

  // optional uint32 base_build = 8;
  bool has_base_build() const;
  void clear_base_build();
  static const int kBaseBuildFieldNumber = 8;
  ::google::protobuf::uint32 base_build() const;
  void set_base_build(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.ResponseReplayInfo.Error error = 9;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 9;
  ::SC2APIProtocol::ResponseReplayInfo_Error error() const;
  void set_error(::SC2APIProtocol::ResponseReplayInfo_Error value);

  // optional string error_details = 10;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 10;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseReplayInfo)
 private:
  inline void set_has_map_name();
  inline void clear_has_map_name();
  inline void set_has_local_map_path();
  inline void clear_has_local_map_path();
  inline void set_has_game_duration_loops();
  inline void clear_has_game_duration_loops();
  inline void set_has_game_duration_seconds();
  inline void clear_has_game_duration_seconds();
  inline void set_has_game_version();
  inline void clear_has_game_version();
  inline void set_has_data_version();
  inline void clear_has_data_version();
  inline void set_has_data_build();
  inline void clear_has_data_build();
  inline void set_has_base_build();
  inline void clear_has_base_build();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_error_details();
  inline void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::google::protobuf::internal::ArenaStringPtr local_map_path_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra > player_info_;
  ::google::protobuf::uint32 game_duration_loops_;
  float game_duration_seconds_;
  ::google::protobuf::internal::ArenaStringPtr game_version_;
  ::google::protobuf::internal::ArenaStringPtr data_version_;
  ::google::protobuf::uint32 data_build_;
  ::google::protobuf::uint32 base_build_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseReplayInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestAvailableMaps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestAvailableMaps) */ {
 public:
  RequestAvailableMaps();
  virtual ~RequestAvailableMaps();

  RequestAvailableMaps(const RequestAvailableMaps& from);

  inline RequestAvailableMaps& operator=(const RequestAvailableMaps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestAvailableMaps& default_instance();

  void Swap(RequestAvailableMaps* other);

  // implements Message ----------------------------------------------

  inline RequestAvailableMaps* New() const { return New(NULL); }

  RequestAvailableMaps* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestAvailableMaps& from);
  void MergeFrom(const RequestAvailableMaps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestAvailableMaps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestAvailableMaps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestAvailableMaps* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAvailableMaps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseAvailableMaps) */ {
 public:
  ResponseAvailableMaps();
  virtual ~ResponseAvailableMaps();

  ResponseAvailableMaps(const ResponseAvailableMaps& from);

  inline ResponseAvailableMaps& operator=(const ResponseAvailableMaps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseAvailableMaps& default_instance();

  void Swap(ResponseAvailableMaps* other);

  // implements Message ----------------------------------------------

  inline ResponseAvailableMaps* New() const { return New(NULL); }

  ResponseAvailableMaps* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseAvailableMaps& from);
  void MergeFrom(const ResponseAvailableMaps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseAvailableMaps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string local_map_paths = 1;
  int local_map_paths_size() const;
  void clear_local_map_paths();
  static const int kLocalMapPathsFieldNumber = 1;
  const ::std::string& local_map_paths(int index) const;
  ::std::string* mutable_local_map_paths(int index);
  void set_local_map_paths(int index, const ::std::string& value);
  void set_local_map_paths(int index, const char* value);
  void set_local_map_paths(int index, const char* value, size_t size);
  ::std::string* add_local_map_paths();
  void add_local_map_paths(const ::std::string& value);
  void add_local_map_paths(const char* value);
  void add_local_map_paths(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& local_map_paths() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_local_map_paths();

  // repeated string battlenet_map_names = 2;
  int battlenet_map_names_size() const;
  void clear_battlenet_map_names();
  static const int kBattlenetMapNamesFieldNumber = 2;
  const ::std::string& battlenet_map_names(int index) const;
  ::std::string* mutable_battlenet_map_names(int index);
  void set_battlenet_map_names(int index, const ::std::string& value);
  void set_battlenet_map_names(int index, const char* value);
  void set_battlenet_map_names(int index, const char* value, size_t size);
  ::std::string* add_battlenet_map_names();
  void add_battlenet_map_names(const ::std::string& value);
  void add_battlenet_map_names(const char* value);
  void add_battlenet_map_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& battlenet_map_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_battlenet_map_names();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseAvailableMaps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> local_map_paths_;
  ::google::protobuf::RepeatedPtrField< ::std::string> battlenet_map_names_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseAvailableMaps* default_instance_;
};
// -------------------------------------------------------------------

class RequestSaveMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestSaveMap) */ {
 public:
  RequestSaveMap();
  virtual ~RequestSaveMap();

  RequestSaveMap(const RequestSaveMap& from);

  inline RequestSaveMap& operator=(const RequestSaveMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSaveMap& default_instance();

  void Swap(RequestSaveMap* other);

  // implements Message ----------------------------------------------

  inline RequestSaveMap* New() const { return New(NULL); }

  RequestSaveMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestSaveMap& from);
  void MergeFrom(const RequestSaveMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestSaveMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_path = 1;
  bool has_map_path() const;
  void clear_map_path();
  static const int kMapPathFieldNumber = 1;
  const ::std::string& map_path() const;
  void set_map_path(const ::std::string& value);
  void set_map_path(const char* value);
  void set_map_path(const char* value, size_t size);
  ::std::string* mutable_map_path();
  ::std::string* release_map_path();
  void set_allocated_map_path(::std::string* map_path);

  // optional bytes map_data = 2;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 2;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestSaveMap)
 private:
  inline void set_has_map_path();
  inline void clear_has_map_path();
  inline void set_has_map_data();
  inline void clear_has_map_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_path_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestSaveMap* default_instance_;
};
// -------------------------------------------------------------------

class ResponseSaveMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseSaveMap) */ {
 public:
  ResponseSaveMap();
  virtual ~ResponseSaveMap();

  ResponseSaveMap(const ResponseSaveMap& from);

  inline ResponseSaveMap& operator=(const ResponseSaveMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSaveMap& default_instance();

  void Swap(ResponseSaveMap* other);

  // implements Message ----------------------------------------------

  inline ResponseSaveMap* New() const { return New(NULL); }

  ResponseSaveMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseSaveMap& from);
  void MergeFrom(const ResponseSaveMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseSaveMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResponseSaveMap_Error Error;
  static const Error InvalidMapData =
    ResponseSaveMap_Error_InvalidMapData;
  static inline bool Error_IsValid(int value) {
    return ResponseSaveMap_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseSaveMap_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseSaveMap_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseSaveMap_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseSaveMap_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseSaveMap_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseSaveMap_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ResponseSaveMap.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SC2APIProtocol::ResponseSaveMap_Error error() const;
  void set_error(::SC2APIProtocol::ResponseSaveMap_Error value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseSaveMap)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int error_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseSaveMap* default_instance_;
};
// -------------------------------------------------------------------

class RequestPing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestPing) */ {
 public:
  RequestPing();
  virtual ~RequestPing();

  RequestPing(const RequestPing& from);

  inline RequestPing& operator=(const RequestPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPing& default_instance();

  void Swap(RequestPing* other);

  // implements Message ----------------------------------------------

  inline RequestPing* New() const { return New(NULL); }

  RequestPing* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPing& from);
  void MergeFrom(const RequestPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestPing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestPing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestPing* default_instance_;
};
// -------------------------------------------------------------------

class ResponsePing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponsePing) */ {
 public:
  ResponsePing();
  virtual ~ResponsePing();

  ResponsePing(const ResponsePing& from);

  inline ResponsePing& operator=(const ResponsePing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponsePing& default_instance();

  void Swap(ResponsePing* other);

  // implements Message ----------------------------------------------

  inline ResponsePing* New() const { return New(NULL); }

  ResponsePing* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponsePing& from);
  void MergeFrom(const ResponsePing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponsePing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_version = 1;
  bool has_game_version() const;
  void clear_game_version();
  static const int kGameVersionFieldNumber = 1;
  const ::std::string& game_version() const;
  void set_game_version(const ::std::string& value);
  void set_game_version(const char* value);
  void set_game_version(const char* value, size_t size);
  ::std::string* mutable_game_version();
  ::std::string* release_game_version();
  void set_allocated_game_version(::std::string* game_version);

  // optional string data_version = 2;
  bool has_data_version() const;
  void clear_data_version();
  static const int kDataVersionFieldNumber = 2;
  const ::std::string& data_version() const;
  void set_data_version(const ::std::string& value);
  void set_data_version(const char* value);
  void set_data_version(const char* value, size_t size);
  ::std::string* mutable_data_version();
  ::std::string* release_data_version();
  void set_allocated_data_version(::std::string* data_version);

  // optional uint32 data_build = 3;
  bool has_data_build() const;
  void clear_data_build();
  static const int kDataBuildFieldNumber = 3;
  ::google::protobuf::uint32 data_build() const;
  void set_data_build(::google::protobuf::uint32 value);

  // optional uint32 base_build = 4;
  bool has_base_build() const;
  void clear_base_build();
  static const int kBaseBuildFieldNumber = 4;
  ::google::protobuf::uint32 base_build() const;
  void set_base_build(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponsePing)
 private:
  inline void set_has_game_version();
  inline void clear_has_game_version();
  inline void set_has_data_version();
  inline void clear_has_data_version();
  inline void set_has_data_build();
  inline void clear_has_data_build();
  inline void set_has_base_build();
  inline void clear_has_base_build();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr game_version_;
  ::google::protobuf::internal::ArenaStringPtr data_version_;
  ::google::protobuf::uint32 data_build_;
  ::google::protobuf::uint32 base_build_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponsePing* default_instance_;
};
// -------------------------------------------------------------------

class RequestDebug : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestDebug) */ {
 public:
  RequestDebug();
  virtual ~RequestDebug();

  RequestDebug(const RequestDebug& from);

  inline RequestDebug& operator=(const RequestDebug& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestDebug& default_instance();

  void Swap(RequestDebug* other);

  // implements Message ----------------------------------------------

  inline RequestDebug* New() const { return New(NULL); }

  RequestDebug* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestDebug& from);
  void MergeFrom(const RequestDebug& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestDebug* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.DebugCommand debug = 1;
  int debug_size() const;
  void clear_debug();
  static const int kDebugFieldNumber = 1;
  const ::SC2APIProtocol::DebugCommand& debug(int index) const;
  ::SC2APIProtocol::DebugCommand* mutable_debug(int index);
  ::SC2APIProtocol::DebugCommand* add_debug();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >*
      mutable_debug();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >&
      debug() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestDebug)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand > debug_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static RequestDebug* default_instance_;
};
// -------------------------------------------------------------------

class ResponseDebug : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseDebug) */ {
 public:
  ResponseDebug();
  virtual ~ResponseDebug();

  ResponseDebug(const ResponseDebug& from);

  inline ResponseDebug& operator=(const ResponseDebug& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseDebug& default_instance();

  void Swap(ResponseDebug* other);

  // implements Message ----------------------------------------------

  inline ResponseDebug* New() const { return New(NULL); }

  ResponseDebug* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseDebug& from);
  void MergeFrom(const ResponseDebug& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseDebug* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseDebug)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ResponseDebug* default_instance_;
};
// -------------------------------------------------------------------

class PlayerSetup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerSetup) */ {
 public:
  PlayerSetup();
  virtual ~PlayerSetup();

  PlayerSetup(const PlayerSetup& from);

  inline PlayerSetup& operator=(const PlayerSetup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSetup& default_instance();

  void Swap(PlayerSetup* other);

  // implements Message ----------------------------------------------

  inline PlayerSetup* New() const { return New(NULL); }

  PlayerSetup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerSetup& from);
  void MergeFrom(const PlayerSetup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerSetup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.PlayerType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SC2APIProtocol::PlayerType type() const;
  void set_type(::SC2APIProtocol::PlayerType value);

  // optional .SC2APIProtocol.Race race = 2;
  bool has_race() const;
  void clear_race();
  static const int kRaceFieldNumber = 2;
  ::SC2APIProtocol::Race race() const;
  void set_race(::SC2APIProtocol::Race value);

  // optional .SC2APIProtocol.Difficulty difficulty = 3;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 3;
  ::SC2APIProtocol::Difficulty difficulty() const;
  void set_difficulty(::SC2APIProtocol::Difficulty value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerSetup)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_difficulty();
  inline void clear_has_difficulty();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  int race_;
  int difficulty_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static PlayerSetup* default_instance_;
};
// -------------------------------------------------------------------

class SpatialCameraSetup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.SpatialCameraSetup) */ {
 public:
  SpatialCameraSetup();
  virtual ~SpatialCameraSetup();

  SpatialCameraSetup(const SpatialCameraSetup& from);

  inline SpatialCameraSetup& operator=(const SpatialCameraSetup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpatialCameraSetup& default_instance();

  void Swap(SpatialCameraSetup* other);

  // implements Message ----------------------------------------------

  inline SpatialCameraSetup* New() const { return New(NULL); }

  SpatialCameraSetup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpatialCameraSetup& from);
  void MergeFrom(const SpatialCameraSetup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SpatialCameraSetup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  float width() const;
  void set_width(float value);

  // optional .SC2APIProtocol.Size2DI resolution = 2;
  bool has_resolution() const;
  void clear_resolution();
  static const int kResolutionFieldNumber = 2;
  const ::SC2APIProtocol::Size2DI& resolution() const;
  ::SC2APIProtocol::Size2DI* mutable_resolution();
  ::SC2APIProtocol::Size2DI* release_resolution();
  void set_allocated_resolution(::SC2APIProtocol::Size2DI* resolution);

  // optional .SC2APIProtocol.Size2DI minimap_resolution = 3;
  bool has_minimap_resolution() const;
  void clear_minimap_resolution();
  static const int kMinimapResolutionFieldNumber = 3;
  const ::SC2APIProtocol::Size2DI& minimap_resolution() const;
  ::SC2APIProtocol::Size2DI* mutable_minimap_resolution();
  ::SC2APIProtocol::Size2DI* release_minimap_resolution();
  void set_allocated_minimap_resolution(::SC2APIProtocol::Size2DI* minimap_resolution);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.SpatialCameraSetup)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_minimap_resolution();
  inline void clear_has_minimap_resolution();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::Size2DI* resolution_;
  ::SC2APIProtocol::Size2DI* minimap_resolution_;
  float width_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static SpatialCameraSetup* default_instance_;
};
// -------------------------------------------------------------------

class InterfaceOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.InterfaceOptions) */ {
 public:
  InterfaceOptions();
  virtual ~InterfaceOptions();

  InterfaceOptions(const InterfaceOptions& from);

  inline InterfaceOptions& operator=(const InterfaceOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterfaceOptions& default_instance();

  void Swap(InterfaceOptions* other);

  // implements Message ----------------------------------------------

  inline InterfaceOptions* New() const { return New(NULL); }

  InterfaceOptions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterfaceOptions& from);
  void MergeFrom(const InterfaceOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InterfaceOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool raw = 1;
  bool has_raw() const;
  void clear_raw();
  static const int kRawFieldNumber = 1;
  bool raw() const;
  void set_raw(bool value);

  // optional bool score = 2;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  bool score() const;
  void set_score(bool value);

  // optional .SC2APIProtocol.SpatialCameraSetup feature_layer = 3;
  bool has_feature_layer() const;
  void clear_feature_layer();
  static const int kFeatureLayerFieldNumber = 3;
  const ::SC2APIProtocol::SpatialCameraSetup& feature_layer() const;
  ::SC2APIProtocol::SpatialCameraSetup* mutable_feature_layer();
  ::SC2APIProtocol::SpatialCameraSetup* release_feature_layer();
  void set_allocated_feature_layer(::SC2APIProtocol::SpatialCameraSetup* feature_layer);

  // optional .SC2APIProtocol.SpatialCameraSetup render = 4;
  bool has_render() const;
  void clear_render();
  static const int kRenderFieldNumber = 4;
  const ::SC2APIProtocol::SpatialCameraSetup& render() const;
  ::SC2APIProtocol::SpatialCameraSetup* mutable_render();
  ::SC2APIProtocol::SpatialCameraSetup* release_render();
  void set_allocated_render(::SC2APIProtocol::SpatialCameraSetup* render);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.InterfaceOptions)
 private:
  inline void set_has_raw();
  inline void clear_has_raw();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_feature_layer();
  inline void clear_has_feature_layer();
  inline void set_has_render();
  inline void clear_has_render();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::SpatialCameraSetup* feature_layer_;
  ::SC2APIProtocol::SpatialCameraSetup* render_;
  bool raw_;
  bool score_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static InterfaceOptions* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  void Swap(PlayerInfo* other);

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const { return New(NULL); }

  PlayerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.PlayerType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::SC2APIProtocol::PlayerType type() const;
  void set_type(::SC2APIProtocol::PlayerType value);

  // optional .SC2APIProtocol.Race race_requested = 3;
  bool has_race_requested() const;
  void clear_race_requested();
  static const int kRaceRequestedFieldNumber = 3;
  ::SC2APIProtocol::Race race_requested() const;
  void set_race_requested(::SC2APIProtocol::Race value);

  // optional .SC2APIProtocol.Race race_actual = 4;
  bool has_race_actual() const;
  void clear_race_actual();
  static const int kRaceActualFieldNumber = 4;
  ::SC2APIProtocol::Race race_actual() const;
  void set_race_actual(::SC2APIProtocol::Race value);

  // optional .SC2APIProtocol.Difficulty difficulty = 5;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 5;
  ::SC2APIProtocol::Difficulty difficulty() const;
  void set_difficulty(::SC2APIProtocol::Difficulty value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerInfo)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_race_requested();
  inline void clear_has_race_requested();
  inline void set_has_race_actual();
  inline void clear_has_race_actual();
  inline void set_has_difficulty();
  inline void clear_has_difficulty();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  int type_;
  int race_requested_;
  int race_actual_;
  int difficulty_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCommon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerCommon) */ {
 public:
  PlayerCommon();
  virtual ~PlayerCommon();

  PlayerCommon(const PlayerCommon& from);

  inline PlayerCommon& operator=(const PlayerCommon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCommon& default_instance();

  void Swap(PlayerCommon* other);

  // implements Message ----------------------------------------------

  inline PlayerCommon* New() const { return New(NULL); }

  PlayerCommon* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCommon& from);
  void MergeFrom(const PlayerCommon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional uint32 minerals = 2;
  bool has_minerals() const;
  void clear_minerals();
  static const int kMineralsFieldNumber = 2;
  ::google::protobuf::uint32 minerals() const;
  void set_minerals(::google::protobuf::uint32 value);

  // optional uint32 vespene = 3;
  bool has_vespene() const;
  void clear_vespene();
  static const int kVespeneFieldNumber = 3;
  ::google::protobuf::uint32 vespene() const;
  void set_vespene(::google::protobuf::uint32 value);

  // optional uint32 food_cap = 4;
  bool has_food_cap() const;
  void clear_food_cap();
  static const int kFoodCapFieldNumber = 4;
  ::google::protobuf::uint32 food_cap() const;
  void set_food_cap(::google::protobuf::uint32 value);

  // optional uint32 food_used = 5;
  bool has_food_used() const;
  void clear_food_used();
  static const int kFoodUsedFieldNumber = 5;
  ::google::protobuf::uint32 food_used() const;
  void set_food_used(::google::protobuf::uint32 value);

  // optional uint32 food_army = 6;
  bool has_food_army() const;
  void clear_food_army();
  static const int kFoodArmyFieldNumber = 6;
  ::google::protobuf::uint32 food_army() const;
  void set_food_army(::google::protobuf::uint32 value);

  // optional uint32 food_workers = 7;
  bool has_food_workers() const;
  void clear_food_workers();
  static const int kFoodWorkersFieldNumber = 7;
  ::google::protobuf::uint32 food_workers() const;
  void set_food_workers(::google::protobuf::uint32 value);

  // optional uint32 idle_worker_count = 8;
  bool has_idle_worker_count() const;
  void clear_idle_worker_count();
  static const int kIdleWorkerCountFieldNumber = 8;
  ::google::protobuf::uint32 idle_worker_count() const;
  void set_idle_worker_count(::google::protobuf::uint32 value);

  // optional uint32 army_count = 9;
  bool has_army_count() const;
  void clear_army_count();
  static const int kArmyCountFieldNumber = 9;
  ::google::protobuf::uint32 army_count() const;
  void set_army_count(::google::protobuf::uint32 value);

  // optional uint32 warp_gate_count = 10;
  bool has_warp_gate_count() const;
  void clear_warp_gate_count();
  static const int kWarpGateCountFieldNumber = 10;
  ::google::protobuf::uint32 warp_gate_count() const;
  void set_warp_gate_count(::google::protobuf::uint32 value);

  // optional uint32 larva_count = 11;
  bool has_larva_count() const;
  void clear_larva_count();
  static const int kLarvaCountFieldNumber = 11;
  ::google::protobuf::uint32 larva_count() const;
  void set_larva_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerCommon)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_minerals();
  inline void clear_has_minerals();
  inline void set_has_vespene();
  inline void clear_has_vespene();
  inline void set_has_food_cap();
  inline void clear_has_food_cap();
  inline void set_has_food_used();
  inline void clear_has_food_used();
  inline void set_has_food_army();
  inline void clear_has_food_army();
  inline void set_has_food_workers();
  inline void clear_has_food_workers();
  inline void set_has_idle_worker_count();
  inline void clear_has_idle_worker_count();
  inline void set_has_army_count();
  inline void clear_has_army_count();
  inline void set_has_warp_gate_count();
  inline void clear_has_warp_gate_count();
  inline void set_has_larva_count();
  inline void clear_has_larva_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 minerals_;
  ::google::protobuf::uint32 vespene_;
  ::google::protobuf::uint32 food_cap_;
  ::google::protobuf::uint32 food_used_;
  ::google::protobuf::uint32 food_army_;
  ::google::protobuf::uint32 food_workers_;
  ::google::protobuf::uint32 idle_worker_count_;
  ::google::protobuf::uint32 army_count_;
  ::google::protobuf::uint32 warp_gate_count_;
  ::google::protobuf::uint32 larva_count_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static PlayerCommon* default_instance_;
};
// -------------------------------------------------------------------

class Observation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Observation) */ {
 public:
  Observation();
  virtual ~Observation();

  Observation(const Observation& from);

  inline Observation& operator=(const Observation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Observation& default_instance();

  void Swap(Observation* other);

  // implements Message ----------------------------------------------

  inline Observation* New() const { return New(NULL); }

  Observation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Observation& from);
  void MergeFrom(const Observation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Observation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 game_loop = 9;
  bool has_game_loop() const;
  void clear_game_loop();
  static const int kGameLoopFieldNumber = 9;
  ::google::protobuf::uint32 game_loop() const;
  void set_game_loop(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.PlayerCommon player_common = 1;
  bool has_player_common() const;
  void clear_player_common();
  static const int kPlayerCommonFieldNumber = 1;
  const ::SC2APIProtocol::PlayerCommon& player_common() const;
  ::SC2APIProtocol::PlayerCommon* mutable_player_common();
  ::SC2APIProtocol::PlayerCommon* release_player_common();
  void set_allocated_player_common(::SC2APIProtocol::PlayerCommon* player_common);

  // repeated .SC2APIProtocol.Alert alerts = 10;
  int alerts_size() const;
  void clear_alerts();
  static const int kAlertsFieldNumber = 10;
  ::SC2APIProtocol::Alert alerts(int index) const;
  void set_alerts(int index, ::SC2APIProtocol::Alert value);
  void add_alerts(::SC2APIProtocol::Alert value);
  const ::google::protobuf::RepeatedField<int>& alerts() const;
  ::google::protobuf::RepeatedField<int>* mutable_alerts();

  // repeated .SC2APIProtocol.AvailableAbility abilities = 3;
  int abilities_size() const;
  void clear_abilities();
  static const int kAbilitiesFieldNumber = 3;
  const ::SC2APIProtocol::AvailableAbility& abilities(int index) const;
  ::SC2APIProtocol::AvailableAbility* mutable_abilities(int index);
  ::SC2APIProtocol::AvailableAbility* add_abilities();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >*
      mutable_abilities();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >&
      abilities() const;

  // optional .SC2APIProtocol.Score score = 4;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 4;
  const ::SC2APIProtocol::Score& score() const;
  ::SC2APIProtocol::Score* mutable_score();
  ::SC2APIProtocol::Score* release_score();
  void set_allocated_score(::SC2APIProtocol::Score* score);

  // optional .SC2APIProtocol.ObservationRaw raw_data = 5;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 5;
  const ::SC2APIProtocol::ObservationRaw& raw_data() const;
  ::SC2APIProtocol::ObservationRaw* mutable_raw_data();
  ::SC2APIProtocol::ObservationRaw* release_raw_data();
  void set_allocated_raw_data(::SC2APIProtocol::ObservationRaw* raw_data);

  // optional .SC2APIProtocol.ObservationFeatureLayer feature_layer_data = 6;
  bool has_feature_layer_data() const;
  void clear_feature_layer_data();
  static const int kFeatureLayerDataFieldNumber = 6;
  const ::SC2APIProtocol::ObservationFeatureLayer& feature_layer_data() const;
  ::SC2APIProtocol::ObservationFeatureLayer* mutable_feature_layer_data();
  ::SC2APIProtocol::ObservationFeatureLayer* release_feature_layer_data();
  void set_allocated_feature_layer_data(::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data);

  // optional .SC2APIProtocol.ObservationRender render_data = 7;
  bool has_render_data() const;
  void clear_render_data();
  static const int kRenderDataFieldNumber = 7;
  const ::SC2APIProtocol::ObservationRender& render_data() const;
  ::SC2APIProtocol::ObservationRender* mutable_render_data();
  ::SC2APIProtocol::ObservationRender* release_render_data();
  void set_allocated_render_data(::SC2APIProtocol::ObservationRender* render_data);

  // optional .SC2APIProtocol.ObservationUI ui_data = 8;
  bool has_ui_data() const;
  void clear_ui_data();
  static const int kUiDataFieldNumber = 8;
  const ::SC2APIProtocol::ObservationUI& ui_data() const;
  ::SC2APIProtocol::ObservationUI* mutable_ui_data();
  ::SC2APIProtocol::ObservationUI* release_ui_data();
  void set_allocated_ui_data(::SC2APIProtocol::ObservationUI* ui_data);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Observation)
 private:
  inline void set_has_game_loop();
  inline void clear_has_game_loop();
  inline void set_has_player_common();
  inline void clear_has_player_common();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_raw_data();
  inline void clear_has_raw_data();
  inline void set_has_feature_layer_data();
  inline void clear_has_feature_layer_data();
  inline void set_has_render_data();
  inline void clear_has_render_data();
  inline void set_has_ui_data();
  inline void clear_has_ui_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::PlayerCommon* player_common_;
  ::google::protobuf::RepeatedField<int> alerts_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility > abilities_;
  ::SC2APIProtocol::Score* score_;
  ::SC2APIProtocol::ObservationRaw* raw_data_;
  ::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data_;
  ::SC2APIProtocol::ObservationRender* render_data_;
  ::SC2APIProtocol::ObservationUI* ui_data_;
  ::google::protobuf::uint32 game_loop_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static Observation* default_instance_;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  void Swap(Action* other);

  // implements Message ----------------------------------------------

  inline Action* New() const { return New(NULL); }

  Action* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ActionRaw action_raw = 1;
  bool has_action_raw() const;
  void clear_action_raw();
  static const int kActionRawFieldNumber = 1;
  const ::SC2APIProtocol::ActionRaw& action_raw() const;
  ::SC2APIProtocol::ActionRaw* mutable_action_raw();
  ::SC2APIProtocol::ActionRaw* release_action_raw();
  void set_allocated_action_raw(::SC2APIProtocol::ActionRaw* action_raw);

  // optional .SC2APIProtocol.ActionSpatial action_feature_layer = 2;
  bool has_action_feature_layer() const;
  void clear_action_feature_layer();
  static const int kActionFeatureLayerFieldNumber = 2;
  const ::SC2APIProtocol::ActionSpatial& action_feature_layer() const;
  ::SC2APIProtocol::ActionSpatial* mutable_action_feature_layer();
  ::SC2APIProtocol::ActionSpatial* release_action_feature_layer();
  void set_allocated_action_feature_layer(::SC2APIProtocol::ActionSpatial* action_feature_layer);

  // optional .SC2APIProtocol.ActionSpatial action_render = 3;
  bool has_action_render() const;
  void clear_action_render();
  static const int kActionRenderFieldNumber = 3;
  const ::SC2APIProtocol::ActionSpatial& action_render() const;
  ::SC2APIProtocol::ActionSpatial* mutable_action_render();
  ::SC2APIProtocol::ActionSpatial* release_action_render();
  void set_allocated_action_render(::SC2APIProtocol::ActionSpatial* action_render);

  // optional .SC2APIProtocol.ActionUI action_ui = 4;
  bool has_action_ui() const;
  void clear_action_ui();
  static const int kActionUiFieldNumber = 4;
  const ::SC2APIProtocol::ActionUI& action_ui() const;
  ::SC2APIProtocol::ActionUI* mutable_action_ui();
  ::SC2APIProtocol::ActionUI* release_action_ui();
  void set_allocated_action_ui(::SC2APIProtocol::ActionUI* action_ui);

  // repeated .SC2APIProtocol.ActionChat chat = 5;
  int chat_size() const;
  void clear_chat();
  static const int kChatFieldNumber = 5;
  const ::SC2APIProtocol::ActionChat& chat(int index) const;
  ::SC2APIProtocol::ActionChat* mutable_chat(int index);
  ::SC2APIProtocol::ActionChat* add_chat();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionChat >*
      mutable_chat();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionChat >&
      chat() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Action)
 private:
  inline void set_has_action_raw();
  inline void clear_has_action_raw();
  inline void set_has_action_feature_layer();
  inline void clear_has_action_feature_layer();
  inline void set_has_action_render();
  inline void clear_has_action_render();
  inline void set_has_action_ui();
  inline void clear_has_action_ui();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::ActionRaw* action_raw_;
  ::SC2APIProtocol::ActionSpatial* action_feature_layer_;
  ::SC2APIProtocol::ActionSpatial* action_render_;
  ::SC2APIProtocol::ActionUI* action_ui_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionChat > chat_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static Action* default_instance_;
};
// -------------------------------------------------------------------

class ActionChat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionChat) */ {
 public:
  ActionChat();
  virtual ~ActionChat();

  ActionChat(const ActionChat& from);

  inline ActionChat& operator=(const ActionChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionChat& default_instance();

  void Swap(ActionChat* other);

  // implements Message ----------------------------------------------

  inline ActionChat* New() const { return New(NULL); }

  ActionChat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionChat& from);
  void MergeFrom(const ActionChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionChat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ActionChat_Channel Channel;
  static const Channel Broadcast =
    ActionChat_Channel_Broadcast;
  static const Channel Team =
    ActionChat_Channel_Team;
  static inline bool Channel_IsValid(int value) {
    return ActionChat_Channel_IsValid(value);
  }
  static const Channel Channel_MIN =
    ActionChat_Channel_Channel_MIN;
  static const Channel Channel_MAX =
    ActionChat_Channel_Channel_MAX;
  static const int Channel_ARRAYSIZE =
    ActionChat_Channel_Channel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Channel_descriptor() {
    return ActionChat_Channel_descriptor();
  }
  static inline const ::std::string& Channel_Name(Channel value) {
    return ActionChat_Channel_Name(value);
  }
  static inline bool Channel_Parse(const ::std::string& name,
      Channel* value) {
    return ActionChat_Channel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ActionChat.Channel channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::SC2APIProtocol::ActionChat_Channel channel() const;
  void set_channel(::SC2APIProtocol::ActionChat_Channel value);

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionChat)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int channel_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ActionChat* default_instance_;
};
// -------------------------------------------------------------------

class ActionError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionError) */ {
 public:
  ActionError();
  virtual ~ActionError();

  ActionError(const ActionError& from);

  inline ActionError& operator=(const ActionError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionError& default_instance();

  void Swap(ActionError* other);

  // implements Message ----------------------------------------------

  inline ActionError* New() const { return New(NULL); }

  ActionError* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionError& from);
  void MergeFrom(const ActionError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 unit_tag = 1;
  bool has_unit_tag() const;
  void clear_unit_tag();
  static const int kUnitTagFieldNumber = 1;
  ::google::protobuf::uint64 unit_tag() const;
  void set_unit_tag(::google::protobuf::uint64 value);

  // optional uint64 ability_id = 2;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 2;
  ::google::protobuf::uint64 ability_id() const;
  void set_ability_id(::google::protobuf::uint64 value);

  // optional .SC2APIProtocol.ActionResult result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  ::SC2APIProtocol::ActionResult result() const;
  void set_result(::SC2APIProtocol::ActionResult value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionError)
 private:
  inline void set_has_unit_tag();
  inline void clear_has_unit_tag();
  inline void set_has_ability_id();
  inline void clear_has_ability_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 unit_tag_;
  ::google::protobuf::uint64 ability_id_;
  int result_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static ActionError* default_instance_;
};
// -------------------------------------------------------------------

class PlayerResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerResult) */ {
 public:
  PlayerResult();
  virtual ~PlayerResult();

  PlayerResult(const PlayerResult& from);

  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerResult& default_instance();

  void Swap(PlayerResult* other);

  // implements Message ----------------------------------------------

  inline PlayerResult* New() const { return New(NULL); }

  PlayerResult* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.Result result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::SC2APIProtocol::Result result() const;
  void set_result(::SC2APIProtocol::Result value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerResult)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 player_id_;
  int result_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fsc2api_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fsc2api_2eproto();

  void InitAsDefaultInstance();
  static PlayerResult* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Request

// optional .SC2APIProtocol.RequestCreateGame create_game = 1;
inline bool Request::has_create_game() const {
  return request_case() == kCreateGame;
}
inline void Request::set_has_create_game() {
  _oneof_case_[0] = kCreateGame;
}
inline void Request::clear_create_game() {
  if (has_create_game()) {
    delete request_.create_game_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestCreateGame& Request::create_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.create_game)
  return has_create_game()
      ? *request_.create_game_
      : ::SC2APIProtocol::RequestCreateGame::default_instance();
}
inline ::SC2APIProtocol::RequestCreateGame* Request::mutable_create_game() {
  if (!has_create_game()) {
    clear_request();
    set_has_create_game();
    request_.create_game_ = new ::SC2APIProtocol::RequestCreateGame;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.create_game)
  return request_.create_game_;
}
inline ::SC2APIProtocol::RequestCreateGame* Request::release_create_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.create_game)
  if (has_create_game()) {
    clear_has_request();
    ::SC2APIProtocol::RequestCreateGame* temp = request_.create_game_;
    request_.create_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_create_game(::SC2APIProtocol::RequestCreateGame* create_game) {
  clear_request();
  if (create_game) {
    set_has_create_game();
    request_.create_game_ = create_game;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.create_game)
}

// optional .SC2APIProtocol.RequestJoinGame join_game = 2;
inline bool Request::has_join_game() const {
  return request_case() == kJoinGame;
}
inline void Request::set_has_join_game() {
  _oneof_case_[0] = kJoinGame;
}
inline void Request::clear_join_game() {
  if (has_join_game()) {
    delete request_.join_game_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestJoinGame& Request::join_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.join_game)
  return has_join_game()
      ? *request_.join_game_
      : ::SC2APIProtocol::RequestJoinGame::default_instance();
}
inline ::SC2APIProtocol::RequestJoinGame* Request::mutable_join_game() {
  if (!has_join_game()) {
    clear_request();
    set_has_join_game();
    request_.join_game_ = new ::SC2APIProtocol::RequestJoinGame;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.join_game)
  return request_.join_game_;
}
inline ::SC2APIProtocol::RequestJoinGame* Request::release_join_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.join_game)
  if (has_join_game()) {
    clear_has_request();
    ::SC2APIProtocol::RequestJoinGame* temp = request_.join_game_;
    request_.join_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_join_game(::SC2APIProtocol::RequestJoinGame* join_game) {
  clear_request();
  if (join_game) {
    set_has_join_game();
    request_.join_game_ = join_game;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.join_game)
}

// optional .SC2APIProtocol.RequestRestartGame restart_game = 3;
inline bool Request::has_restart_game() const {
  return request_case() == kRestartGame;
}
inline void Request::set_has_restart_game() {
  _oneof_case_[0] = kRestartGame;
}
inline void Request::clear_restart_game() {
  if (has_restart_game()) {
    delete request_.restart_game_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestRestartGame& Request::restart_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.restart_game)
  return has_restart_game()
      ? *request_.restart_game_
      : ::SC2APIProtocol::RequestRestartGame::default_instance();
}
inline ::SC2APIProtocol::RequestRestartGame* Request::mutable_restart_game() {
  if (!has_restart_game()) {
    clear_request();
    set_has_restart_game();
    request_.restart_game_ = new ::SC2APIProtocol::RequestRestartGame;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.restart_game)
  return request_.restart_game_;
}
inline ::SC2APIProtocol::RequestRestartGame* Request::release_restart_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.restart_game)
  if (has_restart_game()) {
    clear_has_request();
    ::SC2APIProtocol::RequestRestartGame* temp = request_.restart_game_;
    request_.restart_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_restart_game(::SC2APIProtocol::RequestRestartGame* restart_game) {
  clear_request();
  if (restart_game) {
    set_has_restart_game();
    request_.restart_game_ = restart_game;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.restart_game)
}

// optional .SC2APIProtocol.RequestStartReplay start_replay = 4;
inline bool Request::has_start_replay() const {
  return request_case() == kStartReplay;
}
inline void Request::set_has_start_replay() {
  _oneof_case_[0] = kStartReplay;
}
inline void Request::clear_start_replay() {
  if (has_start_replay()) {
    delete request_.start_replay_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestStartReplay& Request::start_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.start_replay)
  return has_start_replay()
      ? *request_.start_replay_
      : ::SC2APIProtocol::RequestStartReplay::default_instance();
}
inline ::SC2APIProtocol::RequestStartReplay* Request::mutable_start_replay() {
  if (!has_start_replay()) {
    clear_request();
    set_has_start_replay();
    request_.start_replay_ = new ::SC2APIProtocol::RequestStartReplay;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.start_replay)
  return request_.start_replay_;
}
inline ::SC2APIProtocol::RequestStartReplay* Request::release_start_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.start_replay)
  if (has_start_replay()) {
    clear_has_request();
    ::SC2APIProtocol::RequestStartReplay* temp = request_.start_replay_;
    request_.start_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_start_replay(::SC2APIProtocol::RequestStartReplay* start_replay) {
  clear_request();
  if (start_replay) {
    set_has_start_replay();
    request_.start_replay_ = start_replay;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.start_replay)
}

// optional .SC2APIProtocol.RequestLeaveGame leave_game = 5;
inline bool Request::has_leave_game() const {
  return request_case() == kLeaveGame;
}
inline void Request::set_has_leave_game() {
  _oneof_case_[0] = kLeaveGame;
}
inline void Request::clear_leave_game() {
  if (has_leave_game()) {
    delete request_.leave_game_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestLeaveGame& Request::leave_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.leave_game)
  return has_leave_game()
      ? *request_.leave_game_
      : ::SC2APIProtocol::RequestLeaveGame::default_instance();
}
inline ::SC2APIProtocol::RequestLeaveGame* Request::mutable_leave_game() {
  if (!has_leave_game()) {
    clear_request();
    set_has_leave_game();
    request_.leave_game_ = new ::SC2APIProtocol::RequestLeaveGame;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.leave_game)
  return request_.leave_game_;
}
inline ::SC2APIProtocol::RequestLeaveGame* Request::release_leave_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.leave_game)
  if (has_leave_game()) {
    clear_has_request();
    ::SC2APIProtocol::RequestLeaveGame* temp = request_.leave_game_;
    request_.leave_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_leave_game(::SC2APIProtocol::RequestLeaveGame* leave_game) {
  clear_request();
  if (leave_game) {
    set_has_leave_game();
    request_.leave_game_ = leave_game;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.leave_game)
}

// optional .SC2APIProtocol.RequestQuickSave quick_save = 6;
inline bool Request::has_quick_save() const {
  return request_case() == kQuickSave;
}
inline void Request::set_has_quick_save() {
  _oneof_case_[0] = kQuickSave;
}
inline void Request::clear_quick_save() {
  if (has_quick_save()) {
    delete request_.quick_save_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestQuickSave& Request::quick_save() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quick_save)
  return has_quick_save()
      ? *request_.quick_save_
      : ::SC2APIProtocol::RequestQuickSave::default_instance();
}
inline ::SC2APIProtocol::RequestQuickSave* Request::mutable_quick_save() {
  if (!has_quick_save()) {
    clear_request();
    set_has_quick_save();
    request_.quick_save_ = new ::SC2APIProtocol::RequestQuickSave;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quick_save)
  return request_.quick_save_;
}
inline ::SC2APIProtocol::RequestQuickSave* Request::release_quick_save() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quick_save)
  if (has_quick_save()) {
    clear_has_request();
    ::SC2APIProtocol::RequestQuickSave* temp = request_.quick_save_;
    request_.quick_save_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_quick_save(::SC2APIProtocol::RequestQuickSave* quick_save) {
  clear_request();
  if (quick_save) {
    set_has_quick_save();
    request_.quick_save_ = quick_save;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.quick_save)
}

// optional .SC2APIProtocol.RequestQuickLoad quick_load = 7;
inline bool Request::has_quick_load() const {
  return request_case() == kQuickLoad;
}
inline void Request::set_has_quick_load() {
  _oneof_case_[0] = kQuickLoad;
}
inline void Request::clear_quick_load() {
  if (has_quick_load()) {
    delete request_.quick_load_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestQuickLoad& Request::quick_load() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quick_load)
  return has_quick_load()
      ? *request_.quick_load_
      : ::SC2APIProtocol::RequestQuickLoad::default_instance();
}
inline ::SC2APIProtocol::RequestQuickLoad* Request::mutable_quick_load() {
  if (!has_quick_load()) {
    clear_request();
    set_has_quick_load();
    request_.quick_load_ = new ::SC2APIProtocol::RequestQuickLoad;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quick_load)
  return request_.quick_load_;
}
inline ::SC2APIProtocol::RequestQuickLoad* Request::release_quick_load() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quick_load)
  if (has_quick_load()) {
    clear_has_request();
    ::SC2APIProtocol::RequestQuickLoad* temp = request_.quick_load_;
    request_.quick_load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_quick_load(::SC2APIProtocol::RequestQuickLoad* quick_load) {
  clear_request();
  if (quick_load) {
    set_has_quick_load();
    request_.quick_load_ = quick_load;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.quick_load)
}

// optional .SC2APIProtocol.RequestQuit quit = 8;
inline bool Request::has_quit() const {
  return request_case() == kQuit;
}
inline void Request::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Request::clear_quit() {
  if (has_quit()) {
    delete request_.quit_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestQuit& Request::quit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quit)
  return has_quit()
      ? *request_.quit_
      : ::SC2APIProtocol::RequestQuit::default_instance();
}
inline ::SC2APIProtocol::RequestQuit* Request::mutable_quit() {
  if (!has_quit()) {
    clear_request();
    set_has_quit();
    request_.quit_ = new ::SC2APIProtocol::RequestQuit;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quit)
  return request_.quit_;
}
inline ::SC2APIProtocol::RequestQuit* Request::release_quit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quit)
  if (has_quit()) {
    clear_has_request();
    ::SC2APIProtocol::RequestQuit* temp = request_.quit_;
    request_.quit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_quit(::SC2APIProtocol::RequestQuit* quit) {
  clear_request();
  if (quit) {
    set_has_quit();
    request_.quit_ = quit;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.quit)
}

// optional .SC2APIProtocol.RequestGameInfo game_info = 9;
inline bool Request::has_game_info() const {
  return request_case() == kGameInfo;
}
inline void Request::set_has_game_info() {
  _oneof_case_[0] = kGameInfo;
}
inline void Request::clear_game_info() {
  if (has_game_info()) {
    delete request_.game_info_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestGameInfo& Request::game_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.game_info)
  return has_game_info()
      ? *request_.game_info_
      : ::SC2APIProtocol::RequestGameInfo::default_instance();
}
inline ::SC2APIProtocol::RequestGameInfo* Request::mutable_game_info() {
  if (!has_game_info()) {
    clear_request();
    set_has_game_info();
    request_.game_info_ = new ::SC2APIProtocol::RequestGameInfo;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.game_info)
  return request_.game_info_;
}
inline ::SC2APIProtocol::RequestGameInfo* Request::release_game_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.game_info)
  if (has_game_info()) {
    clear_has_request();
    ::SC2APIProtocol::RequestGameInfo* temp = request_.game_info_;
    request_.game_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_game_info(::SC2APIProtocol::RequestGameInfo* game_info) {
  clear_request();
  if (game_info) {
    set_has_game_info();
    request_.game_info_ = game_info;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.game_info)
}

// optional .SC2APIProtocol.RequestObservation observation = 10;
inline bool Request::has_observation() const {
  return request_case() == kObservation;
}
inline void Request::set_has_observation() {
  _oneof_case_[0] = kObservation;
}
inline void Request::clear_observation() {
  if (has_observation()) {
    delete request_.observation_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestObservation& Request::observation() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.observation)
  return has_observation()
      ? *request_.observation_
      : ::SC2APIProtocol::RequestObservation::default_instance();
}
inline ::SC2APIProtocol::RequestObservation* Request::mutable_observation() {
  if (!has_observation()) {
    clear_request();
    set_has_observation();
    request_.observation_ = new ::SC2APIProtocol::RequestObservation;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.observation)
  return request_.observation_;
}
inline ::SC2APIProtocol::RequestObservation* Request::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.observation)
  if (has_observation()) {
    clear_has_request();
    ::SC2APIProtocol::RequestObservation* temp = request_.observation_;
    request_.observation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_observation(::SC2APIProtocol::RequestObservation* observation) {
  clear_request();
  if (observation) {
    set_has_observation();
    request_.observation_ = observation;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.observation)
}

// optional .SC2APIProtocol.RequestAction action = 11;
inline bool Request::has_action() const {
  return request_case() == kAction;
}
inline void Request::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Request::clear_action() {
  if (has_action()) {
    delete request_.action_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestAction& Request::action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.action)
  return has_action()
      ? *request_.action_
      : ::SC2APIProtocol::RequestAction::default_instance();
}
inline ::SC2APIProtocol::RequestAction* Request::mutable_action() {
  if (!has_action()) {
    clear_request();
    set_has_action();
    request_.action_ = new ::SC2APIProtocol::RequestAction;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.action)
  return request_.action_;
}
inline ::SC2APIProtocol::RequestAction* Request::release_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.action)
  if (has_action()) {
    clear_has_request();
    ::SC2APIProtocol::RequestAction* temp = request_.action_;
    request_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_action(::SC2APIProtocol::RequestAction* action) {
  clear_request();
  if (action) {
    set_has_action();
    request_.action_ = action;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.action)
}

// optional .SC2APIProtocol.RequestStep step = 12;
inline bool Request::has_step() const {
  return request_case() == kStep;
}
inline void Request::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Request::clear_step() {
  if (has_step()) {
    delete request_.step_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestStep& Request::step() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.step)
  return has_step()
      ? *request_.step_
      : ::SC2APIProtocol::RequestStep::default_instance();
}
inline ::SC2APIProtocol::RequestStep* Request::mutable_step() {
  if (!has_step()) {
    clear_request();
    set_has_step();
    request_.step_ = new ::SC2APIProtocol::RequestStep;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.step)
  return request_.step_;
}
inline ::SC2APIProtocol::RequestStep* Request::release_step() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.step)
  if (has_step()) {
    clear_has_request();
    ::SC2APIProtocol::RequestStep* temp = request_.step_;
    request_.step_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_step(::SC2APIProtocol::RequestStep* step) {
  clear_request();
  if (step) {
    set_has_step();
    request_.step_ = step;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.step)
}

// optional .SC2APIProtocol.RequestData data = 13;
inline bool Request::has_data() const {
  return request_case() == kData;
}
inline void Request::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Request::clear_data() {
  if (has_data()) {
    delete request_.data_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestData& Request::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.data)
  return has_data()
      ? *request_.data_
      : ::SC2APIProtocol::RequestData::default_instance();
}
inline ::SC2APIProtocol::RequestData* Request::mutable_data() {
  if (!has_data()) {
    clear_request();
    set_has_data();
    request_.data_ = new ::SC2APIProtocol::RequestData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.data)
  return request_.data_;
}
inline ::SC2APIProtocol::RequestData* Request::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.data)
  if (has_data()) {
    clear_has_request();
    ::SC2APIProtocol::RequestData* temp = request_.data_;
    request_.data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_data(::SC2APIProtocol::RequestData* data) {
  clear_request();
  if (data) {
    set_has_data();
    request_.data_ = data;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.data)
}

// optional .SC2APIProtocol.RequestQuery query = 14;
inline bool Request::has_query() const {
  return request_case() == kQuery;
}
inline void Request::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Request::clear_query() {
  if (has_query()) {
    delete request_.query_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.query)
  return has_query()
      ? *request_.query_
      : ::SC2APIProtocol::RequestQuery::default_instance();
}
inline ::SC2APIProtocol::RequestQuery* Request::mutable_query() {
  if (!has_query()) {
    clear_request();
    set_has_query();
    request_.query_ = new ::SC2APIProtocol::RequestQuery;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.query)
  return request_.query_;
}
inline ::SC2APIProtocol::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.query)
  if (has_query()) {
    clear_has_request();
    ::SC2APIProtocol::RequestQuery* temp = request_.query_;
    request_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_query(::SC2APIProtocol::RequestQuery* query) {
  clear_request();
  if (query) {
    set_has_query();
    request_.query_ = query;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.query)
}

// optional .SC2APIProtocol.RequestSaveReplay save_replay = 15;
inline bool Request::has_save_replay() const {
  return request_case() == kSaveReplay;
}
inline void Request::set_has_save_replay() {
  _oneof_case_[0] = kSaveReplay;
}
inline void Request::clear_save_replay() {
  if (has_save_replay()) {
    delete request_.save_replay_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestSaveReplay& Request::save_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.save_replay)
  return has_save_replay()
      ? *request_.save_replay_
      : ::SC2APIProtocol::RequestSaveReplay::default_instance();
}
inline ::SC2APIProtocol::RequestSaveReplay* Request::mutable_save_replay() {
  if (!has_save_replay()) {
    clear_request();
    set_has_save_replay();
    request_.save_replay_ = new ::SC2APIProtocol::RequestSaveReplay;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.save_replay)
  return request_.save_replay_;
}
inline ::SC2APIProtocol::RequestSaveReplay* Request::release_save_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.save_replay)
  if (has_save_replay()) {
    clear_has_request();
    ::SC2APIProtocol::RequestSaveReplay* temp = request_.save_replay_;
    request_.save_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_save_replay(::SC2APIProtocol::RequestSaveReplay* save_replay) {
  clear_request();
  if (save_replay) {
    set_has_save_replay();
    request_.save_replay_ = save_replay;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.save_replay)
}

// optional .SC2APIProtocol.RequestReplayInfo replay_info = 16;
inline bool Request::has_replay_info() const {
  return request_case() == kReplayInfo;
}
inline void Request::set_has_replay_info() {
  _oneof_case_[0] = kReplayInfo;
}
inline void Request::clear_replay_info() {
  if (has_replay_info()) {
    delete request_.replay_info_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestReplayInfo& Request::replay_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.replay_info)
  return has_replay_info()
      ? *request_.replay_info_
      : ::SC2APIProtocol::RequestReplayInfo::default_instance();
}
inline ::SC2APIProtocol::RequestReplayInfo* Request::mutable_replay_info() {
  if (!has_replay_info()) {
    clear_request();
    set_has_replay_info();
    request_.replay_info_ = new ::SC2APIProtocol::RequestReplayInfo;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.replay_info)
  return request_.replay_info_;
}
inline ::SC2APIProtocol::RequestReplayInfo* Request::release_replay_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.replay_info)
  if (has_replay_info()) {
    clear_has_request();
    ::SC2APIProtocol::RequestReplayInfo* temp = request_.replay_info_;
    request_.replay_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_replay_info(::SC2APIProtocol::RequestReplayInfo* replay_info) {
  clear_request();
  if (replay_info) {
    set_has_replay_info();
    request_.replay_info_ = replay_info;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.replay_info)
}

// optional .SC2APIProtocol.RequestAvailableMaps available_maps = 17;
inline bool Request::has_available_maps() const {
  return request_case() == kAvailableMaps;
}
inline void Request::set_has_available_maps() {
  _oneof_case_[0] = kAvailableMaps;
}
inline void Request::clear_available_maps() {
  if (has_available_maps()) {
    delete request_.available_maps_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestAvailableMaps& Request::available_maps() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.available_maps)
  return has_available_maps()
      ? *request_.available_maps_
      : ::SC2APIProtocol::RequestAvailableMaps::default_instance();
}
inline ::SC2APIProtocol::RequestAvailableMaps* Request::mutable_available_maps() {
  if (!has_available_maps()) {
    clear_request();
    set_has_available_maps();
    request_.available_maps_ = new ::SC2APIProtocol::RequestAvailableMaps;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.available_maps)
  return request_.available_maps_;
}
inline ::SC2APIProtocol::RequestAvailableMaps* Request::release_available_maps() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.available_maps)
  if (has_available_maps()) {
    clear_has_request();
    ::SC2APIProtocol::RequestAvailableMaps* temp = request_.available_maps_;
    request_.available_maps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_available_maps(::SC2APIProtocol::RequestAvailableMaps* available_maps) {
  clear_request();
  if (available_maps) {
    set_has_available_maps();
    request_.available_maps_ = available_maps;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.available_maps)
}

// optional .SC2APIProtocol.RequestSaveMap save_map = 18;
inline bool Request::has_save_map() const {
  return request_case() == kSaveMap;
}
inline void Request::set_has_save_map() {
  _oneof_case_[0] = kSaveMap;
}
inline void Request::clear_save_map() {
  if (has_save_map()) {
    delete request_.save_map_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestSaveMap& Request::save_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.save_map)
  return has_save_map()
      ? *request_.save_map_
      : ::SC2APIProtocol::RequestSaveMap::default_instance();
}
inline ::SC2APIProtocol::RequestSaveMap* Request::mutable_save_map() {
  if (!has_save_map()) {
    clear_request();
    set_has_save_map();
    request_.save_map_ = new ::SC2APIProtocol::RequestSaveMap;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.save_map)
  return request_.save_map_;
}
inline ::SC2APIProtocol::RequestSaveMap* Request::release_save_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.save_map)
  if (has_save_map()) {
    clear_has_request();
    ::SC2APIProtocol::RequestSaveMap* temp = request_.save_map_;
    request_.save_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_save_map(::SC2APIProtocol::RequestSaveMap* save_map) {
  clear_request();
  if (save_map) {
    set_has_save_map();
    request_.save_map_ = save_map;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.save_map)
}

// optional .SC2APIProtocol.RequestPing ping = 19;
inline bool Request::has_ping() const {
  return request_case() == kPing;
}
inline void Request::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Request::clear_ping() {
  if (has_ping()) {
    delete request_.ping_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestPing& Request::ping() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.ping)
  return has_ping()
      ? *request_.ping_
      : ::SC2APIProtocol::RequestPing::default_instance();
}
inline ::SC2APIProtocol::RequestPing* Request::mutable_ping() {
  if (!has_ping()) {
    clear_request();
    set_has_ping();
    request_.ping_ = new ::SC2APIProtocol::RequestPing;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.ping)
  return request_.ping_;
}
inline ::SC2APIProtocol::RequestPing* Request::release_ping() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.ping)
  if (has_ping()) {
    clear_has_request();
    ::SC2APIProtocol::RequestPing* temp = request_.ping_;
    request_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_ping(::SC2APIProtocol::RequestPing* ping) {
  clear_request();
  if (ping) {
    set_has_ping();
    request_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.ping)
}

// optional .SC2APIProtocol.RequestDebug debug = 20;
inline bool Request::has_debug() const {
  return request_case() == kDebug;
}
inline void Request::set_has_debug() {
  _oneof_case_[0] = kDebug;
}
inline void Request::clear_debug() {
  if (has_debug()) {
    delete request_.debug_;
    clear_has_request();
  }
}
inline  const ::SC2APIProtocol::RequestDebug& Request::debug() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.debug)
  return has_debug()
      ? *request_.debug_
      : ::SC2APIProtocol::RequestDebug::default_instance();
}
inline ::SC2APIProtocol::RequestDebug* Request::mutable_debug() {
  if (!has_debug()) {
    clear_request();
    set_has_debug();
    request_.debug_ = new ::SC2APIProtocol::RequestDebug;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.debug)
  return request_.debug_;
}
inline ::SC2APIProtocol::RequestDebug* Request::release_debug() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.debug)
  if (has_debug()) {
    clear_has_request();
    ::SC2APIProtocol::RequestDebug* temp = request_.debug_;
    request_.debug_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_debug(::SC2APIProtocol::RequestDebug* debug) {
  clear_request();
  if (debug) {
    set_has_debug();
    request_.debug_ = debug;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Request.debug)
}

inline bool Request::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void Request::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline Request::RequestCase Request::request_case() const {
  return Request::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// optional .SC2APIProtocol.ResponseCreateGame create_game = 1;
inline bool Response::has_create_game() const {
  return response_case() == kCreateGame;
}
inline void Response::set_has_create_game() {
  _oneof_case_[0] = kCreateGame;
}
inline void Response::clear_create_game() {
  if (has_create_game()) {
    delete response_.create_game_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseCreateGame& Response::create_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.create_game)
  return has_create_game()
      ? *response_.create_game_
      : ::SC2APIProtocol::ResponseCreateGame::default_instance();
}
inline ::SC2APIProtocol::ResponseCreateGame* Response::mutable_create_game() {
  if (!has_create_game()) {
    clear_response();
    set_has_create_game();
    response_.create_game_ = new ::SC2APIProtocol::ResponseCreateGame;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.create_game)
  return response_.create_game_;
}
inline ::SC2APIProtocol::ResponseCreateGame* Response::release_create_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.create_game)
  if (has_create_game()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseCreateGame* temp = response_.create_game_;
    response_.create_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_create_game(::SC2APIProtocol::ResponseCreateGame* create_game) {
  clear_response();
  if (create_game) {
    set_has_create_game();
    response_.create_game_ = create_game;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.create_game)
}

// optional .SC2APIProtocol.ResponseJoinGame join_game = 2;
inline bool Response::has_join_game() const {
  return response_case() == kJoinGame;
}
inline void Response::set_has_join_game() {
  _oneof_case_[0] = kJoinGame;
}
inline void Response::clear_join_game() {
  if (has_join_game()) {
    delete response_.join_game_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseJoinGame& Response::join_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.join_game)
  return has_join_game()
      ? *response_.join_game_
      : ::SC2APIProtocol::ResponseJoinGame::default_instance();
}
inline ::SC2APIProtocol::ResponseJoinGame* Response::mutable_join_game() {
  if (!has_join_game()) {
    clear_response();
    set_has_join_game();
    response_.join_game_ = new ::SC2APIProtocol::ResponseJoinGame;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.join_game)
  return response_.join_game_;
}
inline ::SC2APIProtocol::ResponseJoinGame* Response::release_join_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.join_game)
  if (has_join_game()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseJoinGame* temp = response_.join_game_;
    response_.join_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_join_game(::SC2APIProtocol::ResponseJoinGame* join_game) {
  clear_response();
  if (join_game) {
    set_has_join_game();
    response_.join_game_ = join_game;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.join_game)
}

// optional .SC2APIProtocol.ResponseRestartGame restart_game = 3;
inline bool Response::has_restart_game() const {
  return response_case() == kRestartGame;
}
inline void Response::set_has_restart_game() {
  _oneof_case_[0] = kRestartGame;
}
inline void Response::clear_restart_game() {
  if (has_restart_game()) {
    delete response_.restart_game_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseRestartGame& Response::restart_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.restart_game)
  return has_restart_game()
      ? *response_.restart_game_
      : ::SC2APIProtocol::ResponseRestartGame::default_instance();
}
inline ::SC2APIProtocol::ResponseRestartGame* Response::mutable_restart_game() {
  if (!has_restart_game()) {
    clear_response();
    set_has_restart_game();
    response_.restart_game_ = new ::SC2APIProtocol::ResponseRestartGame;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.restart_game)
  return response_.restart_game_;
}
inline ::SC2APIProtocol::ResponseRestartGame* Response::release_restart_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.restart_game)
  if (has_restart_game()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseRestartGame* temp = response_.restart_game_;
    response_.restart_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_restart_game(::SC2APIProtocol::ResponseRestartGame* restart_game) {
  clear_response();
  if (restart_game) {
    set_has_restart_game();
    response_.restart_game_ = restart_game;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.restart_game)
}

// optional .SC2APIProtocol.ResponseStartReplay start_replay = 4;
inline bool Response::has_start_replay() const {
  return response_case() == kStartReplay;
}
inline void Response::set_has_start_replay() {
  _oneof_case_[0] = kStartReplay;
}
inline void Response::clear_start_replay() {
  if (has_start_replay()) {
    delete response_.start_replay_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseStartReplay& Response::start_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.start_replay)
  return has_start_replay()
      ? *response_.start_replay_
      : ::SC2APIProtocol::ResponseStartReplay::default_instance();
}
inline ::SC2APIProtocol::ResponseStartReplay* Response::mutable_start_replay() {
  if (!has_start_replay()) {
    clear_response();
    set_has_start_replay();
    response_.start_replay_ = new ::SC2APIProtocol::ResponseStartReplay;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.start_replay)
  return response_.start_replay_;
}
inline ::SC2APIProtocol::ResponseStartReplay* Response::release_start_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.start_replay)
  if (has_start_replay()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseStartReplay* temp = response_.start_replay_;
    response_.start_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_start_replay(::SC2APIProtocol::ResponseStartReplay* start_replay) {
  clear_response();
  if (start_replay) {
    set_has_start_replay();
    response_.start_replay_ = start_replay;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.start_replay)
}

// optional .SC2APIProtocol.ResponseLeaveGame leave_game = 5;
inline bool Response::has_leave_game() const {
  return response_case() == kLeaveGame;
}
inline void Response::set_has_leave_game() {
  _oneof_case_[0] = kLeaveGame;
}
inline void Response::clear_leave_game() {
  if (has_leave_game()) {
    delete response_.leave_game_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseLeaveGame& Response::leave_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.leave_game)
  return has_leave_game()
      ? *response_.leave_game_
      : ::SC2APIProtocol::ResponseLeaveGame::default_instance();
}
inline ::SC2APIProtocol::ResponseLeaveGame* Response::mutable_leave_game() {
  if (!has_leave_game()) {
    clear_response();
    set_has_leave_game();
    response_.leave_game_ = new ::SC2APIProtocol::ResponseLeaveGame;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.leave_game)
  return response_.leave_game_;
}
inline ::SC2APIProtocol::ResponseLeaveGame* Response::release_leave_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.leave_game)
  if (has_leave_game()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseLeaveGame* temp = response_.leave_game_;
    response_.leave_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_leave_game(::SC2APIProtocol::ResponseLeaveGame* leave_game) {
  clear_response();
  if (leave_game) {
    set_has_leave_game();
    response_.leave_game_ = leave_game;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.leave_game)
}

// optional .SC2APIProtocol.ResponseQuickSave quick_save = 6;
inline bool Response::has_quick_save() const {
  return response_case() == kQuickSave;
}
inline void Response::set_has_quick_save() {
  _oneof_case_[0] = kQuickSave;
}
inline void Response::clear_quick_save() {
  if (has_quick_save()) {
    delete response_.quick_save_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseQuickSave& Response::quick_save() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quick_save)
  return has_quick_save()
      ? *response_.quick_save_
      : ::SC2APIProtocol::ResponseQuickSave::default_instance();
}
inline ::SC2APIProtocol::ResponseQuickSave* Response::mutable_quick_save() {
  if (!has_quick_save()) {
    clear_response();
    set_has_quick_save();
    response_.quick_save_ = new ::SC2APIProtocol::ResponseQuickSave;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quick_save)
  return response_.quick_save_;
}
inline ::SC2APIProtocol::ResponseQuickSave* Response::release_quick_save() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quick_save)
  if (has_quick_save()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseQuickSave* temp = response_.quick_save_;
    response_.quick_save_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_quick_save(::SC2APIProtocol::ResponseQuickSave* quick_save) {
  clear_response();
  if (quick_save) {
    set_has_quick_save();
    response_.quick_save_ = quick_save;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.quick_save)
}

// optional .SC2APIProtocol.ResponseQuickLoad quick_load = 7;
inline bool Response::has_quick_load() const {
  return response_case() == kQuickLoad;
}
inline void Response::set_has_quick_load() {
  _oneof_case_[0] = kQuickLoad;
}
inline void Response::clear_quick_load() {
  if (has_quick_load()) {
    delete response_.quick_load_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseQuickLoad& Response::quick_load() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quick_load)
  return has_quick_load()
      ? *response_.quick_load_
      : ::SC2APIProtocol::ResponseQuickLoad::default_instance();
}
inline ::SC2APIProtocol::ResponseQuickLoad* Response::mutable_quick_load() {
  if (!has_quick_load()) {
    clear_response();
    set_has_quick_load();
    response_.quick_load_ = new ::SC2APIProtocol::ResponseQuickLoad;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quick_load)
  return response_.quick_load_;
}
inline ::SC2APIProtocol::ResponseQuickLoad* Response::release_quick_load() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quick_load)
  if (has_quick_load()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseQuickLoad* temp = response_.quick_load_;
    response_.quick_load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_quick_load(::SC2APIProtocol::ResponseQuickLoad* quick_load) {
  clear_response();
  if (quick_load) {
    set_has_quick_load();
    response_.quick_load_ = quick_load;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.quick_load)
}

// optional .SC2APIProtocol.ResponseQuit quit = 8;
inline bool Response::has_quit() const {
  return response_case() == kQuit;
}
inline void Response::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Response::clear_quit() {
  if (has_quit()) {
    delete response_.quit_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseQuit& Response::quit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quit)
  return has_quit()
      ? *response_.quit_
      : ::SC2APIProtocol::ResponseQuit::default_instance();
}
inline ::SC2APIProtocol::ResponseQuit* Response::mutable_quit() {
  if (!has_quit()) {
    clear_response();
    set_has_quit();
    response_.quit_ = new ::SC2APIProtocol::ResponseQuit;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quit)
  return response_.quit_;
}
inline ::SC2APIProtocol::ResponseQuit* Response::release_quit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quit)
  if (has_quit()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseQuit* temp = response_.quit_;
    response_.quit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_quit(::SC2APIProtocol::ResponseQuit* quit) {
  clear_response();
  if (quit) {
    set_has_quit();
    response_.quit_ = quit;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.quit)
}

// optional .SC2APIProtocol.ResponseGameInfo game_info = 9;
inline bool Response::has_game_info() const {
  return response_case() == kGameInfo;
}
inline void Response::set_has_game_info() {
  _oneof_case_[0] = kGameInfo;
}
inline void Response::clear_game_info() {
  if (has_game_info()) {
    delete response_.game_info_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseGameInfo& Response::game_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.game_info)
  return has_game_info()
      ? *response_.game_info_
      : ::SC2APIProtocol::ResponseGameInfo::default_instance();
}
inline ::SC2APIProtocol::ResponseGameInfo* Response::mutable_game_info() {
  if (!has_game_info()) {
    clear_response();
    set_has_game_info();
    response_.game_info_ = new ::SC2APIProtocol::ResponseGameInfo;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.game_info)
  return response_.game_info_;
}
inline ::SC2APIProtocol::ResponseGameInfo* Response::release_game_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.game_info)
  if (has_game_info()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseGameInfo* temp = response_.game_info_;
    response_.game_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_game_info(::SC2APIProtocol::ResponseGameInfo* game_info) {
  clear_response();
  if (game_info) {
    set_has_game_info();
    response_.game_info_ = game_info;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.game_info)
}

// optional .SC2APIProtocol.ResponseObservation observation = 10;
inline bool Response::has_observation() const {
  return response_case() == kObservation;
}
inline void Response::set_has_observation() {
  _oneof_case_[0] = kObservation;
}
inline void Response::clear_observation() {
  if (has_observation()) {
    delete response_.observation_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseObservation& Response::observation() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.observation)
  return has_observation()
      ? *response_.observation_
      : ::SC2APIProtocol::ResponseObservation::default_instance();
}
inline ::SC2APIProtocol::ResponseObservation* Response::mutable_observation() {
  if (!has_observation()) {
    clear_response();
    set_has_observation();
    response_.observation_ = new ::SC2APIProtocol::ResponseObservation;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.observation)
  return response_.observation_;
}
inline ::SC2APIProtocol::ResponseObservation* Response::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.observation)
  if (has_observation()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseObservation* temp = response_.observation_;
    response_.observation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_observation(::SC2APIProtocol::ResponseObservation* observation) {
  clear_response();
  if (observation) {
    set_has_observation();
    response_.observation_ = observation;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.observation)
}

// optional .SC2APIProtocol.ResponseAction action = 11;
inline bool Response::has_action() const {
  return response_case() == kAction;
}
inline void Response::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Response::clear_action() {
  if (has_action()) {
    delete response_.action_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseAction& Response::action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.action)
  return has_action()
      ? *response_.action_
      : ::SC2APIProtocol::ResponseAction::default_instance();
}
inline ::SC2APIProtocol::ResponseAction* Response::mutable_action() {
  if (!has_action()) {
    clear_response();
    set_has_action();
    response_.action_ = new ::SC2APIProtocol::ResponseAction;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.action)
  return response_.action_;
}
inline ::SC2APIProtocol::ResponseAction* Response::release_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.action)
  if (has_action()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseAction* temp = response_.action_;
    response_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_action(::SC2APIProtocol::ResponseAction* action) {
  clear_response();
  if (action) {
    set_has_action();
    response_.action_ = action;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.action)
}

// optional .SC2APIProtocol.ResponseStep step = 12;
inline bool Response::has_step() const {
  return response_case() == kStep;
}
inline void Response::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Response::clear_step() {
  if (has_step()) {
    delete response_.step_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseStep& Response::step() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.step)
  return has_step()
      ? *response_.step_
      : ::SC2APIProtocol::ResponseStep::default_instance();
}
inline ::SC2APIProtocol::ResponseStep* Response::mutable_step() {
  if (!has_step()) {
    clear_response();
    set_has_step();
    response_.step_ = new ::SC2APIProtocol::ResponseStep;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.step)
  return response_.step_;
}
inline ::SC2APIProtocol::ResponseStep* Response::release_step() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.step)
  if (has_step()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseStep* temp = response_.step_;
    response_.step_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_step(::SC2APIProtocol::ResponseStep* step) {
  clear_response();
  if (step) {
    set_has_step();
    response_.step_ = step;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.step)
}

// optional .SC2APIProtocol.ResponseData data = 13;
inline bool Response::has_data() const {
  return response_case() == kData;
}
inline void Response::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Response::clear_data() {
  if (has_data()) {
    delete response_.data_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseData& Response::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.data)
  return has_data()
      ? *response_.data_
      : ::SC2APIProtocol::ResponseData::default_instance();
}
inline ::SC2APIProtocol::ResponseData* Response::mutable_data() {
  if (!has_data()) {
    clear_response();
    set_has_data();
    response_.data_ = new ::SC2APIProtocol::ResponseData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.data)
  return response_.data_;
}
inline ::SC2APIProtocol::ResponseData* Response::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.data)
  if (has_data()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseData* temp = response_.data_;
    response_.data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_data(::SC2APIProtocol::ResponseData* data) {
  clear_response();
  if (data) {
    set_has_data();
    response_.data_ = data;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.data)
}

// optional .SC2APIProtocol.ResponseQuery query = 14;
inline bool Response::has_query() const {
  return response_case() == kQuery;
}
inline void Response::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Response::clear_query() {
  if (has_query()) {
    delete response_.query_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.query)
  return has_query()
      ? *response_.query_
      : ::SC2APIProtocol::ResponseQuery::default_instance();
}
inline ::SC2APIProtocol::ResponseQuery* Response::mutable_query() {
  if (!has_query()) {
    clear_response();
    set_has_query();
    response_.query_ = new ::SC2APIProtocol::ResponseQuery;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.query)
  return response_.query_;
}
inline ::SC2APIProtocol::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.query)
  if (has_query()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseQuery* temp = response_.query_;
    response_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_query(::SC2APIProtocol::ResponseQuery* query) {
  clear_response();
  if (query) {
    set_has_query();
    response_.query_ = query;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.query)
}

// optional .SC2APIProtocol.ResponseSaveReplay save_replay = 15;
inline bool Response::has_save_replay() const {
  return response_case() == kSaveReplay;
}
inline void Response::set_has_save_replay() {
  _oneof_case_[0] = kSaveReplay;
}
inline void Response::clear_save_replay() {
  if (has_save_replay()) {
    delete response_.save_replay_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseSaveReplay& Response::save_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.save_replay)
  return has_save_replay()
      ? *response_.save_replay_
      : ::SC2APIProtocol::ResponseSaveReplay::default_instance();
}
inline ::SC2APIProtocol::ResponseSaveReplay* Response::mutable_save_replay() {
  if (!has_save_replay()) {
    clear_response();
    set_has_save_replay();
    response_.save_replay_ = new ::SC2APIProtocol::ResponseSaveReplay;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.save_replay)
  return response_.save_replay_;
}
inline ::SC2APIProtocol::ResponseSaveReplay* Response::release_save_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.save_replay)
  if (has_save_replay()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseSaveReplay* temp = response_.save_replay_;
    response_.save_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_save_replay(::SC2APIProtocol::ResponseSaveReplay* save_replay) {
  clear_response();
  if (save_replay) {
    set_has_save_replay();
    response_.save_replay_ = save_replay;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.save_replay)
}

// optional .SC2APIProtocol.ResponseReplayInfo replay_info = 16;
inline bool Response::has_replay_info() const {
  return response_case() == kReplayInfo;
}
inline void Response::set_has_replay_info() {
  _oneof_case_[0] = kReplayInfo;
}
inline void Response::clear_replay_info() {
  if (has_replay_info()) {
    delete response_.replay_info_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseReplayInfo& Response::replay_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.replay_info)
  return has_replay_info()
      ? *response_.replay_info_
      : ::SC2APIProtocol::ResponseReplayInfo::default_instance();
}
inline ::SC2APIProtocol::ResponseReplayInfo* Response::mutable_replay_info() {
  if (!has_replay_info()) {
    clear_response();
    set_has_replay_info();
    response_.replay_info_ = new ::SC2APIProtocol::ResponseReplayInfo;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.replay_info)
  return response_.replay_info_;
}
inline ::SC2APIProtocol::ResponseReplayInfo* Response::release_replay_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.replay_info)
  if (has_replay_info()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseReplayInfo* temp = response_.replay_info_;
    response_.replay_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_replay_info(::SC2APIProtocol::ResponseReplayInfo* replay_info) {
  clear_response();
  if (replay_info) {
    set_has_replay_info();
    response_.replay_info_ = replay_info;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.replay_info)
}

// optional .SC2APIProtocol.ResponseAvailableMaps available_maps = 17;
inline bool Response::has_available_maps() const {
  return response_case() == kAvailableMaps;
}
inline void Response::set_has_available_maps() {
  _oneof_case_[0] = kAvailableMaps;
}
inline void Response::clear_available_maps() {
  if (has_available_maps()) {
    delete response_.available_maps_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseAvailableMaps& Response::available_maps() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.available_maps)
  return has_available_maps()
      ? *response_.available_maps_
      : ::SC2APIProtocol::ResponseAvailableMaps::default_instance();
}
inline ::SC2APIProtocol::ResponseAvailableMaps* Response::mutable_available_maps() {
  if (!has_available_maps()) {
    clear_response();
    set_has_available_maps();
    response_.available_maps_ = new ::SC2APIProtocol::ResponseAvailableMaps;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.available_maps)
  return response_.available_maps_;
}
inline ::SC2APIProtocol::ResponseAvailableMaps* Response::release_available_maps() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.available_maps)
  if (has_available_maps()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseAvailableMaps* temp = response_.available_maps_;
    response_.available_maps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_available_maps(::SC2APIProtocol::ResponseAvailableMaps* available_maps) {
  clear_response();
  if (available_maps) {
    set_has_available_maps();
    response_.available_maps_ = available_maps;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.available_maps)
}

// optional .SC2APIProtocol.ResponseSaveMap save_map = 18;
inline bool Response::has_save_map() const {
  return response_case() == kSaveMap;
}
inline void Response::set_has_save_map() {
  _oneof_case_[0] = kSaveMap;
}
inline void Response::clear_save_map() {
  if (has_save_map()) {
    delete response_.save_map_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseSaveMap& Response::save_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.save_map)
  return has_save_map()
      ? *response_.save_map_
      : ::SC2APIProtocol::ResponseSaveMap::default_instance();
}
inline ::SC2APIProtocol::ResponseSaveMap* Response::mutable_save_map() {
  if (!has_save_map()) {
    clear_response();
    set_has_save_map();
    response_.save_map_ = new ::SC2APIProtocol::ResponseSaveMap;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.save_map)
  return response_.save_map_;
}
inline ::SC2APIProtocol::ResponseSaveMap* Response::release_save_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.save_map)
  if (has_save_map()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseSaveMap* temp = response_.save_map_;
    response_.save_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_save_map(::SC2APIProtocol::ResponseSaveMap* save_map) {
  clear_response();
  if (save_map) {
    set_has_save_map();
    response_.save_map_ = save_map;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.save_map)
}

// optional .SC2APIProtocol.ResponsePing ping = 19;
inline bool Response::has_ping() const {
  return response_case() == kPing;
}
inline void Response::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Response::clear_ping() {
  if (has_ping()) {
    delete response_.ping_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponsePing& Response::ping() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.ping)
  return has_ping()
      ? *response_.ping_
      : ::SC2APIProtocol::ResponsePing::default_instance();
}
inline ::SC2APIProtocol::ResponsePing* Response::mutable_ping() {
  if (!has_ping()) {
    clear_response();
    set_has_ping();
    response_.ping_ = new ::SC2APIProtocol::ResponsePing;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.ping)
  return response_.ping_;
}
inline ::SC2APIProtocol::ResponsePing* Response::release_ping() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.ping)
  if (has_ping()) {
    clear_has_response();
    ::SC2APIProtocol::ResponsePing* temp = response_.ping_;
    response_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_ping(::SC2APIProtocol::ResponsePing* ping) {
  clear_response();
  if (ping) {
    set_has_ping();
    response_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.ping)
}

// optional .SC2APIProtocol.ResponseDebug debug = 20;
inline bool Response::has_debug() const {
  return response_case() == kDebug;
}
inline void Response::set_has_debug() {
  _oneof_case_[0] = kDebug;
}
inline void Response::clear_debug() {
  if (has_debug()) {
    delete response_.debug_;
    clear_has_response();
  }
}
inline  const ::SC2APIProtocol::ResponseDebug& Response::debug() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.debug)
  return has_debug()
      ? *response_.debug_
      : ::SC2APIProtocol::ResponseDebug::default_instance();
}
inline ::SC2APIProtocol::ResponseDebug* Response::mutable_debug() {
  if (!has_debug()) {
    clear_response();
    set_has_debug();
    response_.debug_ = new ::SC2APIProtocol::ResponseDebug;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.debug)
  return response_.debug_;
}
inline ::SC2APIProtocol::ResponseDebug* Response::release_debug() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.debug)
  if (has_debug()) {
    clear_has_response();
    ::SC2APIProtocol::ResponseDebug* temp = response_.debug_;
    response_.debug_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_debug(::SC2APIProtocol::ResponseDebug* debug) {
  clear_response();
  if (debug) {
    set_has_debug();
    response_.debug_ = debug;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Response.debug)
}

// repeated string error = 98;
inline int Response::error_size() const {
  return error_.size();
}
inline void Response::clear_error() {
  error_.Clear();
}
inline const ::std::string& Response::error(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.error)
  return error_.Get(index);
}
inline ::std::string* Response::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.error)
  return error_.Mutable(index);
}
inline void Response::set_error(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.error)
  error_.Mutable(index)->assign(value);
}
inline void Response::set_error(int index, const char* value) {
  error_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.Response.error)
}
inline void Response::set_error(int index, const char* value, size_t size) {
  error_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.Response.error)
}
inline ::std::string* Response::add_error() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.Response.error)
  return error_.Add();
}
inline void Response::add_error(const ::std::string& value) {
  error_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Response.error)
}
inline void Response::add_error(const char* value) {
  error_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.Response.error)
}
inline void Response::add_error(const char* value, size_t size) {
  error_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.Response.error)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Response::error() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Response.error)
  return error_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Response::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Response.error)
  return &error_;
}

// optional .SC2APIProtocol.Status status = 99;
inline bool Response::has_status() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Response::set_has_status() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Response::clear_has_status() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Response::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::SC2APIProtocol::Status Response::status() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.status)
  return static_cast< ::SC2APIProtocol::Status >(status_);
}
inline void Response::set_status(::SC2APIProtocol::Status value) {
  assert(::SC2APIProtocol::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.status)
}

inline bool Response::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void Response::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline Response::ResponseCase Response::response_case() const {
  return Response::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestCreateGame

// optional .SC2APIProtocol.LocalMap local_map = 1;
inline bool RequestCreateGame::has_local_map() const {
  return Map_case() == kLocalMap;
}
inline void RequestCreateGame::set_has_local_map() {
  _oneof_case_[0] = kLocalMap;
}
inline void RequestCreateGame::clear_local_map() {
  if (has_local_map()) {
    delete Map_.local_map_;
    clear_has_Map();
  }
}
inline  const ::SC2APIProtocol::LocalMap& RequestCreateGame::local_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.local_map)
  return has_local_map()
      ? *Map_.local_map_
      : ::SC2APIProtocol::LocalMap::default_instance();
}
inline ::SC2APIProtocol::LocalMap* RequestCreateGame::mutable_local_map() {
  if (!has_local_map()) {
    clear_Map();
    set_has_local_map();
    Map_.local_map_ = new ::SC2APIProtocol::LocalMap;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.local_map)
  return Map_.local_map_;
}
inline ::SC2APIProtocol::LocalMap* RequestCreateGame::release_local_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestCreateGame.local_map)
  if (has_local_map()) {
    clear_has_Map();
    ::SC2APIProtocol::LocalMap* temp = Map_.local_map_;
    Map_.local_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RequestCreateGame::set_allocated_local_map(::SC2APIProtocol::LocalMap* local_map) {
  clear_Map();
  if (local_map) {
    set_has_local_map();
    Map_.local_map_ = local_map;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestCreateGame.local_map)
}

// optional string battlenet_map_name = 2;
inline bool RequestCreateGame::has_battlenet_map_name() const {
  return Map_case() == kBattlenetMapName;
}
inline void RequestCreateGame::set_has_battlenet_map_name() {
  _oneof_case_[0] = kBattlenetMapName;
}
inline void RequestCreateGame::clear_battlenet_map_name() {
  if (has_battlenet_map_name()) {
    Map_.battlenet_map_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_Map();
  }
}
inline const ::std::string& RequestCreateGame::battlenet_map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (has_battlenet_map_name()) {
    return Map_.battlenet_map_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestCreateGame::set_battlenet_map_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline void RequestCreateGame::set_battlenet_map_name(const char* value) {
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline void RequestCreateGame::set_battlenet_map_name(const char* value, size_t size) {
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline ::std::string* RequestCreateGame::mutable_battlenet_map_name() {
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  return Map_.battlenet_map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCreateGame::release_battlenet_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (has_battlenet_map_name()) {
    clear_has_Map();
    return Map_.battlenet_map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestCreateGame::set_allocated_battlenet_map_name(::std::string* battlenet_map_name) {
  if (!has_battlenet_map_name()) {
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_Map();
  if (battlenet_map_name != NULL) {
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        battlenet_map_name);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}

// repeated .SC2APIProtocol.PlayerSetup player_setup = 3;
inline int RequestCreateGame::player_setup_size() const {
  return player_setup_.size();
}
inline void RequestCreateGame::clear_player_setup() {
  player_setup_.Clear();
}
inline const ::SC2APIProtocol::PlayerSetup& RequestCreateGame::player_setup(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Get(index);
}
inline ::SC2APIProtocol::PlayerSetup* RequestCreateGame::mutable_player_setup(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Mutable(index);
}
inline ::SC2APIProtocol::PlayerSetup* RequestCreateGame::add_player_setup() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >*
RequestCreateGame::mutable_player_setup() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestCreateGame.player_setup)
  return &player_setup_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >&
RequestCreateGame::player_setup() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_;
}

// optional bool disable_fog = 4;
inline bool RequestCreateGame::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestCreateGame::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestCreateGame::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestCreateGame::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestCreateGame::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.disable_fog)
  return disable_fog_;
}
inline void RequestCreateGame::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.disable_fog)
}

// optional uint32 random_seed = 5;
inline bool RequestCreateGame::has_random_seed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestCreateGame::set_has_random_seed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestCreateGame::clear_has_random_seed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestCreateGame::clear_random_seed() {
  random_seed_ = 0u;
  clear_has_random_seed();
}
inline ::google::protobuf::uint32 RequestCreateGame::random_seed() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.random_seed)
  return random_seed_;
}
inline void RequestCreateGame::set_random_seed(::google::protobuf::uint32 value) {
  set_has_random_seed();
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.random_seed)
}

// optional bool realtime = 6;
inline bool RequestCreateGame::has_realtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestCreateGame::set_has_realtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestCreateGame::clear_has_realtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestCreateGame::clear_realtime() {
  realtime_ = false;
  clear_has_realtime();
}
inline bool RequestCreateGame::realtime() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.realtime)
  return realtime_;
}
inline void RequestCreateGame::set_realtime(bool value) {
  set_has_realtime();
  realtime_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.realtime)
}

inline bool RequestCreateGame::has_Map() const {
  return Map_case() != MAP_NOT_SET;
}
inline void RequestCreateGame::clear_has_Map() {
  _oneof_case_[0] = MAP_NOT_SET;
}
inline RequestCreateGame::MapCase RequestCreateGame::Map_case() const {
  return RequestCreateGame::MapCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalMap

// optional string map_path = 1;
inline bool LocalMap::has_map_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalMap::set_has_map_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalMap::clear_has_map_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalMap::clear_map_path() {
  map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_path();
}
inline const ::std::string& LocalMap::map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.LocalMap.map_path)
  return map_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_map_path(const ::std::string& value) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.LocalMap.map_path)
}
inline void LocalMap::set_map_path(const char* value) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.LocalMap.map_path)
}
inline void LocalMap::set_map_path(const char* value, size_t size) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.LocalMap.map_path)
}
inline ::std::string* LocalMap::mutable_map_path() {
  set_has_map_path();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.LocalMap.map_path)
  return map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocalMap::release_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.LocalMap.map_path)
  clear_has_map_path();
  return map_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_allocated_map_path(::std::string* map_path) {
  if (map_path != NULL) {
    set_has_map_path();
  } else {
    clear_has_map_path();
  }
  map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.LocalMap.map_path)
}

// optional bytes map_data = 7;
inline bool LocalMap::has_map_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalMap::set_has_map_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalMap::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalMap::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& LocalMap::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.LocalMap.map_data)
  return map_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.LocalMap.map_data)
}
inline void LocalMap::set_map_data(const char* value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.LocalMap.map_data)
}
inline void LocalMap::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.LocalMap.map_data)
}
inline ::std::string* LocalMap::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.LocalMap.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocalMap::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.LocalMap.map_data)
  clear_has_map_data();
  return map_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.LocalMap.map_data)
}

// -------------------------------------------------------------------

// ResponseCreateGame

// optional .SC2APIProtocol.ResponseCreateGame.Error error = 1;
inline bool ResponseCreateGame::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCreateGame::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCreateGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCreateGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseCreateGame_Error ResponseCreateGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseCreateGame.error)
  return static_cast< ::SC2APIProtocol::ResponseCreateGame_Error >(error_);
}
inline void ResponseCreateGame::set_error(::SC2APIProtocol::ResponseCreateGame_Error value) {
  assert(::SC2APIProtocol::ResponseCreateGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseCreateGame.error)
}

// optional string error_details = 2;
inline bool ResponseCreateGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCreateGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCreateGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCreateGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseCreateGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseCreateGame.error_details)
  return error_details_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCreateGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline void ResponseCreateGame::set_error_details(const char* value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline void ResponseCreateGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline ::std::string* ResponseCreateGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseCreateGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCreateGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseCreateGame.error_details)
  clear_has_error_details();
  return error_details_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCreateGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseCreateGame.error_details)
}

// -------------------------------------------------------------------

// RequestJoinGame

// optional .SC2APIProtocol.Race race = 1;
inline bool RequestJoinGame::has_race() const {
  return participation_case() == kRace;
}
inline void RequestJoinGame::set_has_race() {
  _oneof_case_[0] = kRace;
}
inline void RequestJoinGame::clear_race() {
  if (has_race()) {
    participation_.race_ = 0;
    clear_has_participation();
  }
}
inline ::SC2APIProtocol::Race RequestJoinGame::race() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.race)
  if (has_race()) {
    return static_cast< ::SC2APIProtocol::Race >(participation_.race_);
  }
  return static_cast< ::SC2APIProtocol::Race >(0);
}
inline void RequestJoinGame::set_race(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  if (!has_race()) {
    clear_participation();
    set_has_race();
  }
  participation_.race_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.race)
}

// optional uint32 observed_player_id = 2;
inline bool RequestJoinGame::has_observed_player_id() const {
  return participation_case() == kObservedPlayerId;
}
inline void RequestJoinGame::set_has_observed_player_id() {
  _oneof_case_[0] = kObservedPlayerId;
}
inline void RequestJoinGame::clear_observed_player_id() {
  if (has_observed_player_id()) {
    participation_.observed_player_id_ = 0u;
    clear_has_participation();
  }
}
inline ::google::protobuf::uint32 RequestJoinGame::observed_player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.observed_player_id)
  if (has_observed_player_id()) {
    return participation_.observed_player_id_;
  }
  return 0u;
}
inline void RequestJoinGame::set_observed_player_id(::google::protobuf::uint32 value) {
  if (!has_observed_player_id()) {
    clear_participation();
    set_has_observed_player_id();
  }
  participation_.observed_player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.observed_player_id)
}

// optional .SC2APIProtocol.InterfaceOptions options = 3;
inline bool RequestJoinGame::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestJoinGame::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestJoinGame::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestJoinGame::clear_options() {
  if (options_ != NULL) options_->::SC2APIProtocol::InterfaceOptions::Clear();
  clear_has_options();
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestJoinGame::options() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestJoinGame::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    options_ = new ::SC2APIProtocol::InterfaceOptions;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.options)
  return options_;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestJoinGame::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestJoinGame.options)
  clear_has_options();
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void RequestJoinGame::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestJoinGame.options)
}

// optional .SC2APIProtocol.PortSet server_ports = 4;
inline bool RequestJoinGame::has_server_ports() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestJoinGame::set_has_server_ports() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestJoinGame::clear_has_server_ports() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestJoinGame::clear_server_ports() {
  if (server_ports_ != NULL) server_ports_->::SC2APIProtocol::PortSet::Clear();
  clear_has_server_ports();
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::server_ports() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.server_ports)
  return server_ports_ != NULL ? *server_ports_ : *default_instance_->server_ports_;
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::mutable_server_ports() {
  set_has_server_ports();
  if (server_ports_ == NULL) {
    server_ports_ = new ::SC2APIProtocol::PortSet;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.server_ports)
  return server_ports_;
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::release_server_ports() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestJoinGame.server_ports)
  clear_has_server_ports();
  ::SC2APIProtocol::PortSet* temp = server_ports_;
  server_ports_ = NULL;
  return temp;
}
inline void RequestJoinGame::set_allocated_server_ports(::SC2APIProtocol::PortSet* server_ports) {
  delete server_ports_;
  server_ports_ = server_ports;
  if (server_ports) {
    set_has_server_ports();
  } else {
    clear_has_server_ports();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestJoinGame.server_ports)
}

// repeated .SC2APIProtocol.PortSet client_ports = 5;
inline int RequestJoinGame::client_ports_size() const {
  return client_ports_.size();
}
inline void RequestJoinGame::clear_client_ports() {
  client_ports_.Clear();
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::client_ports(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Get(index);
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::mutable_client_ports(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Mutable(index);
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::add_client_ports() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet >*
RequestJoinGame::mutable_client_ports() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestJoinGame.client_ports)
  return &client_ports_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet >&
RequestJoinGame::client_ports() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_;
}

// optional int32 shared_port = 6;
inline bool RequestJoinGame::has_shared_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestJoinGame::set_has_shared_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestJoinGame::clear_has_shared_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestJoinGame::clear_shared_port() {
  shared_port_ = 0;
  clear_has_shared_port();
}
inline ::google::protobuf::int32 RequestJoinGame::shared_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.shared_port)
  return shared_port_;
}
inline void RequestJoinGame::set_shared_port(::google::protobuf::int32 value) {
  set_has_shared_port();
  shared_port_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.shared_port)
}

inline bool RequestJoinGame::has_participation() const {
  return participation_case() != PARTICIPATION_NOT_SET;
}
inline void RequestJoinGame::clear_has_participation() {
  _oneof_case_[0] = PARTICIPATION_NOT_SET;
}
inline RequestJoinGame::ParticipationCase RequestJoinGame::participation_case() const {
  return RequestJoinGame::ParticipationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PortSet

// optional int32 game_port = 1;
inline bool PortSet::has_game_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortSet::set_has_game_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortSet::clear_has_game_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortSet::clear_game_port() {
  game_port_ = 0;
  clear_has_game_port();
}
inline ::google::protobuf::int32 PortSet::game_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PortSet.game_port)
  return game_port_;
}
inline void PortSet::set_game_port(::google::protobuf::int32 value) {
  set_has_game_port();
  game_port_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PortSet.game_port)
}

// optional int32 base_port = 2;
inline bool PortSet::has_base_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortSet::set_has_base_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortSet::clear_has_base_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortSet::clear_base_port() {
  base_port_ = 0;
  clear_has_base_port();
}
inline ::google::protobuf::int32 PortSet::base_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PortSet.base_port)
  return base_port_;
}
inline void PortSet::set_base_port(::google::protobuf::int32 value) {
  set_has_base_port();
  base_port_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PortSet.base_port)
}

// -------------------------------------------------------------------

// ResponseJoinGame

// optional uint32 player_id = 1;
inline bool ResponseJoinGame::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseJoinGame::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseJoinGame::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseJoinGame::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ResponseJoinGame::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.player_id)
  return player_id_;
}
inline void ResponseJoinGame::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.player_id)
}

// optional .SC2APIProtocol.ResponseJoinGame.Error error = 2;
inline bool ResponseJoinGame::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseJoinGame::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseJoinGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseJoinGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseJoinGame_Error ResponseJoinGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.error)
  return static_cast< ::SC2APIProtocol::ResponseJoinGame_Error >(error_);
}
inline void ResponseJoinGame::set_error(::SC2APIProtocol::ResponseJoinGame_Error value) {
  assert(::SC2APIProtocol::ResponseJoinGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.error)
}

// optional string error_details = 3;
inline bool ResponseJoinGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseJoinGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseJoinGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseJoinGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseJoinGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.error_details)
  return error_details_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseJoinGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline void ResponseJoinGame::set_error_details(const char* value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline void ResponseJoinGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline ::std::string* ResponseJoinGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseJoinGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseJoinGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseJoinGame.error_details)
  clear_has_error_details();
  return error_details_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseJoinGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseJoinGame.error_details)
}

// -------------------------------------------------------------------

// RequestRestartGame

// -------------------------------------------------------------------

// ResponseRestartGame

// optional .SC2APIProtocol.ResponseRestartGame.Error error = 1;
inline bool ResponseRestartGame::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRestartGame::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRestartGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRestartGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseRestartGame_Error ResponseRestartGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseRestartGame.error)
  return static_cast< ::SC2APIProtocol::ResponseRestartGame_Error >(error_);
}
inline void ResponseRestartGame::set_error(::SC2APIProtocol::ResponseRestartGame_Error value) {
  assert(::SC2APIProtocol::ResponseRestartGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseRestartGame.error)
}

// optional string error_details = 2;
inline bool ResponseRestartGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseRestartGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseRestartGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseRestartGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseRestartGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseRestartGame.error_details)
  return error_details_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseRestartGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline void ResponseRestartGame::set_error_details(const char* value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline void ResponseRestartGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline ::std::string* ResponseRestartGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseRestartGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseRestartGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseRestartGame.error_details)
  clear_has_error_details();
  return error_details_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseRestartGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseRestartGame.error_details)
}

// -------------------------------------------------------------------

// RequestStartReplay

// optional string replay_path = 1;
inline bool RequestStartReplay::has_replay_path() const {
  return replay_case() == kReplayPath;
}
inline void RequestStartReplay::set_has_replay_path() {
  _oneof_case_[0] = kReplayPath;
}
inline void RequestStartReplay::clear_replay_path() {
  if (has_replay_path()) {
    replay_.replay_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestStartReplay::replay_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.replay_path)
  if (has_replay_path()) {
    return replay_.replay_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestStartReplay::set_replay_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline void RequestStartReplay::set_replay_path(const char* value) {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline void RequestStartReplay::set_replay_path(const char* value, size_t size) {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline ::std::string* RequestStartReplay::mutable_replay_path() {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.replay_path)
  return replay_.replay_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_replay_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.replay_path)
  if (has_replay_path()) {
    clear_has_replay();
    return replay_.replay_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestStartReplay::set_allocated_replay_path(::std::string* replay_path) {
  if (!has_replay_path()) {
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_path != NULL) {
    set_has_replay_path();
    replay_.replay_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        replay_path);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.replay_path)
}

// optional bytes replay_data = 5;
inline bool RequestStartReplay::has_replay_data() const {
  return replay_case() == kReplayData;
}
inline void RequestStartReplay::set_has_replay_data() {
  _oneof_case_[0] = kReplayData;
}
inline void RequestStartReplay::clear_replay_data() {
  if (has_replay_data()) {
    replay_.replay_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestStartReplay::replay_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.replay_data)
  if (has_replay_data()) {
    return replay_.replay_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestStartReplay::set_replay_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline void RequestStartReplay::set_replay_data(const char* value) {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline void RequestStartReplay::set_replay_data(const void* value, size_t size) {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline ::std::string* RequestStartReplay::mutable_replay_data() {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.replay_data)
  return replay_.replay_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_replay_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.replay_data)
  if (has_replay_data()) {
    clear_has_replay();
    return replay_.replay_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestStartReplay::set_allocated_replay_data(::std::string* replay_data) {
  if (!has_replay_data()) {
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_data != NULL) {
    set_has_replay_data();
    replay_.replay_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        replay_data);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.replay_data)
}

// optional bytes map_data = 6;
inline bool RequestStartReplay::has_map_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestStartReplay::set_has_map_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestStartReplay::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestStartReplay::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& RequestStartReplay::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.map_data)
  return map_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestStartReplay::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.map_data)
}
inline void RequestStartReplay::set_map_data(const char* value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.map_data)
}
inline void RequestStartReplay::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.map_data)
}
inline ::std::string* RequestStartReplay::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.map_data)
  clear_has_map_data();
  return map_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestStartReplay::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.map_data)
}

// optional int32 observed_player_id = 2;
inline bool RequestStartReplay::has_observed_player_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestStartReplay::set_has_observed_player_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestStartReplay::clear_has_observed_player_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestStartReplay::clear_observed_player_id() {
  observed_player_id_ = 0;
  clear_has_observed_player_id();
}
inline ::google::protobuf::int32 RequestStartReplay::observed_player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.observed_player_id)
  return observed_player_id_;
}
inline void RequestStartReplay::set_observed_player_id(::google::protobuf::int32 value) {
  set_has_observed_player_id();
  observed_player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.observed_player_id)
}

// optional .SC2APIProtocol.InterfaceOptions options = 3;
inline bool RequestStartReplay::has_options() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestStartReplay::set_has_options() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestStartReplay::clear_has_options() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestStartReplay::clear_options() {
  if (options_ != NULL) options_->::SC2APIProtocol::InterfaceOptions::Clear();
  clear_has_options();
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestStartReplay::options() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestStartReplay::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    options_ = new ::SC2APIProtocol::InterfaceOptions;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.options)
  return options_;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestStartReplay::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.options)
  clear_has_options();
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void RequestStartReplay::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.options)
}

// optional bool disable_fog = 4;
inline bool RequestStartReplay::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestStartReplay::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestStartReplay::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestStartReplay::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestStartReplay::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.disable_fog)
  return disable_fog_;
}
inline void RequestStartReplay::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.disable_fog)
}

inline bool RequestStartReplay::has_replay() const {
  return replay_case() != REPLAY_NOT_SET;
}
inline void RequestStartReplay::clear_has_replay() {
  _oneof_case_[0] = REPLAY_NOT_SET;
}
inline RequestStartReplay::ReplayCase RequestStartReplay::replay_case() const {
  return RequestStartReplay::ReplayCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseStartReplay

// optional .SC2APIProtocol.ResponseStartReplay.Error error = 1;
inline bool ResponseStartReplay::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseStartReplay::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseStartReplay::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseStartReplay::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseStartReplay_Error ResponseStartReplay::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseStartReplay.error)
  return static_cast< ::SC2APIProtocol::ResponseStartReplay_Error >(error_);
}
inline void ResponseStartReplay::set_error(::SC2APIProtocol::ResponseStartReplay_Error value) {
  assert(::SC2APIProtocol::ResponseStartReplay_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseStartReplay.error)
}

// optional string error_details = 2;
inline bool ResponseStartReplay::has_error_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseStartReplay::set_has_error_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseStartReplay::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseStartReplay::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseStartReplay::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseStartReplay.error_details)
  return error_details_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseStartReplay::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline void ResponseStartReplay::set_error_details(const char* value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline void ResponseStartReplay::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline ::std::string* ResponseStartReplay::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseStartReplay.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseStartReplay::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseStartReplay.error_details)
  clear_has_error_details();
  return error_details_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseStartReplay::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseStartReplay.error_details)
}

// -------------------------------------------------------------------

// RequestLeaveGame

// -------------------------------------------------------------------

// ResponseLeaveGame

// -------------------------------------------------------------------

// RequestQuickSave

// -------------------------------------------------------------------

// ResponseQuickSave

// -------------------------------------------------------------------

// RequestQuickLoad

// -------------------------------------------------------------------

// ResponseQuickLoad

// -------------------------------------------------------------------

// RequestQuit

// -------------------------------------------------------------------

// ResponseQuit

// -------------------------------------------------------------------

// RequestGameInfo

// -------------------------------------------------------------------

// ResponseGameInfo

// optional string map_name = 1;
inline bool ResponseGameInfo::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGameInfo::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGameInfo::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGameInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& ResponseGameInfo::map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.map_name)
  return map_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline void ResponseGameInfo::set_map_name(const char* value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline void ResponseGameInfo::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline ::std::string* ResponseGameInfo::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseGameInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.map_name)
  clear_has_map_name();
  return map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.map_name)
}

// repeated string mod_names = 6;
inline int ResponseGameInfo::mod_names_size() const {
  return mod_names_.size();
}
inline void ResponseGameInfo::clear_mod_names() {
  mod_names_.Clear();
}
inline const ::std::string& ResponseGameInfo::mod_names(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Get(index);
}
inline ::std::string* ResponseGameInfo::mutable_mod_names(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Mutable(index);
}
inline void ResponseGameInfo::set_mod_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.mod_names)
  mod_names_.Mutable(index)->assign(value);
}
inline void ResponseGameInfo::set_mod_names(int index, const char* value) {
  mod_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::set_mod_names(int index, const char* value, size_t size) {
  mod_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline ::std::string* ResponseGameInfo::add_mod_names() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Add();
}
inline void ResponseGameInfo::add_mod_names(const ::std::string& value) {
  mod_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::add_mod_names(const char* value) {
  mod_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::add_mod_names(const char* value, size_t size) {
  mod_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseGameInfo::mod_names() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseGameInfo::mutable_mod_names() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseGameInfo.mod_names)
  return &mod_names_;
}

// optional string local_map_path = 2;
inline bool ResponseGameInfo::has_local_map_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseGameInfo::set_has_local_map_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseGameInfo::clear_has_local_map_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseGameInfo::clear_local_map_path() {
  local_map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_map_path();
}
inline const ::std::string& ResponseGameInfo::local_map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.local_map_path)
  return local_map_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_local_map_path(const ::std::string& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline void ResponseGameInfo::set_local_map_path(const char* value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline void ResponseGameInfo::set_local_map_path(const char* value, size_t size) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline ::std::string* ResponseGameInfo::mutable_local_map_path() {
  set_has_local_map_path();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.local_map_path)
  return local_map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseGameInfo::release_local_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.local_map_path)
  clear_has_local_map_path();
  return local_map_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_allocated_local_map_path(::std::string* local_map_path) {
  if (local_map_path != NULL) {
    set_has_local_map_path();
  } else {
    clear_has_local_map_path();
  }
  local_map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.local_map_path)
}

// repeated .SC2APIProtocol.PlayerInfo player_info = 3;
inline int ResponseGameInfo::player_info_size() const {
  return player_info_.size();
}
inline void ResponseGameInfo::clear_player_info() {
  player_info_.Clear();
}
inline const ::SC2APIProtocol::PlayerInfo& ResponseGameInfo::player_info(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_.Get(index);
}
inline ::SC2APIProtocol::PlayerInfo* ResponseGameInfo::mutable_player_info(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_.Mutable(index);
}
inline ::SC2APIProtocol::PlayerInfo* ResponseGameInfo::add_player_info() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >*
ResponseGameInfo::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseGameInfo.player_info)
  return &player_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >&
ResponseGameInfo::player_info() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_;
}

// optional .SC2APIProtocol.StartRaw start_raw = 4;
inline bool ResponseGameInfo::has_start_raw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseGameInfo::set_has_start_raw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseGameInfo::clear_has_start_raw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseGameInfo::clear_start_raw() {
  if (start_raw_ != NULL) start_raw_->::SC2APIProtocol::StartRaw::Clear();
  clear_has_start_raw();
}
inline const ::SC2APIProtocol::StartRaw& ResponseGameInfo::start_raw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.start_raw)
  return start_raw_ != NULL ? *start_raw_ : *default_instance_->start_raw_;
}
inline ::SC2APIProtocol::StartRaw* ResponseGameInfo::mutable_start_raw() {
  set_has_start_raw();
  if (start_raw_ == NULL) {
    start_raw_ = new ::SC2APIProtocol::StartRaw;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.start_raw)
  return start_raw_;
}
inline ::SC2APIProtocol::StartRaw* ResponseGameInfo::release_start_raw() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.start_raw)
  clear_has_start_raw();
  ::SC2APIProtocol::StartRaw* temp = start_raw_;
  start_raw_ = NULL;
  return temp;
}
inline void ResponseGameInfo::set_allocated_start_raw(::SC2APIProtocol::StartRaw* start_raw) {
  delete start_raw_;
  start_raw_ = start_raw;
  if (start_raw) {
    set_has_start_raw();
  } else {
    clear_has_start_raw();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.start_raw)
}

// optional .SC2APIProtocol.InterfaceOptions options = 5;
inline bool ResponseGameInfo::has_options() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseGameInfo::set_has_options() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseGameInfo::clear_has_options() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseGameInfo::clear_options() {
  if (options_ != NULL) options_->::SC2APIProtocol::InterfaceOptions::Clear();
  clear_has_options();
}
inline const ::SC2APIProtocol::InterfaceOptions& ResponseGameInfo::options() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::SC2APIProtocol::InterfaceOptions* ResponseGameInfo::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    options_ = new ::SC2APIProtocol::InterfaceOptions;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.options)
  return options_;
}
inline ::SC2APIProtocol::InterfaceOptions* ResponseGameInfo::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.options)
  clear_has_options();
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void ResponseGameInfo::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.options)
}

// -------------------------------------------------------------------

// RequestObservation

// optional bool disable_fog = 1;
inline bool RequestObservation::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestObservation::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestObservation::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestObservation::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestObservation::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestObservation.disable_fog)
  return disable_fog_;
}
inline void RequestObservation::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestObservation.disable_fog)
}

// -------------------------------------------------------------------

// ResponseObservation

// repeated .SC2APIProtocol.Action actions = 1;
inline int ResponseObservation::actions_size() const {
  return actions_.size();
}
inline void ResponseObservation::clear_actions() {
  actions_.Clear();
}
inline const ::SC2APIProtocol::Action& ResponseObservation::actions(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.actions)
  return actions_.Get(index);
}
inline ::SC2APIProtocol::Action* ResponseObservation::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.actions)
  return actions_.Mutable(index);
}
inline ::SC2APIProtocol::Action* ResponseObservation::add_actions() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.actions)
  return actions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >*
ResponseObservation::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.actions)
  return &actions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >&
ResponseObservation::actions() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.actions)
  return actions_;
}

// repeated .SC2APIProtocol.ActionError action_errors = 2;
inline int ResponseObservation::action_errors_size() const {
  return action_errors_.size();
}
inline void ResponseObservation::clear_action_errors() {
  action_errors_.Clear();
}
inline const ::SC2APIProtocol::ActionError& ResponseObservation::action_errors(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_.Get(index);
}
inline ::SC2APIProtocol::ActionError* ResponseObservation::mutable_action_errors(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_.Mutable(index);
}
inline ::SC2APIProtocol::ActionError* ResponseObservation::add_action_errors() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError >*
ResponseObservation::mutable_action_errors() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.action_errors)
  return &action_errors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError >&
ResponseObservation::action_errors() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_;
}

// optional .SC2APIProtocol.Observation observation = 3;
inline bool ResponseObservation::has_observation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseObservation::set_has_observation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseObservation::clear_has_observation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseObservation::clear_observation() {
  if (observation_ != NULL) observation_->::SC2APIProtocol::Observation::Clear();
  clear_has_observation();
}
inline const ::SC2APIProtocol::Observation& ResponseObservation::observation() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.observation)
  return observation_ != NULL ? *observation_ : *default_instance_->observation_;
}
inline ::SC2APIProtocol::Observation* ResponseObservation::mutable_observation() {
  set_has_observation();
  if (observation_ == NULL) {
    observation_ = new ::SC2APIProtocol::Observation;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.observation)
  return observation_;
}
inline ::SC2APIProtocol::Observation* ResponseObservation::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseObservation.observation)
  clear_has_observation();
  ::SC2APIProtocol::Observation* temp = observation_;
  observation_ = NULL;
  return temp;
}
inline void ResponseObservation::set_allocated_observation(::SC2APIProtocol::Observation* observation) {
  delete observation_;
  observation_ = observation;
  if (observation) {
    set_has_observation();
  } else {
    clear_has_observation();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseObservation.observation)
}

// repeated .SC2APIProtocol.PlayerResult player_result = 4;
inline int ResponseObservation::player_result_size() const {
  return player_result_.size();
}
inline void ResponseObservation::clear_player_result() {
  player_result_.Clear();
}
inline const ::SC2APIProtocol::PlayerResult& ResponseObservation::player_result(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_.Get(index);
}
inline ::SC2APIProtocol::PlayerResult* ResponseObservation::mutable_player_result(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_.Mutable(index);
}
inline ::SC2APIProtocol::PlayerResult* ResponseObservation::add_player_result() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >*
ResponseObservation::mutable_player_result() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.player_result)
  return &player_result_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >&
ResponseObservation::player_result() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_;
}

// repeated .SC2APIProtocol.ChatReceived chat = 5;
inline int ResponseObservation::chat_size() const {
  return chat_.size();
}
inline void ResponseObservation::clear_chat() {
  chat_.Clear();
}
inline const ::SC2APIProtocol::ChatReceived& ResponseObservation::chat(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.chat)
  return chat_.Get(index);
}
inline ::SC2APIProtocol::ChatReceived* ResponseObservation::mutable_chat(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.chat)
  return chat_.Mutable(index);
}
inline ::SC2APIProtocol::ChatReceived* ResponseObservation::add_chat() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.chat)
  return chat_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >*
ResponseObservation::mutable_chat() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.chat)
  return &chat_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >&
ResponseObservation::chat() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.chat)
  return chat_;
}

// -------------------------------------------------------------------

// ChatReceived

// optional int32 player_id = 1;
inline bool ChatReceived::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReceived::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReceived::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReceived::clear_player_id() {
  player_id_ = 0;
  clear_has_player_id();
}
inline ::google::protobuf::int32 ChatReceived::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ChatReceived.player_id)
  return player_id_;
}
inline void ChatReceived::set_player_id(::google::protobuf::int32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ChatReceived.player_id)
}

// optional string message = 2;
inline bool ChatReceived::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReceived::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReceived::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReceived::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ChatReceived::message() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ChatReceived.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReceived::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ChatReceived.message)
}
inline void ChatReceived::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ChatReceived.message)
}
inline void ChatReceived::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ChatReceived.message)
}
inline ::std::string* ChatReceived::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ChatReceived.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatReceived::release_message() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ChatReceived.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReceived::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ChatReceived.message)
}

// -------------------------------------------------------------------

// RequestAction

// repeated .SC2APIProtocol.Action actions = 1;
inline int RequestAction::actions_size() const {
  return actions_.size();
}
inline void RequestAction::clear_actions() {
  actions_.Clear();
}
inline const ::SC2APIProtocol::Action& RequestAction::actions(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestAction.actions)
  return actions_.Get(index);
}
inline ::SC2APIProtocol::Action* RequestAction::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestAction.actions)
  return actions_.Mutable(index);
}
inline ::SC2APIProtocol::Action* RequestAction::add_actions() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestAction.actions)
  return actions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >*
RequestAction::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestAction.actions)
  return &actions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >&
RequestAction::actions() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestAction.actions)
  return actions_;
}

// -------------------------------------------------------------------

// ResponseAction

// repeated .SC2APIProtocol.ActionResult result = 1;
inline int ResponseAction::result_size() const {
  return result_.size();
}
inline void ResponseAction::clear_result() {
  result_.Clear();
}
inline ::SC2APIProtocol::ActionResult ResponseAction::result(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAction.result)
  return static_cast< ::SC2APIProtocol::ActionResult >(result_.Get(index));
}
inline void ResponseAction::set_result(int index, ::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  result_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAction.result)
}
inline void ResponseAction::add_result(::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  result_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAction.result)
}
inline const ::google::protobuf::RepeatedField<int>&
ResponseAction::result() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAction.result)
  return result_;
}
inline ::google::protobuf::RepeatedField<int>*
ResponseAction::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAction.result)
  return &result_;
}

// -------------------------------------------------------------------

// RequestStep

// optional uint32 count = 1;
inline bool RequestStep::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStep::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStep::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStep::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RequestStep::count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStep.count)
  return count_;
}
inline void RequestStep::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStep.count)
}

// -------------------------------------------------------------------

// ResponseStep

// -------------------------------------------------------------------

// RequestData

// optional bool ability_id = 1;
inline bool RequestData::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestData::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestData::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestData::clear_ability_id() {
  ability_id_ = false;
  clear_has_ability_id();
}
inline bool RequestData::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.ability_id)
  return ability_id_;
}
inline void RequestData::set_ability_id(bool value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.ability_id)
}

// optional bool unit_type_id = 2;
inline bool RequestData::has_unit_type_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestData::set_has_unit_type_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestData::clear_has_unit_type_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestData::clear_unit_type_id() {
  unit_type_id_ = false;
  clear_has_unit_type_id();
}
inline bool RequestData::unit_type_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.unit_type_id)
  return unit_type_id_;
}
inline void RequestData::set_unit_type_id(bool value) {
  set_has_unit_type_id();
  unit_type_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.unit_type_id)
}

// optional bool upgrade_id = 3;
inline bool RequestData::has_upgrade_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestData::set_has_upgrade_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestData::clear_has_upgrade_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestData::clear_upgrade_id() {
  upgrade_id_ = false;
  clear_has_upgrade_id();
}
inline bool RequestData::upgrade_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.upgrade_id)
  return upgrade_id_;
}
inline void RequestData::set_upgrade_id(bool value) {
  set_has_upgrade_id();
  upgrade_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.upgrade_id)
}

// optional bool buff_id = 4;
inline bool RequestData::has_buff_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestData::set_has_buff_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestData::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestData::clear_buff_id() {
  buff_id_ = false;
  clear_has_buff_id();
}
inline bool RequestData::buff_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.buff_id)
  return buff_id_;
}
inline void RequestData::set_buff_id(bool value) {
  set_has_buff_id();
  buff_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.buff_id)
}

// -------------------------------------------------------------------

// ResponseData

// repeated .SC2APIProtocol.AbilityData abilities = 1;
inline int ResponseData::abilities_size() const {
  return abilities_.size();
}
inline void ResponseData::clear_abilities() {
  abilities_.Clear();
}
inline const ::SC2APIProtocol::AbilityData& ResponseData::abilities(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.abilities)
  return abilities_.Get(index);
}
inline ::SC2APIProtocol::AbilityData* ResponseData::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.abilities)
  return abilities_.Mutable(index);
}
inline ::SC2APIProtocol::AbilityData* ResponseData::add_abilities() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.abilities)
  return abilities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData >*
ResponseData::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.abilities)
  return &abilities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData >&
ResponseData::abilities() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.abilities)
  return abilities_;
}

// repeated .SC2APIProtocol.UnitTypeData units = 2;
inline int ResponseData::units_size() const {
  return units_.size();
}
inline void ResponseData::clear_units() {
  units_.Clear();
}
inline const ::SC2APIProtocol::UnitTypeData& ResponseData::units(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.units)
  return units_.Get(index);
}
inline ::SC2APIProtocol::UnitTypeData* ResponseData::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.units)
  return units_.Mutable(index);
}
inline ::SC2APIProtocol::UnitTypeData* ResponseData::add_units() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.units)
  return units_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >*
ResponseData::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.units)
  return &units_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >&
ResponseData::units() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.units)
  return units_;
}

// repeated .SC2APIProtocol.UpgradeData upgrades = 3;
inline int ResponseData::upgrades_size() const {
  return upgrades_.size();
}
inline void ResponseData::clear_upgrades() {
  upgrades_.Clear();
}
inline const ::SC2APIProtocol::UpgradeData& ResponseData::upgrades(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_.Get(index);
}
inline ::SC2APIProtocol::UpgradeData* ResponseData::mutable_upgrades(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_.Mutable(index);
}
inline ::SC2APIProtocol::UpgradeData* ResponseData::add_upgrades() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >*
ResponseData::mutable_upgrades() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.upgrades)
  return &upgrades_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >&
ResponseData::upgrades() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_;
}

// repeated .SC2APIProtocol.BuffData buffs = 4;
inline int ResponseData::buffs_size() const {
  return buffs_.size();
}
inline void ResponseData::clear_buffs() {
  buffs_.Clear();
}
inline const ::SC2APIProtocol::BuffData& ResponseData::buffs(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.buffs)
  return buffs_.Get(index);
}
inline ::SC2APIProtocol::BuffData* ResponseData::mutable_buffs(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.buffs)
  return buffs_.Mutable(index);
}
inline ::SC2APIProtocol::BuffData* ResponseData::add_buffs() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.buffs)
  return buffs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData >*
ResponseData::mutable_buffs() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.buffs)
  return &buffs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData >&
ResponseData::buffs() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.buffs)
  return buffs_;
}

// -------------------------------------------------------------------

// RequestSaveReplay

// -------------------------------------------------------------------

// ResponseSaveReplay

// optional bytes data = 1;
inline bool ResponseSaveReplay::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSaveReplay::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSaveReplay::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSaveReplay::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ResponseSaveReplay::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseSaveReplay.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSaveReplay::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseSaveReplay.data)
}
inline void ResponseSaveReplay::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseSaveReplay.data)
}
inline void ResponseSaveReplay::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseSaveReplay.data)
}
inline ::std::string* ResponseSaveReplay::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseSaveReplay.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSaveReplay::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseSaveReplay.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSaveReplay::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseSaveReplay.data)
}

// -------------------------------------------------------------------

// RequestReplayInfo

// optional string replay_path = 1;
inline bool RequestReplayInfo::has_replay_path() const {
  return replay_case() == kReplayPath;
}
inline void RequestReplayInfo::set_has_replay_path() {
  _oneof_case_[0] = kReplayPath;
}
inline void RequestReplayInfo::clear_replay_path() {
  if (has_replay_path()) {
    replay_.replay_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestReplayInfo::replay_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (has_replay_path()) {
    return replay_.replay_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestReplayInfo::set_replay_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline void RequestReplayInfo::set_replay_path(const char* value) {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline void RequestReplayInfo::set_replay_path(const char* value, size_t size) {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline ::std::string* RequestReplayInfo::mutable_replay_path() {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestReplayInfo.replay_path)
  return replay_.replay_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestReplayInfo::release_replay_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (has_replay_path()) {
    clear_has_replay();
    return replay_.replay_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestReplayInfo::set_allocated_replay_path(::std::string* replay_path) {
  if (!has_replay_path()) {
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_path != NULL) {
    set_has_replay_path();
    replay_.replay_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        replay_path);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestReplayInfo.replay_path)
}

// optional bytes replay_data = 2;
inline bool RequestReplayInfo::has_replay_data() const {
  return replay_case() == kReplayData;
}
inline void RequestReplayInfo::set_has_replay_data() {
  _oneof_case_[0] = kReplayData;
}
inline void RequestReplayInfo::clear_replay_data() {
  if (has_replay_data()) {
    replay_.replay_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestReplayInfo::replay_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (has_replay_data()) {
    return replay_.replay_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestReplayInfo::set_replay_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline void RequestReplayInfo::set_replay_data(const char* value) {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline void RequestReplayInfo::set_replay_data(const void* value, size_t size) {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline ::std::string* RequestReplayInfo::mutable_replay_data() {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestReplayInfo.replay_data)
  return replay_.replay_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestReplayInfo::release_replay_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (has_replay_data()) {
    clear_has_replay();
    return replay_.replay_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestReplayInfo::set_allocated_replay_data(::std::string* replay_data) {
  if (!has_replay_data()) {
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_data != NULL) {
    set_has_replay_data();
    replay_.replay_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        replay_data);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestReplayInfo.replay_data)
}

// optional bool download_data = 3;
inline bool RequestReplayInfo::has_download_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestReplayInfo::set_has_download_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestReplayInfo::clear_has_download_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestReplayInfo::clear_download_data() {
  download_data_ = false;
  clear_has_download_data();
}
inline bool RequestReplayInfo::download_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.download_data)
  return download_data_;
}
inline void RequestReplayInfo::set_download_data(bool value) {
  set_has_download_data();
  download_data_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.download_data)
}

inline bool RequestReplayInfo::has_replay() const {
  return replay_case() != REPLAY_NOT_SET;
}
inline void RequestReplayInfo::clear_has_replay() {
  _oneof_case_[0] = REPLAY_NOT_SET;
}
inline RequestReplayInfo::ReplayCase RequestReplayInfo::replay_case() const {
  return RequestReplayInfo::ReplayCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerInfoExtra

// optional .SC2APIProtocol.PlayerInfo player_info = 1;
inline bool PlayerInfoExtra::has_player_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoExtra::set_has_player_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoExtra::clear_has_player_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoExtra::clear_player_info() {
  if (player_info_ != NULL) player_info_->::SC2APIProtocol::PlayerInfo::Clear();
  clear_has_player_info();
}
inline const ::SC2APIProtocol::PlayerInfo& PlayerInfoExtra::player_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_info)
  return player_info_ != NULL ? *player_info_ : *default_instance_->player_info_;
}
inline ::SC2APIProtocol::PlayerInfo* PlayerInfoExtra::mutable_player_info() {
  set_has_player_info();
  if (player_info_ == NULL) {
    player_info_ = new ::SC2APIProtocol::PlayerInfo;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerInfoExtra.player_info)
  return player_info_;
}
inline ::SC2APIProtocol::PlayerInfo* PlayerInfoExtra::release_player_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerInfoExtra.player_info)
  clear_has_player_info();
  ::SC2APIProtocol::PlayerInfo* temp = player_info_;
  player_info_ = NULL;
  return temp;
}
inline void PlayerInfoExtra::set_allocated_player_info(::SC2APIProtocol::PlayerInfo* player_info) {
  delete player_info_;
  player_info_ = player_info;
  if (player_info) {
    set_has_player_info();
  } else {
    clear_has_player_info();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerInfoExtra.player_info)
}

// optional .SC2APIProtocol.PlayerResult player_result = 2;
inline bool PlayerInfoExtra::has_player_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoExtra::set_has_player_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoExtra::clear_has_player_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoExtra::clear_player_result() {
  if (player_result_ != NULL) player_result_->::SC2APIProtocol::PlayerResult::Clear();
  clear_has_player_result();
}
inline const ::SC2APIProtocol::PlayerResult& PlayerInfoExtra::player_result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_result)
  return player_result_ != NULL ? *player_result_ : *default_instance_->player_result_;
}
inline ::SC2APIProtocol::PlayerResult* PlayerInfoExtra::mutable_player_result() {
  set_has_player_result();
  if (player_result_ == NULL) {
    player_result_ = new ::SC2APIProtocol::PlayerResult;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerInfoExtra.player_result)
  return player_result_;
}
inline ::SC2APIProtocol::PlayerResult* PlayerInfoExtra::release_player_result() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerInfoExtra.player_result)
  clear_has_player_result();
  ::SC2APIProtocol::PlayerResult* temp = player_result_;
  player_result_ = NULL;
  return temp;
}
inline void PlayerInfoExtra::set_allocated_player_result(::SC2APIProtocol::PlayerResult* player_result) {
  delete player_result_;
  player_result_ = player_result;
  if (player_result) {
    set_has_player_result();
  } else {
    clear_has_player_result();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerInfoExtra.player_result)
}

// optional int32 player_mmr = 3;
inline bool PlayerInfoExtra::has_player_mmr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfoExtra::set_has_player_mmr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfoExtra::clear_has_player_mmr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfoExtra::clear_player_mmr() {
  player_mmr_ = 0;
  clear_has_player_mmr();
}
inline ::google::protobuf::int32 PlayerInfoExtra::player_mmr() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_mmr)
  return player_mmr_;
}
inline void PlayerInfoExtra::set_player_mmr(::google::protobuf::int32 value) {
  set_has_player_mmr();
  player_mmr_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfoExtra.player_mmr)
}

// optional int32 player_apm = 4;
inline bool PlayerInfoExtra::has_player_apm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfoExtra::set_has_player_apm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfoExtra::clear_has_player_apm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfoExtra::clear_player_apm() {
  player_apm_ = 0;
  clear_has_player_apm();
}
inline ::google::protobuf::int32 PlayerInfoExtra::player_apm() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_apm)
  return player_apm_;
}
inline void PlayerInfoExtra::set_player_apm(::google::protobuf::int32 value) {
  set_has_player_apm();
  player_apm_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfoExtra.player_apm)
}

// -------------------------------------------------------------------

// ResponseReplayInfo

// optional string map_name = 1;
inline bool ResponseReplayInfo::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseReplayInfo::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseReplayInfo::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseReplayInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& ResponseReplayInfo::map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.map_name)
  return map_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline void ResponseReplayInfo::set_map_name(const char* value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline void ResponseReplayInfo::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline ::std::string* ResponseReplayInfo::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.map_name)
  clear_has_map_name();
  return map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.map_name)
}

// optional string local_map_path = 2;
inline bool ResponseReplayInfo::has_local_map_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseReplayInfo::set_has_local_map_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseReplayInfo::clear_has_local_map_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseReplayInfo::clear_local_map_path() {
  local_map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_map_path();
}
inline const ::std::string& ResponseReplayInfo::local_map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  return local_map_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_local_map_path(const ::std::string& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline void ResponseReplayInfo::set_local_map_path(const char* value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline void ResponseReplayInfo::set_local_map_path(const char* value, size_t size) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline ::std::string* ResponseReplayInfo::mutable_local_map_path() {
  set_has_local_map_path();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  return local_map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_local_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  clear_has_local_map_path();
  return local_map_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_local_map_path(::std::string* local_map_path) {
  if (local_map_path != NULL) {
    set_has_local_map_path();
  } else {
    clear_has_local_map_path();
  }
  local_map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}

// repeated .SC2APIProtocol.PlayerInfoExtra player_info = 3;
inline int ResponseReplayInfo::player_info_size() const {
  return player_info_.size();
}
inline void ResponseReplayInfo::clear_player_info() {
  player_info_.Clear();
}
inline const ::SC2APIProtocol::PlayerInfoExtra& ResponseReplayInfo::player_info(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Get(index);
}
inline ::SC2APIProtocol::PlayerInfoExtra* ResponseReplayInfo::mutable_player_info(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Mutable(index);
}
inline ::SC2APIProtocol::PlayerInfoExtra* ResponseReplayInfo::add_player_info() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >*
ResponseReplayInfo::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseReplayInfo.player_info)
  return &player_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >&
ResponseReplayInfo::player_info() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_;
}

// optional uint32 game_duration_loops = 4;
inline bool ResponseReplayInfo::has_game_duration_loops() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseReplayInfo::set_has_game_duration_loops() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseReplayInfo::clear_has_game_duration_loops() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseReplayInfo::clear_game_duration_loops() {
  game_duration_loops_ = 0u;
  clear_has_game_duration_loops();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::game_duration_loops() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_duration_loops)
  return game_duration_loops_;
}
inline void ResponseReplayInfo::set_game_duration_loops(::google::protobuf::uint32 value) {
  set_has_game_duration_loops();
  game_duration_loops_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_duration_loops)
}

// optional float game_duration_seconds = 5;
inline bool ResponseReplayInfo::has_game_duration_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseReplayInfo::set_has_game_duration_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseReplayInfo::clear_has_game_duration_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseReplayInfo::clear_game_duration_seconds() {
  game_duration_seconds_ = 0;
  clear_has_game_duration_seconds();
}
inline float ResponseReplayInfo::game_duration_seconds() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_duration_seconds)
  return game_duration_seconds_;
}
inline void ResponseReplayInfo::set_game_duration_seconds(float value) {
  set_has_game_duration_seconds();
  game_duration_seconds_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_duration_seconds)
}

// optional string game_version = 6;
inline bool ResponseReplayInfo::has_game_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseReplayInfo::set_has_game_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseReplayInfo::clear_has_game_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseReplayInfo::clear_game_version() {
  game_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_version();
}
inline const ::std::string& ResponseReplayInfo::game_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_version)
  return game_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_game_version(const ::std::string& value) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline void ResponseReplayInfo::set_game_version(const char* value) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline void ResponseReplayInfo::set_game_version(const char* value, size_t size) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline ::std::string* ResponseReplayInfo::mutable_game_version() {
  set_has_game_version();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.game_version)
  return game_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_game_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.game_version)
  clear_has_game_version();
  return game_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_game_version(::std::string* game_version) {
  if (game_version != NULL) {
    set_has_game_version();
  } else {
    clear_has_game_version();
  }
  game_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.game_version)
}

// optional string data_version = 11;
inline bool ResponseReplayInfo::has_data_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseReplayInfo::set_has_data_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseReplayInfo::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseReplayInfo::clear_data_version() {
  data_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_version();
}
inline const ::std::string& ResponseReplayInfo::data_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.data_version)
  return data_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_data_version(const ::std::string& value) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline void ResponseReplayInfo::set_data_version(const char* value) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline void ResponseReplayInfo::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline ::std::string* ResponseReplayInfo::mutable_data_version() {
  set_has_data_version();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.data_version)
  return data_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_data_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.data_version)
  clear_has_data_version();
  return data_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_data_version(::std::string* data_version) {
  if (data_version != NULL) {
    set_has_data_version();
  } else {
    clear_has_data_version();
  }
  data_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.data_version)
}

// optional uint32 data_build = 7;
inline bool ResponseReplayInfo::has_data_build() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseReplayInfo::set_has_data_build() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseReplayInfo::clear_has_data_build() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseReplayInfo::clear_data_build() {
  data_build_ = 0u;
  clear_has_data_build();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::data_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.data_build)
  return data_build_;
}
inline void ResponseReplayInfo::set_data_build(::google::protobuf::uint32 value) {
  set_has_data_build();
  data_build_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.data_build)
}

// optional uint32 base_build = 8;
inline bool ResponseReplayInfo::has_base_build() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseReplayInfo::set_has_base_build() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseReplayInfo::clear_has_base_build() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseReplayInfo::clear_base_build() {
  base_build_ = 0u;
  clear_has_base_build();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::base_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.base_build)
  return base_build_;
}
inline void ResponseReplayInfo::set_base_build(::google::protobuf::uint32 value) {
  set_has_base_build();
  base_build_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.base_build)
}

// optional .SC2APIProtocol.ResponseReplayInfo.Error error = 9;
inline bool ResponseReplayInfo::has_error() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseReplayInfo::set_has_error() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseReplayInfo::clear_has_error() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseReplayInfo::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseReplayInfo_Error ResponseReplayInfo::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.error)
  return static_cast< ::SC2APIProtocol::ResponseReplayInfo_Error >(error_);
}
inline void ResponseReplayInfo::set_error(::SC2APIProtocol::ResponseReplayInfo_Error value) {
  assert(::SC2APIProtocol::ResponseReplayInfo_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.error)
}

// optional string error_details = 10;
inline bool ResponseReplayInfo::has_error_details() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResponseReplayInfo::set_has_error_details() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResponseReplayInfo::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResponseReplayInfo::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseReplayInfo::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.error_details)
  return error_details_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline void ResponseReplayInfo::set_error_details(const char* value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline void ResponseReplayInfo::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline ::std::string* ResponseReplayInfo::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.error_details)
  clear_has_error_details();
  return error_details_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.error_details)
}

// -------------------------------------------------------------------

// RequestAvailableMaps

// -------------------------------------------------------------------

// ResponseAvailableMaps

// repeated string local_map_paths = 1;
inline int ResponseAvailableMaps::local_map_paths_size() const {
  return local_map_paths_.size();
}
inline void ResponseAvailableMaps::clear_local_map_paths() {
  local_map_paths_.Clear();
}
inline const ::std::string& ResponseAvailableMaps::local_map_paths(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Get(index);
}
inline ::std::string* ResponseAvailableMaps::mutable_local_map_paths(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Mutable(index);
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  local_map_paths_.Mutable(index)->assign(value);
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const char* value) {
  local_map_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const char* value, size_t size) {
  local_map_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline ::std::string* ResponseAvailableMaps::add_local_map_paths() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Add();
}
inline void ResponseAvailableMaps::add_local_map_paths(const ::std::string& value) {
  local_map_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::add_local_map_paths(const char* value) {
  local_map_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::add_local_map_paths(const char* value, size_t size) {
  local_map_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseAvailableMaps::local_map_paths() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseAvailableMaps::mutable_local_map_paths() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return &local_map_paths_;
}

// repeated string battlenet_map_names = 2;
inline int ResponseAvailableMaps::battlenet_map_names_size() const {
  return battlenet_map_names_.size();
}
inline void ResponseAvailableMaps::clear_battlenet_map_names() {
  battlenet_map_names_.Clear();
}
inline const ::std::string& ResponseAvailableMaps::battlenet_map_names(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Get(index);
}
inline ::std::string* ResponseAvailableMaps::mutable_battlenet_map_names(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Mutable(index);
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  battlenet_map_names_.Mutable(index)->assign(value);
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const char* value) {
  battlenet_map_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const char* value, size_t size) {
  battlenet_map_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline ::std::string* ResponseAvailableMaps::add_battlenet_map_names() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Add();
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const ::std::string& value) {
  battlenet_map_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const char* value) {
  battlenet_map_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const char* value, size_t size) {
  battlenet_map_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseAvailableMaps::battlenet_map_names() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseAvailableMaps::mutable_battlenet_map_names() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return &battlenet_map_names_;
}

// -------------------------------------------------------------------

// RequestSaveMap

// optional string map_path = 1;
inline bool RequestSaveMap::has_map_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSaveMap::set_has_map_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSaveMap::clear_has_map_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSaveMap::clear_map_path() {
  map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_path();
}
inline const ::std::string& RequestSaveMap::map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestSaveMap.map_path)
  return map_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_map_path(const ::std::string& value) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestSaveMap.map_path)
}
inline void RequestSaveMap::set_map_path(const char* value) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestSaveMap.map_path)
}
inline void RequestSaveMap::set_map_path(const char* value, size_t size) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestSaveMap.map_path)
}
inline ::std::string* RequestSaveMap::mutable_map_path() {
  set_has_map_path();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestSaveMap.map_path)
  return map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSaveMap::release_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestSaveMap.map_path)
  clear_has_map_path();
  return map_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_allocated_map_path(::std::string* map_path) {
  if (map_path != NULL) {
    set_has_map_path();
  } else {
    clear_has_map_path();
  }
  map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestSaveMap.map_path)
}

// optional bytes map_data = 2;
inline bool RequestSaveMap::has_map_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSaveMap::set_has_map_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSaveMap::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSaveMap::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& RequestSaveMap::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestSaveMap.map_data)
  return map_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestSaveMap.map_data)
}
inline void RequestSaveMap::set_map_data(const char* value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestSaveMap.map_data)
}
inline void RequestSaveMap::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestSaveMap.map_data)
}
inline ::std::string* RequestSaveMap::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestSaveMap.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSaveMap::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestSaveMap.map_data)
  clear_has_map_data();
  return map_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestSaveMap.map_data)
}

// -------------------------------------------------------------------

// ResponseSaveMap

// optional .SC2APIProtocol.ResponseSaveMap.Error error = 1;
inline bool ResponseSaveMap::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSaveMap::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSaveMap::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSaveMap::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseSaveMap_Error ResponseSaveMap::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseSaveMap.error)
  return static_cast< ::SC2APIProtocol::ResponseSaveMap_Error >(error_);
}
inline void ResponseSaveMap::set_error(::SC2APIProtocol::ResponseSaveMap_Error value) {
  assert(::SC2APIProtocol::ResponseSaveMap_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseSaveMap.error)
}

// -------------------------------------------------------------------

// RequestPing

// -------------------------------------------------------------------

// ResponsePing

// optional string game_version = 1;
inline bool ResponsePing::has_game_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponsePing::set_has_game_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponsePing::clear_has_game_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponsePing::clear_game_version() {
  game_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_version();
}
inline const ::std::string& ResponsePing::game_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.game_version)
  return game_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_game_version(const ::std::string& value) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.game_version)
}
inline void ResponsePing::set_game_version(const char* value) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponsePing.game_version)
}
inline void ResponsePing::set_game_version(const char* value, size_t size) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponsePing.game_version)
}
inline ::std::string* ResponsePing::mutable_game_version() {
  set_has_game_version();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponsePing.game_version)
  return game_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponsePing::release_game_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponsePing.game_version)
  clear_has_game_version();
  return game_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_allocated_game_version(::std::string* game_version) {
  if (game_version != NULL) {
    set_has_game_version();
  } else {
    clear_has_game_version();
  }
  game_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponsePing.game_version)
}

// optional string data_version = 2;
inline bool ResponsePing::has_data_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponsePing::set_has_data_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponsePing::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponsePing::clear_data_version() {
  data_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_version();
}
inline const ::std::string& ResponsePing::data_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.data_version)
  return data_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_data_version(const ::std::string& value) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.data_version)
}
inline void ResponsePing::set_data_version(const char* value) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponsePing.data_version)
}
inline void ResponsePing::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponsePing.data_version)
}
inline ::std::string* ResponsePing::mutable_data_version() {
  set_has_data_version();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponsePing.data_version)
  return data_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponsePing::release_data_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponsePing.data_version)
  clear_has_data_version();
  return data_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_allocated_data_version(::std::string* data_version) {
  if (data_version != NULL) {
    set_has_data_version();
  } else {
    clear_has_data_version();
  }
  data_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponsePing.data_version)
}

// optional uint32 data_build = 3;
inline bool ResponsePing::has_data_build() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponsePing::set_has_data_build() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponsePing::clear_has_data_build() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponsePing::clear_data_build() {
  data_build_ = 0u;
  clear_has_data_build();
}
inline ::google::protobuf::uint32 ResponsePing::data_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.data_build)
  return data_build_;
}
inline void ResponsePing::set_data_build(::google::protobuf::uint32 value) {
  set_has_data_build();
  data_build_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.data_build)
}

// optional uint32 base_build = 4;
inline bool ResponsePing::has_base_build() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponsePing::set_has_base_build() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponsePing::clear_has_base_build() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponsePing::clear_base_build() {
  base_build_ = 0u;
  clear_has_base_build();
}
inline ::google::protobuf::uint32 ResponsePing::base_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.base_build)
  return base_build_;
}
inline void ResponsePing::set_base_build(::google::protobuf::uint32 value) {
  set_has_base_build();
  base_build_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.base_build)
}

// -------------------------------------------------------------------

// RequestDebug

// repeated .SC2APIProtocol.DebugCommand debug = 1;
inline int RequestDebug::debug_size() const {
  return debug_.size();
}
inline void RequestDebug::clear_debug() {
  debug_.Clear();
}
inline const ::SC2APIProtocol::DebugCommand& RequestDebug::debug(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestDebug.debug)
  return debug_.Get(index);
}
inline ::SC2APIProtocol::DebugCommand* RequestDebug::mutable_debug(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestDebug.debug)
  return debug_.Mutable(index);
}
inline ::SC2APIProtocol::DebugCommand* RequestDebug::add_debug() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestDebug.debug)
  return debug_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >*
RequestDebug::mutable_debug() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestDebug.debug)
  return &debug_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >&
RequestDebug::debug() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestDebug.debug)
  return debug_;
}

// -------------------------------------------------------------------

// ResponseDebug

// -------------------------------------------------------------------

// PlayerSetup

// optional .SC2APIProtocol.PlayerType type = 1;
inline bool PlayerSetup::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSetup::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSetup::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSetup::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SC2APIProtocol::PlayerType PlayerSetup::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.type)
  return static_cast< ::SC2APIProtocol::PlayerType >(type_);
}
inline void PlayerSetup::set_type(::SC2APIProtocol::PlayerType value) {
  assert(::SC2APIProtocol::PlayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.type)
}

// optional .SC2APIProtocol.Race race = 2;
inline bool PlayerSetup::has_race() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerSetup::set_has_race() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerSetup::clear_has_race() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerSetup::clear_race() {
  race_ = 0;
  clear_has_race();
}
inline ::SC2APIProtocol::Race PlayerSetup::race() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.race)
  return static_cast< ::SC2APIProtocol::Race >(race_);
}
inline void PlayerSetup::set_race(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  set_has_race();
  race_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.race)
}

// optional .SC2APIProtocol.Difficulty difficulty = 3;
inline bool PlayerSetup::has_difficulty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerSetup::set_has_difficulty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerSetup::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerSetup::clear_difficulty() {
  difficulty_ = 1;
  clear_has_difficulty();
}
inline ::SC2APIProtocol::Difficulty PlayerSetup::difficulty() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.difficulty)
  return static_cast< ::SC2APIProtocol::Difficulty >(difficulty_);
}
inline void PlayerSetup::set_difficulty(::SC2APIProtocol::Difficulty value) {
  assert(::SC2APIProtocol::Difficulty_IsValid(value));
  set_has_difficulty();
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.difficulty)
}

// -------------------------------------------------------------------

// SpatialCameraSetup

// optional float width = 1;
inline bool SpatialCameraSetup::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpatialCameraSetup::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpatialCameraSetup::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpatialCameraSetup::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float SpatialCameraSetup::width() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.width)
  return width_;
}
inline void SpatialCameraSetup::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.SpatialCameraSetup.width)
}

// optional .SC2APIProtocol.Size2DI resolution = 2;
inline bool SpatialCameraSetup::has_resolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpatialCameraSetup::set_has_resolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpatialCameraSetup::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpatialCameraSetup::clear_resolution() {
  if (resolution_ != NULL) resolution_->::SC2APIProtocol::Size2DI::Clear();
  clear_has_resolution();
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::resolution() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.resolution)
  return resolution_ != NULL ? *resolution_ : *default_instance_->resolution_;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == NULL) {
    resolution_ = new ::SC2APIProtocol::Size2DI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.SpatialCameraSetup.resolution)
  return resolution_;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::release_resolution() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.SpatialCameraSetup.resolution)
  clear_has_resolution();
  ::SC2APIProtocol::Size2DI* temp = resolution_;
  resolution_ = NULL;
  return temp;
}
inline void SpatialCameraSetup::set_allocated_resolution(::SC2APIProtocol::Size2DI* resolution) {
  delete resolution_;
  resolution_ = resolution;
  if (resolution) {
    set_has_resolution();
  } else {
    clear_has_resolution();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.SpatialCameraSetup.resolution)
}

// optional .SC2APIProtocol.Size2DI minimap_resolution = 3;
inline bool SpatialCameraSetup::has_minimap_resolution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpatialCameraSetup::set_has_minimap_resolution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpatialCameraSetup::clear_has_minimap_resolution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpatialCameraSetup::clear_minimap_resolution() {
  if (minimap_resolution_ != NULL) minimap_resolution_->::SC2APIProtocol::Size2DI::Clear();
  clear_has_minimap_resolution();
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::minimap_resolution() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  return minimap_resolution_ != NULL ? *minimap_resolution_ : *default_instance_->minimap_resolution_;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::mutable_minimap_resolution() {
  set_has_minimap_resolution();
  if (minimap_resolution_ == NULL) {
    minimap_resolution_ = new ::SC2APIProtocol::Size2DI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  return minimap_resolution_;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::release_minimap_resolution() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  clear_has_minimap_resolution();
  ::SC2APIProtocol::Size2DI* temp = minimap_resolution_;
  minimap_resolution_ = NULL;
  return temp;
}
inline void SpatialCameraSetup::set_allocated_minimap_resolution(::SC2APIProtocol::Size2DI* minimap_resolution) {
  delete minimap_resolution_;
  minimap_resolution_ = minimap_resolution;
  if (minimap_resolution) {
    set_has_minimap_resolution();
  } else {
    clear_has_minimap_resolution();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
}

// -------------------------------------------------------------------

// InterfaceOptions

// optional bool raw = 1;
inline bool InterfaceOptions::has_raw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterfaceOptions::set_has_raw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterfaceOptions::clear_has_raw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterfaceOptions::clear_raw() {
  raw_ = false;
  clear_has_raw();
}
inline bool InterfaceOptions::raw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.raw)
  return raw_;
}
inline void InterfaceOptions::set_raw(bool value) {
  set_has_raw();
  raw_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.raw)
}

// optional bool score = 2;
inline bool InterfaceOptions::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterfaceOptions::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterfaceOptions::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterfaceOptions::clear_score() {
  score_ = false;
  clear_has_score();
}
inline bool InterfaceOptions::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.score)
  return score_;
}
inline void InterfaceOptions::set_score(bool value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.score)
}

// optional .SC2APIProtocol.SpatialCameraSetup feature_layer = 3;
inline bool InterfaceOptions::has_feature_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InterfaceOptions::set_has_feature_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InterfaceOptions::clear_has_feature_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InterfaceOptions::clear_feature_layer() {
  if (feature_layer_ != NULL) feature_layer_->::SC2APIProtocol::SpatialCameraSetup::Clear();
  clear_has_feature_layer();
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::feature_layer() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.feature_layer)
  return feature_layer_ != NULL ? *feature_layer_ : *default_instance_->feature_layer_;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::mutable_feature_layer() {
  set_has_feature_layer();
  if (feature_layer_ == NULL) {
    feature_layer_ = new ::SC2APIProtocol::SpatialCameraSetup;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.InterfaceOptions.feature_layer)
  return feature_layer_;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::release_feature_layer() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.InterfaceOptions.feature_layer)
  clear_has_feature_layer();
  ::SC2APIProtocol::SpatialCameraSetup* temp = feature_layer_;
  feature_layer_ = NULL;
  return temp;
}
inline void InterfaceOptions::set_allocated_feature_layer(::SC2APIProtocol::SpatialCameraSetup* feature_layer) {
  delete feature_layer_;
  feature_layer_ = feature_layer;
  if (feature_layer) {
    set_has_feature_layer();
  } else {
    clear_has_feature_layer();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.InterfaceOptions.feature_layer)
}

// optional .SC2APIProtocol.SpatialCameraSetup render = 4;
inline bool InterfaceOptions::has_render() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InterfaceOptions::set_has_render() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InterfaceOptions::clear_has_render() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InterfaceOptions::clear_render() {
  if (render_ != NULL) render_->::SC2APIProtocol::SpatialCameraSetup::Clear();
  clear_has_render();
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::render() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.render)
  return render_ != NULL ? *render_ : *default_instance_->render_;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::mutable_render() {
  set_has_render();
  if (render_ == NULL) {
    render_ = new ::SC2APIProtocol::SpatialCameraSetup;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.InterfaceOptions.render)
  return render_;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::release_render() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.InterfaceOptions.render)
  clear_has_render();
  ::SC2APIProtocol::SpatialCameraSetup* temp = render_;
  render_ = NULL;
  return temp;
}
inline void InterfaceOptions::set_allocated_render(::SC2APIProtocol::SpatialCameraSetup* render) {
  delete render_;
  render_ = render;
  if (render) {
    set_has_render();
  } else {
    clear_has_render();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.InterfaceOptions.render)
}

// -------------------------------------------------------------------

// PlayerInfo

// optional uint32 player_id = 1;
inline bool PlayerInfo::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfo::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerInfo::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.player_id)
  return player_id_;
}
inline void PlayerInfo::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.player_id)
}

// optional .SC2APIProtocol.PlayerType type = 2;
inline bool PlayerInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SC2APIProtocol::PlayerType PlayerInfo::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.type)
  return static_cast< ::SC2APIProtocol::PlayerType >(type_);
}
inline void PlayerInfo::set_type(::SC2APIProtocol::PlayerType value) {
  assert(::SC2APIProtocol::PlayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.type)
}

// optional .SC2APIProtocol.Race race_requested = 3;
inline bool PlayerInfo::has_race_requested() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_race_requested() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_race_requested() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfo::clear_race_requested() {
  race_requested_ = 0;
  clear_has_race_requested();
}
inline ::SC2APIProtocol::Race PlayerInfo::race_requested() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.race_requested)
  return static_cast< ::SC2APIProtocol::Race >(race_requested_);
}
inline void PlayerInfo::set_race_requested(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  set_has_race_requested();
  race_requested_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.race_requested)
}

// optional .SC2APIProtocol.Race race_actual = 4;
inline bool PlayerInfo::has_race_actual() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_race_actual() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_race_actual() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfo::clear_race_actual() {
  race_actual_ = 0;
  clear_has_race_actual();
}
inline ::SC2APIProtocol::Race PlayerInfo::race_actual() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.race_actual)
  return static_cast< ::SC2APIProtocol::Race >(race_actual_);
}
inline void PlayerInfo::set_race_actual(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  set_has_race_actual();
  race_actual_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.race_actual)
}

// optional .SC2APIProtocol.Difficulty difficulty = 5;
inline bool PlayerInfo::has_difficulty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_difficulty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfo::clear_difficulty() {
  difficulty_ = 1;
  clear_has_difficulty();
}
inline ::SC2APIProtocol::Difficulty PlayerInfo::difficulty() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.difficulty)
  return static_cast< ::SC2APIProtocol::Difficulty >(difficulty_);
}
inline void PlayerInfo::set_difficulty(::SC2APIProtocol::Difficulty value) {
  assert(::SC2APIProtocol::Difficulty_IsValid(value));
  set_has_difficulty();
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.difficulty)
}

// -------------------------------------------------------------------

// PlayerCommon

// optional uint32 player_id = 1;
inline bool PlayerCommon::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCommon::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCommon::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCommon::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerCommon::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.player_id)
  return player_id_;
}
inline void PlayerCommon::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.player_id)
}

// optional uint32 minerals = 2;
inline bool PlayerCommon::has_minerals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCommon::set_has_minerals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCommon::clear_has_minerals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCommon::clear_minerals() {
  minerals_ = 0u;
  clear_has_minerals();
}
inline ::google::protobuf::uint32 PlayerCommon::minerals() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.minerals)
  return minerals_;
}
inline void PlayerCommon::set_minerals(::google::protobuf::uint32 value) {
  set_has_minerals();
  minerals_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.minerals)
}

// optional uint32 vespene = 3;
inline bool PlayerCommon::has_vespene() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerCommon::set_has_vespene() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerCommon::clear_has_vespene() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerCommon::clear_vespene() {
  vespene_ = 0u;
  clear_has_vespene();
}
inline ::google::protobuf::uint32 PlayerCommon::vespene() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.vespene)
  return vespene_;
}
inline void PlayerCommon::set_vespene(::google::protobuf::uint32 value) {
  set_has_vespene();
  vespene_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.vespene)
}

// optional uint32 food_cap = 4;
inline bool PlayerCommon::has_food_cap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerCommon::set_has_food_cap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerCommon::clear_has_food_cap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerCommon::clear_food_cap() {
  food_cap_ = 0u;
  clear_has_food_cap();
}
inline ::google::protobuf::uint32 PlayerCommon::food_cap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_cap)
  return food_cap_;
}
inline void PlayerCommon::set_food_cap(::google::protobuf::uint32 value) {
  set_has_food_cap();
  food_cap_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_cap)
}

// optional uint32 food_used = 5;
inline bool PlayerCommon::has_food_used() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerCommon::set_has_food_used() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerCommon::clear_has_food_used() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerCommon::clear_food_used() {
  food_used_ = 0u;
  clear_has_food_used();
}
inline ::google::protobuf::uint32 PlayerCommon::food_used() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_used)
  return food_used_;
}
inline void PlayerCommon::set_food_used(::google::protobuf::uint32 value) {
  set_has_food_used();
  food_used_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_used)
}

// optional uint32 food_army = 6;
inline bool PlayerCommon::has_food_army() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerCommon::set_has_food_army() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerCommon::clear_has_food_army() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerCommon::clear_food_army() {
  food_army_ = 0u;
  clear_has_food_army();
}
inline ::google::protobuf::uint32 PlayerCommon::food_army() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_army)
  return food_army_;
}
inline void PlayerCommon::set_food_army(::google::protobuf::uint32 value) {
  set_has_food_army();
  food_army_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_army)
}

// optional uint32 food_workers = 7;
inline bool PlayerCommon::has_food_workers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerCommon::set_has_food_workers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerCommon::clear_has_food_workers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerCommon::clear_food_workers() {
  food_workers_ = 0u;
  clear_has_food_workers();
}
inline ::google::protobuf::uint32 PlayerCommon::food_workers() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_workers)
  return food_workers_;
}
inline void PlayerCommon::set_food_workers(::google::protobuf::uint32 value) {
  set_has_food_workers();
  food_workers_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_workers)
}

// optional uint32 idle_worker_count = 8;
inline bool PlayerCommon::has_idle_worker_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerCommon::set_has_idle_worker_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerCommon::clear_has_idle_worker_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerCommon::clear_idle_worker_count() {
  idle_worker_count_ = 0u;
  clear_has_idle_worker_count();
}
inline ::google::protobuf::uint32 PlayerCommon::idle_worker_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.idle_worker_count)
  return idle_worker_count_;
}
inline void PlayerCommon::set_idle_worker_count(::google::protobuf::uint32 value) {
  set_has_idle_worker_count();
  idle_worker_count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.idle_worker_count)
}

// optional uint32 army_count = 9;
inline bool PlayerCommon::has_army_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerCommon::set_has_army_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerCommon::clear_has_army_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerCommon::clear_army_count() {
  army_count_ = 0u;
  clear_has_army_count();
}
inline ::google::protobuf::uint32 PlayerCommon::army_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.army_count)
  return army_count_;
}
inline void PlayerCommon::set_army_count(::google::protobuf::uint32 value) {
  set_has_army_count();
  army_count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.army_count)
}

// optional uint32 warp_gate_count = 10;
inline bool PlayerCommon::has_warp_gate_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerCommon::set_has_warp_gate_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerCommon::clear_has_warp_gate_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerCommon::clear_warp_gate_count() {
  warp_gate_count_ = 0u;
  clear_has_warp_gate_count();
}
inline ::google::protobuf::uint32 PlayerCommon::warp_gate_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.warp_gate_count)
  return warp_gate_count_;
}
inline void PlayerCommon::set_warp_gate_count(::google::protobuf::uint32 value) {
  set_has_warp_gate_count();
  warp_gate_count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.warp_gate_count)
}

// optional uint32 larva_count = 11;
inline bool PlayerCommon::has_larva_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerCommon::set_has_larva_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerCommon::clear_has_larva_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerCommon::clear_larva_count() {
  larva_count_ = 0u;
  clear_has_larva_count();
}
inline ::google::protobuf::uint32 PlayerCommon::larva_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.larva_count)
  return larva_count_;
}
inline void PlayerCommon::set_larva_count(::google::protobuf::uint32 value) {
  set_has_larva_count();
  larva_count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.larva_count)
}

// -------------------------------------------------------------------

// Observation

// optional uint32 game_loop = 9;
inline bool Observation::has_game_loop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Observation::set_has_game_loop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Observation::clear_has_game_loop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Observation::clear_game_loop() {
  game_loop_ = 0u;
  clear_has_game_loop();
}
inline ::google::protobuf::uint32 Observation::game_loop() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.game_loop)
  return game_loop_;
}
inline void Observation::set_game_loop(::google::protobuf::uint32 value) {
  set_has_game_loop();
  game_loop_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Observation.game_loop)
}

// optional .SC2APIProtocol.PlayerCommon player_common = 1;
inline bool Observation::has_player_common() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Observation::set_has_player_common() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Observation::clear_has_player_common() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Observation::clear_player_common() {
  if (player_common_ != NULL) player_common_->::SC2APIProtocol::PlayerCommon::Clear();
  clear_has_player_common();
}
inline const ::SC2APIProtocol::PlayerCommon& Observation::player_common() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.player_common)
  return player_common_ != NULL ? *player_common_ : *default_instance_->player_common_;
}
inline ::SC2APIProtocol::PlayerCommon* Observation::mutable_player_common() {
  set_has_player_common();
  if (player_common_ == NULL) {
    player_common_ = new ::SC2APIProtocol::PlayerCommon;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.player_common)
  return player_common_;
}
inline ::SC2APIProtocol::PlayerCommon* Observation::release_player_common() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.player_common)
  clear_has_player_common();
  ::SC2APIProtocol::PlayerCommon* temp = player_common_;
  player_common_ = NULL;
  return temp;
}
inline void Observation::set_allocated_player_common(::SC2APIProtocol::PlayerCommon* player_common) {
  delete player_common_;
  player_common_ = player_common;
  if (player_common) {
    set_has_player_common();
  } else {
    clear_has_player_common();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.player_common)
}

// repeated .SC2APIProtocol.Alert alerts = 10;
inline int Observation::alerts_size() const {
  return alerts_.size();
}
inline void Observation::clear_alerts() {
  alerts_.Clear();
}
inline ::SC2APIProtocol::Alert Observation::alerts(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.alerts)
  return static_cast< ::SC2APIProtocol::Alert >(alerts_.Get(index));
}
inline void Observation::set_alerts(int index, ::SC2APIProtocol::Alert value) {
  assert(::SC2APIProtocol::Alert_IsValid(value));
  alerts_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Observation.alerts)
}
inline void Observation::add_alerts(::SC2APIProtocol::Alert value) {
  assert(::SC2APIProtocol::Alert_IsValid(value));
  alerts_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Observation.alerts)
}
inline const ::google::protobuf::RepeatedField<int>&
Observation::alerts() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Observation.alerts)
  return alerts_;
}
inline ::google::protobuf::RepeatedField<int>*
Observation::mutable_alerts() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Observation.alerts)
  return &alerts_;
}

// repeated .SC2APIProtocol.AvailableAbility abilities = 3;
inline int Observation::abilities_size() const {
  return abilities_.size();
}
inline void Observation::clear_abilities() {
  abilities_.Clear();
}
inline const ::SC2APIProtocol::AvailableAbility& Observation::abilities(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.abilities)
  return abilities_.Get(index);
}
inline ::SC2APIProtocol::AvailableAbility* Observation::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.abilities)
  return abilities_.Mutable(index);
}
inline ::SC2APIProtocol::AvailableAbility* Observation::add_abilities() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Observation.abilities)
  return abilities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >*
Observation::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Observation.abilities)
  return &abilities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >&
Observation::abilities() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Observation.abilities)
  return abilities_;
}

// optional .SC2APIProtocol.Score score = 4;
inline bool Observation::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Observation::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Observation::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Observation::clear_score() {
  if (score_ != NULL) score_->::SC2APIProtocol::Score::Clear();
  clear_has_score();
}
inline const ::SC2APIProtocol::Score& Observation::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.score)
  return score_ != NULL ? *score_ : *default_instance_->score_;
}
inline ::SC2APIProtocol::Score* Observation::mutable_score() {
  set_has_score();
  if (score_ == NULL) {
    score_ = new ::SC2APIProtocol::Score;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.score)
  return score_;
}
inline ::SC2APIProtocol::Score* Observation::release_score() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.score)
  clear_has_score();
  ::SC2APIProtocol::Score* temp = score_;
  score_ = NULL;
  return temp;
}
inline void Observation::set_allocated_score(::SC2APIProtocol::Score* score) {
  delete score_;
  score_ = score;
  if (score) {
    set_has_score();
  } else {
    clear_has_score();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.score)
}

// optional .SC2APIProtocol.ObservationRaw raw_data = 5;
inline bool Observation::has_raw_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Observation::set_has_raw_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Observation::clear_has_raw_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Observation::clear_raw_data() {
  if (raw_data_ != NULL) raw_data_->::SC2APIProtocol::ObservationRaw::Clear();
  clear_has_raw_data();
}
inline const ::SC2APIProtocol::ObservationRaw& Observation::raw_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.raw_data)
  return raw_data_ != NULL ? *raw_data_ : *default_instance_->raw_data_;
}
inline ::SC2APIProtocol::ObservationRaw* Observation::mutable_raw_data() {
  set_has_raw_data();
  if (raw_data_ == NULL) {
    raw_data_ = new ::SC2APIProtocol::ObservationRaw;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.raw_data)
  return raw_data_;
}
inline ::SC2APIProtocol::ObservationRaw* Observation::release_raw_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.raw_data)
  clear_has_raw_data();
  ::SC2APIProtocol::ObservationRaw* temp = raw_data_;
  raw_data_ = NULL;
  return temp;
}
inline void Observation::set_allocated_raw_data(::SC2APIProtocol::ObservationRaw* raw_data) {
  delete raw_data_;
  raw_data_ = raw_data;
  if (raw_data) {
    set_has_raw_data();
  } else {
    clear_has_raw_data();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.raw_data)
}

// optional .SC2APIProtocol.ObservationFeatureLayer feature_layer_data = 6;
inline bool Observation::has_feature_layer_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Observation::set_has_feature_layer_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Observation::clear_has_feature_layer_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Observation::clear_feature_layer_data() {
  if (feature_layer_data_ != NULL) feature_layer_data_->::SC2APIProtocol::ObservationFeatureLayer::Clear();
  clear_has_feature_layer_data();
}
inline const ::SC2APIProtocol::ObservationFeatureLayer& Observation::feature_layer_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.feature_layer_data)
  return feature_layer_data_ != NULL ? *feature_layer_data_ : *default_instance_->feature_layer_data_;
}
inline ::SC2APIProtocol::ObservationFeatureLayer* Observation::mutable_feature_layer_data() {
  set_has_feature_layer_data();
  if (feature_layer_data_ == NULL) {
    feature_layer_data_ = new ::SC2APIProtocol::ObservationFeatureLayer;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.feature_layer_data)
  return feature_layer_data_;
}
inline ::SC2APIProtocol::ObservationFeatureLayer* Observation::release_feature_layer_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.feature_layer_data)
  clear_has_feature_layer_data();
  ::SC2APIProtocol::ObservationFeatureLayer* temp = feature_layer_data_;
  feature_layer_data_ = NULL;
  return temp;
}
inline void Observation::set_allocated_feature_layer_data(::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data) {
  delete feature_layer_data_;
  feature_layer_data_ = feature_layer_data;
  if (feature_layer_data) {
    set_has_feature_layer_data();
  } else {
    clear_has_feature_layer_data();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.feature_layer_data)
}

// optional .SC2APIProtocol.ObservationRender render_data = 7;
inline bool Observation::has_render_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Observation::set_has_render_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Observation::clear_has_render_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Observation::clear_render_data() {
  if (render_data_ != NULL) render_data_->::SC2APIProtocol::ObservationRender::Clear();
  clear_has_render_data();
}
inline const ::SC2APIProtocol::ObservationRender& Observation::render_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.render_data)
  return render_data_ != NULL ? *render_data_ : *default_instance_->render_data_;
}
inline ::SC2APIProtocol::ObservationRender* Observation::mutable_render_data() {
  set_has_render_data();
  if (render_data_ == NULL) {
    render_data_ = new ::SC2APIProtocol::ObservationRender;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.render_data)
  return render_data_;
}
inline ::SC2APIProtocol::ObservationRender* Observation::release_render_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.render_data)
  clear_has_render_data();
  ::SC2APIProtocol::ObservationRender* temp = render_data_;
  render_data_ = NULL;
  return temp;
}
inline void Observation::set_allocated_render_data(::SC2APIProtocol::ObservationRender* render_data) {
  delete render_data_;
  render_data_ = render_data;
  if (render_data) {
    set_has_render_data();
  } else {
    clear_has_render_data();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.render_data)
}

// optional .SC2APIProtocol.ObservationUI ui_data = 8;
inline bool Observation::has_ui_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Observation::set_has_ui_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Observation::clear_has_ui_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Observation::clear_ui_data() {
  if (ui_data_ != NULL) ui_data_->::SC2APIProtocol::ObservationUI::Clear();
  clear_has_ui_data();
}
inline const ::SC2APIProtocol::ObservationUI& Observation::ui_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.ui_data)
  return ui_data_ != NULL ? *ui_data_ : *default_instance_->ui_data_;
}
inline ::SC2APIProtocol::ObservationUI* Observation::mutable_ui_data() {
  set_has_ui_data();
  if (ui_data_ == NULL) {
    ui_data_ = new ::SC2APIProtocol::ObservationUI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.ui_data)
  return ui_data_;
}
inline ::SC2APIProtocol::ObservationUI* Observation::release_ui_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.ui_data)
  clear_has_ui_data();
  ::SC2APIProtocol::ObservationUI* temp = ui_data_;
  ui_data_ = NULL;
  return temp;
}
inline void Observation::set_allocated_ui_data(::SC2APIProtocol::ObservationUI* ui_data) {
  delete ui_data_;
  ui_data_ = ui_data;
  if (ui_data) {
    set_has_ui_data();
  } else {
    clear_has_ui_data();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.ui_data)
}

// -------------------------------------------------------------------

// Action

// optional .SC2APIProtocol.ActionRaw action_raw = 1;
inline bool Action::has_action_raw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Action::set_has_action_raw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Action::clear_has_action_raw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Action::clear_action_raw() {
  if (action_raw_ != NULL) action_raw_->::SC2APIProtocol::ActionRaw::Clear();
  clear_has_action_raw();
}
inline const ::SC2APIProtocol::ActionRaw& Action::action_raw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_raw)
  return action_raw_ != NULL ? *action_raw_ : *default_instance_->action_raw_;
}
inline ::SC2APIProtocol::ActionRaw* Action::mutable_action_raw() {
  set_has_action_raw();
  if (action_raw_ == NULL) {
    action_raw_ = new ::SC2APIProtocol::ActionRaw;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_raw)
  return action_raw_;
}
inline ::SC2APIProtocol::ActionRaw* Action::release_action_raw() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_raw)
  clear_has_action_raw();
  ::SC2APIProtocol::ActionRaw* temp = action_raw_;
  action_raw_ = NULL;
  return temp;
}
inline void Action::set_allocated_action_raw(::SC2APIProtocol::ActionRaw* action_raw) {
  delete action_raw_;
  action_raw_ = action_raw;
  if (action_raw) {
    set_has_action_raw();
  } else {
    clear_has_action_raw();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_raw)
}

// optional .SC2APIProtocol.ActionSpatial action_feature_layer = 2;
inline bool Action::has_action_feature_layer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Action::set_has_action_feature_layer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Action::clear_has_action_feature_layer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Action::clear_action_feature_layer() {
  if (action_feature_layer_ != NULL) action_feature_layer_->::SC2APIProtocol::ActionSpatial::Clear();
  clear_has_action_feature_layer();
}
inline const ::SC2APIProtocol::ActionSpatial& Action::action_feature_layer() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_feature_layer)
  return action_feature_layer_ != NULL ? *action_feature_layer_ : *default_instance_->action_feature_layer_;
}
inline ::SC2APIProtocol::ActionSpatial* Action::mutable_action_feature_layer() {
  set_has_action_feature_layer();
  if (action_feature_layer_ == NULL) {
    action_feature_layer_ = new ::SC2APIProtocol::ActionSpatial;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_feature_layer)
  return action_feature_layer_;
}
inline ::SC2APIProtocol::ActionSpatial* Action::release_action_feature_layer() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_feature_layer)
  clear_has_action_feature_layer();
  ::SC2APIProtocol::ActionSpatial* temp = action_feature_layer_;
  action_feature_layer_ = NULL;
  return temp;
}
inline void Action::set_allocated_action_feature_layer(::SC2APIProtocol::ActionSpatial* action_feature_layer) {
  delete action_feature_layer_;
  action_feature_layer_ = action_feature_layer;
  if (action_feature_layer) {
    set_has_action_feature_layer();
  } else {
    clear_has_action_feature_layer();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_feature_layer)
}

// optional .SC2APIProtocol.ActionSpatial action_render = 3;
inline bool Action::has_action_render() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Action::set_has_action_render() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Action::clear_has_action_render() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Action::clear_action_render() {
  if (action_render_ != NULL) action_render_->::SC2APIProtocol::ActionSpatial::Clear();
  clear_has_action_render();
}
inline const ::SC2APIProtocol::ActionSpatial& Action::action_render() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_render)
  return action_render_ != NULL ? *action_render_ : *default_instance_->action_render_;
}
inline ::SC2APIProtocol::ActionSpatial* Action::mutable_action_render() {
  set_has_action_render();
  if (action_render_ == NULL) {
    action_render_ = new ::SC2APIProtocol::ActionSpatial;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_render)
  return action_render_;
}
inline ::SC2APIProtocol::ActionSpatial* Action::release_action_render() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_render)
  clear_has_action_render();
  ::SC2APIProtocol::ActionSpatial* temp = action_render_;
  action_render_ = NULL;
  return temp;
}
inline void Action::set_allocated_action_render(::SC2APIProtocol::ActionSpatial* action_render) {
  delete action_render_;
  action_render_ = action_render;
  if (action_render) {
    set_has_action_render();
  } else {
    clear_has_action_render();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_render)
}

// optional .SC2APIProtocol.ActionUI action_ui = 4;
inline bool Action::has_action_ui() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Action::set_has_action_ui() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Action::clear_has_action_ui() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Action::clear_action_ui() {
  if (action_ui_ != NULL) action_ui_->::SC2APIProtocol::ActionUI::Clear();
  clear_has_action_ui();
}
inline const ::SC2APIProtocol::ActionUI& Action::action_ui() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_ui)
  return action_ui_ != NULL ? *action_ui_ : *default_instance_->action_ui_;
}
inline ::SC2APIProtocol::ActionUI* Action::mutable_action_ui() {
  set_has_action_ui();
  if (action_ui_ == NULL) {
    action_ui_ = new ::SC2APIProtocol::ActionUI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_ui)
  return action_ui_;
}
inline ::SC2APIProtocol::ActionUI* Action::release_action_ui() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_ui)
  clear_has_action_ui();
  ::SC2APIProtocol::ActionUI* temp = action_ui_;
  action_ui_ = NULL;
  return temp;
}
inline void Action::set_allocated_action_ui(::SC2APIProtocol::ActionUI* action_ui) {
  delete action_ui_;
  action_ui_ = action_ui;
  if (action_ui) {
    set_has_action_ui();
  } else {
    clear_has_action_ui();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_ui)
}

// repeated .SC2APIProtocol.ActionChat chat = 5;
inline int Action::chat_size() const {
  return chat_.size();
}
inline void Action::clear_chat() {
  chat_.Clear();
}
inline const ::SC2APIProtocol::ActionChat& Action::chat(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.chat)
  return chat_.Get(index);
}
inline ::SC2APIProtocol::ActionChat* Action::mutable_chat(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.chat)
  return chat_.Mutable(index);
}
inline ::SC2APIProtocol::ActionChat* Action::add_chat() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Action.chat)
  return chat_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionChat >*
Action::mutable_chat() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Action.chat)
  return &chat_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionChat >&
Action::chat() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Action.chat)
  return chat_;
}

// -------------------------------------------------------------------

// ActionChat

// optional .SC2APIProtocol.ActionChat.Channel channel = 1;
inline bool ActionChat::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionChat::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionChat::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionChat::clear_channel() {
  channel_ = 1;
  clear_has_channel();
}
inline ::SC2APIProtocol::ActionChat_Channel ActionChat::channel() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionChat.channel)
  return static_cast< ::SC2APIProtocol::ActionChat_Channel >(channel_);
}
inline void ActionChat::set_channel(::SC2APIProtocol::ActionChat_Channel value) {
  assert(::SC2APIProtocol::ActionChat_Channel_IsValid(value));
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionChat.channel)
}

// optional string message = 2;
inline bool ActionChat::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionChat::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionChat::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionChat::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ActionChat::message() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionChat.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionChat::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionChat.message)
}
inline void ActionChat::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ActionChat.message)
}
inline void ActionChat::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ActionChat.message)
}
inline ::std::string* ActionChat::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionChat.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionChat::release_message() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionChat.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionChat::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionChat.message)
}

// -------------------------------------------------------------------

// ActionError

// optional uint64 unit_tag = 1;
inline bool ActionError::has_unit_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionError::set_has_unit_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionError::clear_has_unit_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionError::clear_unit_tag() {
  unit_tag_ = GOOGLE_ULONGLONG(0);
  clear_has_unit_tag();
}
inline ::google::protobuf::uint64 ActionError::unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.unit_tag)
  return unit_tag_;
}
inline void ActionError::set_unit_tag(::google::protobuf::uint64 value) {
  set_has_unit_tag();
  unit_tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.unit_tag)
}

// optional uint64 ability_id = 2;
inline bool ActionError::has_ability_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionError::set_has_ability_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionError::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionError::clear_ability_id() {
  ability_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ability_id();
}
inline ::google::protobuf::uint64 ActionError::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.ability_id)
  return ability_id_;
}
inline void ActionError::set_ability_id(::google::protobuf::uint64 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.ability_id)
}

// optional .SC2APIProtocol.ActionResult result = 3;
inline bool ActionError::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionError::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionError::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionError::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::SC2APIProtocol::ActionResult ActionError::result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.result)
  return static_cast< ::SC2APIProtocol::ActionResult >(result_);
}
inline void ActionError::set_result(::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.result)
}

// -------------------------------------------------------------------

// PlayerResult

// optional uint32 player_id = 1;
inline bool PlayerResult::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResult::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerResult::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerResult::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerResult::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerResult.player_id)
  return player_id_;
}
inline void PlayerResult::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerResult.player_id)
}

// optional .SC2APIProtocol.Result result = 2;
inline bool PlayerResult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerResult::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::SC2APIProtocol::Result PlayerResult::result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerResult.result)
  return static_cast< ::SC2APIProtocol::Result >(result_);
}
inline void PlayerResult::set_result(::SC2APIProtocol::Result value) {
  assert(::SC2APIProtocol::Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerResult.result)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SC2APIProtocol::ResponseCreateGame_Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseCreateGame_Error>() {
  return ::SC2APIProtocol::ResponseCreateGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseJoinGame_Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseJoinGame_Error>() {
  return ::SC2APIProtocol::ResponseJoinGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseRestartGame_Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseRestartGame_Error>() {
  return ::SC2APIProtocol::ResponseRestartGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseStartReplay_Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseStartReplay_Error>() {
  return ::SC2APIProtocol::ResponseStartReplay_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseReplayInfo_Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseReplayInfo_Error>() {
  return ::SC2APIProtocol::ResponseReplayInfo_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseSaveMap_Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseSaveMap_Error>() {
  return ::SC2APIProtocol::ResponseSaveMap_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ActionChat_Channel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ActionChat_Channel>() {
  return ::SC2APIProtocol::ActionChat_Channel_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Status>() {
  return ::SC2APIProtocol::Status_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Difficulty> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Difficulty>() {
  return ::SC2APIProtocol::Difficulty_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::PlayerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::PlayerType>() {
  return ::SC2APIProtocol::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Alert> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Alert>() {
  return ::SC2APIProtocol::Alert_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Result>() {
  return ::SC2APIProtocol::Result_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_s2clientprotocol_2fsc2api_2eproto__INCLUDED
