// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/spatial.proto

#ifndef PROTOBUF_s2clientprotocol_2fspatial_2eproto__INCLUDED
#define PROTOBUF_s2clientprotocol_2fspatial_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2007000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
// @@protoc_insertion_point(includes)

namespace SC2APIProtocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

class ActionSpatial;
class ActionSpatialCameraMove;
class ActionSpatialUnitCommand;
class ActionSpatialUnitSelectionPoint;
class ActionSpatialUnitSelectionRect;
class FeatureLayers;
class FeatureLayersMinimap;
class ObservationFeatureLayer;
class ObservationRender;

enum ActionSpatialUnitSelectionPoint_Type {
  ActionSpatialUnitSelectionPoint_Type_Select = 1,
  ActionSpatialUnitSelectionPoint_Type_Toggle = 2,
  ActionSpatialUnitSelectionPoint_Type_AllType = 3,
  ActionSpatialUnitSelectionPoint_Type_AddAllType = 4
};
bool ActionSpatialUnitSelectionPoint_Type_IsValid(int value);
const ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint_Type_Type_MIN = ActionSpatialUnitSelectionPoint_Type_Select;
const ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint_Type_Type_MAX = ActionSpatialUnitSelectionPoint_Type_AddAllType;
const int ActionSpatialUnitSelectionPoint_Type_Type_ARRAYSIZE = ActionSpatialUnitSelectionPoint_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionSpatialUnitSelectionPoint_Type_descriptor();
inline const ::std::string& ActionSpatialUnitSelectionPoint_Type_Name(ActionSpatialUnitSelectionPoint_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionSpatialUnitSelectionPoint_Type_descriptor(), value);
}
inline bool ActionSpatialUnitSelectionPoint_Type_Parse(
    const ::std::string& name, ActionSpatialUnitSelectionPoint_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionSpatialUnitSelectionPoint_Type>(
    ActionSpatialUnitSelectionPoint_Type_descriptor(), name, value);
}
// ===================================================================

class ObservationFeatureLayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObservationFeatureLayer) */ {
 public:
  ObservationFeatureLayer();
  virtual ~ObservationFeatureLayer();

  ObservationFeatureLayer(const ObservationFeatureLayer& from);

  inline ObservationFeatureLayer& operator=(const ObservationFeatureLayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObservationFeatureLayer& default_instance();

  void Swap(ObservationFeatureLayer* other);

  // implements Message ----------------------------------------------

  inline ObservationFeatureLayer* New() const { return New(NULL); }

  ObservationFeatureLayer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObservationFeatureLayer& from);
  void MergeFrom(const ObservationFeatureLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservationFeatureLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.FeatureLayers renders = 1;
  bool has_renders() const;
  void clear_renders();
  static const int kRendersFieldNumber = 1;
  const ::SC2APIProtocol::FeatureLayers& renders() const;
  ::SC2APIProtocol::FeatureLayers* mutable_renders();
  ::SC2APIProtocol::FeatureLayers* release_renders();
  void set_allocated_renders(::SC2APIProtocol::FeatureLayers* renders);

  // optional .SC2APIProtocol.FeatureLayersMinimap minimap_renders = 2;
  bool has_minimap_renders() const;
  void clear_minimap_renders();
  static const int kMinimapRendersFieldNumber = 2;
  const ::SC2APIProtocol::FeatureLayersMinimap& minimap_renders() const;
  ::SC2APIProtocol::FeatureLayersMinimap* mutable_minimap_renders();
  ::SC2APIProtocol::FeatureLayersMinimap* release_minimap_renders();
  void set_allocated_minimap_renders(::SC2APIProtocol::FeatureLayersMinimap* minimap_renders);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObservationFeatureLayer)
 private:
  inline void set_has_renders();
  inline void clear_has_renders();
  inline void set_has_minimap_renders();
  inline void clear_has_minimap_renders();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::FeatureLayers* renders_;
  ::SC2APIProtocol::FeatureLayersMinimap* minimap_renders_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static ObservationFeatureLayer* default_instance_;
};
// -------------------------------------------------------------------

class FeatureLayers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.FeatureLayers) */ {
 public:
  FeatureLayers();
  virtual ~FeatureLayers();

  FeatureLayers(const FeatureLayers& from);

  inline FeatureLayers& operator=(const FeatureLayers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureLayers& default_instance();

  void Swap(FeatureLayers* other);

  // implements Message ----------------------------------------------

  inline FeatureLayers* New() const { return New(NULL); }

  FeatureLayers* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureLayers& from);
  void MergeFrom(const FeatureLayers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureLayers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ImageData height_map = 1;
  bool has_height_map() const;
  void clear_height_map();
  static const int kHeightMapFieldNumber = 1;
  const ::SC2APIProtocol::ImageData& height_map() const;
  ::SC2APIProtocol::ImageData* mutable_height_map();
  ::SC2APIProtocol::ImageData* release_height_map();
  void set_allocated_height_map(::SC2APIProtocol::ImageData* height_map);

  // optional .SC2APIProtocol.ImageData visibility_map = 2;
  bool has_visibility_map() const;
  void clear_visibility_map();
  static const int kVisibilityMapFieldNumber = 2;
  const ::SC2APIProtocol::ImageData& visibility_map() const;
  ::SC2APIProtocol::ImageData* mutable_visibility_map();
  ::SC2APIProtocol::ImageData* release_visibility_map();
  void set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map);

  // optional .SC2APIProtocol.ImageData creep = 3;
  bool has_creep() const;
  void clear_creep();
  static const int kCreepFieldNumber = 3;
  const ::SC2APIProtocol::ImageData& creep() const;
  ::SC2APIProtocol::ImageData* mutable_creep();
  ::SC2APIProtocol::ImageData* release_creep();
  void set_allocated_creep(::SC2APIProtocol::ImageData* creep);

  // optional .SC2APIProtocol.ImageData power = 4;
  bool has_power() const;
  void clear_power();
  static const int kPowerFieldNumber = 4;
  const ::SC2APIProtocol::ImageData& power() const;
  ::SC2APIProtocol::ImageData* mutable_power();
  ::SC2APIProtocol::ImageData* release_power();
  void set_allocated_power(::SC2APIProtocol::ImageData* power);

  // optional .SC2APIProtocol.ImageData player_id = 5;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 5;
  const ::SC2APIProtocol::ImageData& player_id() const;
  ::SC2APIProtocol::ImageData* mutable_player_id();
  ::SC2APIProtocol::ImageData* release_player_id();
  void set_allocated_player_id(::SC2APIProtocol::ImageData* player_id);

  // optional .SC2APIProtocol.ImageData unit_type = 6;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 6;
  const ::SC2APIProtocol::ImageData& unit_type() const;
  ::SC2APIProtocol::ImageData* mutable_unit_type();
  ::SC2APIProtocol::ImageData* release_unit_type();
  void set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type);

  // optional .SC2APIProtocol.ImageData selected = 7;
  bool has_selected() const;
  void clear_selected();
  static const int kSelectedFieldNumber = 7;
  const ::SC2APIProtocol::ImageData& selected() const;
  ::SC2APIProtocol::ImageData* mutable_selected();
  ::SC2APIProtocol::ImageData* release_selected();
  void set_allocated_selected(::SC2APIProtocol::ImageData* selected);

  // optional .SC2APIProtocol.ImageData unit_hit_points = 8;
  bool has_unit_hit_points() const;
  void clear_unit_hit_points();
  static const int kUnitHitPointsFieldNumber = 8;
  const ::SC2APIProtocol::ImageData& unit_hit_points() const;
  ::SC2APIProtocol::ImageData* mutable_unit_hit_points();
  ::SC2APIProtocol::ImageData* release_unit_hit_points();
  void set_allocated_unit_hit_points(::SC2APIProtocol::ImageData* unit_hit_points);

  // optional .SC2APIProtocol.ImageData unit_hit_points_ratio = 17;
  bool has_unit_hit_points_ratio() const;
  void clear_unit_hit_points_ratio();
  static const int kUnitHitPointsRatioFieldNumber = 17;
  const ::SC2APIProtocol::ImageData& unit_hit_points_ratio() const;
  ::SC2APIProtocol::ImageData* mutable_unit_hit_points_ratio();
  ::SC2APIProtocol::ImageData* release_unit_hit_points_ratio();
  void set_allocated_unit_hit_points_ratio(::SC2APIProtocol::ImageData* unit_hit_points_ratio);

  // optional .SC2APIProtocol.ImageData unit_energy = 9;
  bool has_unit_energy() const;
  void clear_unit_energy();
  static const int kUnitEnergyFieldNumber = 9;
  const ::SC2APIProtocol::ImageData& unit_energy() const;
  ::SC2APIProtocol::ImageData* mutable_unit_energy();
  ::SC2APIProtocol::ImageData* release_unit_energy();
  void set_allocated_unit_energy(::SC2APIProtocol::ImageData* unit_energy);

  // optional .SC2APIProtocol.ImageData unit_shields = 10;
  bool has_unit_shields() const;
  void clear_unit_shields();
  static const int kUnitShieldsFieldNumber = 10;
  const ::SC2APIProtocol::ImageData& unit_shields() const;
  ::SC2APIProtocol::ImageData* mutable_unit_shields();
  ::SC2APIProtocol::ImageData* release_unit_shields();
  void set_allocated_unit_shields(::SC2APIProtocol::ImageData* unit_shields);

  // optional .SC2APIProtocol.ImageData player_relative = 11;
  bool has_player_relative() const;
  void clear_player_relative();
  static const int kPlayerRelativeFieldNumber = 11;
  const ::SC2APIProtocol::ImageData& player_relative() const;
  ::SC2APIProtocol::ImageData* mutable_player_relative();
  ::SC2APIProtocol::ImageData* release_player_relative();
  void set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative);

  // optional .SC2APIProtocol.ImageData unit_density_aa = 14;
  bool has_unit_density_aa() const;
  void clear_unit_density_aa();
  static const int kUnitDensityAaFieldNumber = 14;
  const ::SC2APIProtocol::ImageData& unit_density_aa() const;
  ::SC2APIProtocol::ImageData* mutable_unit_density_aa();
  ::SC2APIProtocol::ImageData* release_unit_density_aa();
  void set_allocated_unit_density_aa(::SC2APIProtocol::ImageData* unit_density_aa);

  // optional .SC2APIProtocol.ImageData unit_density = 15;
  bool has_unit_density() const;
  void clear_unit_density();
  static const int kUnitDensityFieldNumber = 15;
  const ::SC2APIProtocol::ImageData& unit_density() const;
  ::SC2APIProtocol::ImageData* mutable_unit_density();
  ::SC2APIProtocol::ImageData* release_unit_density();
  void set_allocated_unit_density(::SC2APIProtocol::ImageData* unit_density);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.FeatureLayers)
 private:
  inline void set_has_height_map();
  inline void clear_has_height_map();
  inline void set_has_visibility_map();
  inline void clear_has_visibility_map();
  inline void set_has_creep();
  inline void clear_has_creep();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_unit_type();
  inline void clear_has_unit_type();
  inline void set_has_selected();
  inline void clear_has_selected();
  inline void set_has_unit_hit_points();
  inline void clear_has_unit_hit_points();
  inline void set_has_unit_hit_points_ratio();
  inline void clear_has_unit_hit_points_ratio();
  inline void set_has_unit_energy();
  inline void clear_has_unit_energy();
  inline void set_has_unit_shields();
  inline void clear_has_unit_shields();
  inline void set_has_player_relative();
  inline void clear_has_player_relative();
  inline void set_has_unit_density_aa();
  inline void clear_has_unit_density_aa();
  inline void set_has_unit_density();
  inline void clear_has_unit_density();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::ImageData* height_map_;
  ::SC2APIProtocol::ImageData* visibility_map_;
  ::SC2APIProtocol::ImageData* creep_;
  ::SC2APIProtocol::ImageData* power_;
  ::SC2APIProtocol::ImageData* player_id_;
  ::SC2APIProtocol::ImageData* unit_type_;
  ::SC2APIProtocol::ImageData* selected_;
  ::SC2APIProtocol::ImageData* unit_hit_points_;
  ::SC2APIProtocol::ImageData* unit_hit_points_ratio_;
  ::SC2APIProtocol::ImageData* unit_energy_;
  ::SC2APIProtocol::ImageData* unit_shields_;
  ::SC2APIProtocol::ImageData* player_relative_;
  ::SC2APIProtocol::ImageData* unit_density_aa_;
  ::SC2APIProtocol::ImageData* unit_density_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static FeatureLayers* default_instance_;
};
// -------------------------------------------------------------------

class FeatureLayersMinimap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.FeatureLayersMinimap) */ {
 public:
  FeatureLayersMinimap();
  virtual ~FeatureLayersMinimap();

  FeatureLayersMinimap(const FeatureLayersMinimap& from);

  inline FeatureLayersMinimap& operator=(const FeatureLayersMinimap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureLayersMinimap& default_instance();

  void Swap(FeatureLayersMinimap* other);

  // implements Message ----------------------------------------------

  inline FeatureLayersMinimap* New() const { return New(NULL); }

  FeatureLayersMinimap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureLayersMinimap& from);
  void MergeFrom(const FeatureLayersMinimap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureLayersMinimap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ImageData height_map = 1;
  bool has_height_map() const;
  void clear_height_map();
  static const int kHeightMapFieldNumber = 1;
  const ::SC2APIProtocol::ImageData& height_map() const;
  ::SC2APIProtocol::ImageData* mutable_height_map();
  ::SC2APIProtocol::ImageData* release_height_map();
  void set_allocated_height_map(::SC2APIProtocol::ImageData* height_map);

  // optional .SC2APIProtocol.ImageData visibility_map = 2;
  bool has_visibility_map() const;
  void clear_visibility_map();
  static const int kVisibilityMapFieldNumber = 2;
  const ::SC2APIProtocol::ImageData& visibility_map() const;
  ::SC2APIProtocol::ImageData* mutable_visibility_map();
  ::SC2APIProtocol::ImageData* release_visibility_map();
  void set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map);

  // optional .SC2APIProtocol.ImageData creep = 3;
  bool has_creep() const;
  void clear_creep();
  static const int kCreepFieldNumber = 3;
  const ::SC2APIProtocol::ImageData& creep() const;
  ::SC2APIProtocol::ImageData* mutable_creep();
  ::SC2APIProtocol::ImageData* release_creep();
  void set_allocated_creep(::SC2APIProtocol::ImageData* creep);

  // optional .SC2APIProtocol.ImageData camera = 4;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 4;
  const ::SC2APIProtocol::ImageData& camera() const;
  ::SC2APIProtocol::ImageData* mutable_camera();
  ::SC2APIProtocol::ImageData* release_camera();
  void set_allocated_camera(::SC2APIProtocol::ImageData* camera);

  // optional .SC2APIProtocol.ImageData player_id = 5;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 5;
  const ::SC2APIProtocol::ImageData& player_id() const;
  ::SC2APIProtocol::ImageData* mutable_player_id();
  ::SC2APIProtocol::ImageData* release_player_id();
  void set_allocated_player_id(::SC2APIProtocol::ImageData* player_id);

  // optional .SC2APIProtocol.ImageData player_relative = 6;
  bool has_player_relative() const;
  void clear_player_relative();
  static const int kPlayerRelativeFieldNumber = 6;
  const ::SC2APIProtocol::ImageData& player_relative() const;
  ::SC2APIProtocol::ImageData* mutable_player_relative();
  ::SC2APIProtocol::ImageData* release_player_relative();
  void set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative);

  // optional .SC2APIProtocol.ImageData selected = 7;
  bool has_selected() const;
  void clear_selected();
  static const int kSelectedFieldNumber = 7;
  const ::SC2APIProtocol::ImageData& selected() const;
  ::SC2APIProtocol::ImageData* mutable_selected();
  ::SC2APIProtocol::ImageData* release_selected();
  void set_allocated_selected(::SC2APIProtocol::ImageData* selected);

  // optional .SC2APIProtocol.ImageData unit_type = 8;
  bool has_unit_type() const;
  void clear_unit_type();
  static const int kUnitTypeFieldNumber = 8;
  const ::SC2APIProtocol::ImageData& unit_type() const;
  ::SC2APIProtocol::ImageData* mutable_unit_type();
  ::SC2APIProtocol::ImageData* release_unit_type();
  void set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.FeatureLayersMinimap)
 private:
  inline void set_has_height_map();
  inline void clear_has_height_map();
  inline void set_has_visibility_map();
  inline void clear_has_visibility_map();
  inline void set_has_creep();
  inline void clear_has_creep();
  inline void set_has_camera();
  inline void clear_has_camera();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_player_relative();
  inline void clear_has_player_relative();
  inline void set_has_selected();
  inline void clear_has_selected();
  inline void set_has_unit_type();
  inline void clear_has_unit_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::ImageData* height_map_;
  ::SC2APIProtocol::ImageData* visibility_map_;
  ::SC2APIProtocol::ImageData* creep_;
  ::SC2APIProtocol::ImageData* camera_;
  ::SC2APIProtocol::ImageData* player_id_;
  ::SC2APIProtocol::ImageData* player_relative_;
  ::SC2APIProtocol::ImageData* selected_;
  ::SC2APIProtocol::ImageData* unit_type_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static FeatureLayersMinimap* default_instance_;
};
// -------------------------------------------------------------------

class ObservationRender : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObservationRender) */ {
 public:
  ObservationRender();
  virtual ~ObservationRender();

  ObservationRender(const ObservationRender& from);

  inline ObservationRender& operator=(const ObservationRender& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObservationRender& default_instance();

  void Swap(ObservationRender* other);

  // implements Message ----------------------------------------------

  inline ObservationRender* New() const { return New(NULL); }

  ObservationRender* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObservationRender& from);
  void MergeFrom(const ObservationRender& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservationRender* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ImageData map = 1;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 1;
  const ::SC2APIProtocol::ImageData& map() const;
  ::SC2APIProtocol::ImageData* mutable_map();
  ::SC2APIProtocol::ImageData* release_map();
  void set_allocated_map(::SC2APIProtocol::ImageData* map);

  // optional .SC2APIProtocol.ImageData minimap = 2;
  bool has_minimap() const;
  void clear_minimap();
  static const int kMinimapFieldNumber = 2;
  const ::SC2APIProtocol::ImageData& minimap() const;
  ::SC2APIProtocol::ImageData* mutable_minimap();
  ::SC2APIProtocol::ImageData* release_minimap();
  void set_allocated_minimap(::SC2APIProtocol::ImageData* minimap);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObservationRender)
 private:
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_minimap();
  inline void clear_has_minimap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::ImageData* map_;
  ::SC2APIProtocol::ImageData* minimap_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static ObservationRender* default_instance_;
};
// -------------------------------------------------------------------

class ActionSpatial : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatial) */ {
 public:
  ActionSpatial();
  virtual ~ActionSpatial();

  ActionSpatial(const ActionSpatial& from);

  inline ActionSpatial& operator=(const ActionSpatial& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatial& default_instance();

  enum ActionCase {
    kUnitCommand = 1,
    kCameraMove = 2,
    kUnitSelectionPoint = 3,
    kUnitSelectionRect = 4,
    ACTION_NOT_SET = 0,
  };

  void Swap(ActionSpatial* other);

  // implements Message ----------------------------------------------

  inline ActionSpatial* New() const { return New(NULL); }

  ActionSpatial* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionSpatial& from);
  void MergeFrom(const ActionSpatial& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionSpatial* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ActionSpatialUnitCommand unit_command = 1;
  bool has_unit_command() const;
  void clear_unit_command();
  static const int kUnitCommandFieldNumber = 1;
  const ::SC2APIProtocol::ActionSpatialUnitCommand& unit_command() const;
  ::SC2APIProtocol::ActionSpatialUnitCommand* mutable_unit_command();
  ::SC2APIProtocol::ActionSpatialUnitCommand* release_unit_command();
  void set_allocated_unit_command(::SC2APIProtocol::ActionSpatialUnitCommand* unit_command);

  // optional .SC2APIProtocol.ActionSpatialCameraMove camera_move = 2;
  bool has_camera_move() const;
  void clear_camera_move();
  static const int kCameraMoveFieldNumber = 2;
  const ::SC2APIProtocol::ActionSpatialCameraMove& camera_move() const;
  ::SC2APIProtocol::ActionSpatialCameraMove* mutable_camera_move();
  ::SC2APIProtocol::ActionSpatialCameraMove* release_camera_move();
  void set_allocated_camera_move(::SC2APIProtocol::ActionSpatialCameraMove* camera_move);

  // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;
  bool has_unit_selection_point() const;
  void clear_unit_selection_point();
  static const int kUnitSelectionPointFieldNumber = 3;
  const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& unit_selection_point() const;
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* mutable_unit_selection_point();
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* release_unit_selection_point();
  void set_allocated_unit_selection_point(::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point);

  // optional .SC2APIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;
  bool has_unit_selection_rect() const;
  void clear_unit_selection_rect();
  static const int kUnitSelectionRectFieldNumber = 4;
  const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& unit_selection_rect() const;
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* mutable_unit_selection_rect();
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* release_unit_selection_rect();
  void set_allocated_unit_selection_rect(::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect);

  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatial)
 private:
  inline void set_has_unit_command();
  inline void set_has_camera_move();
  inline void set_has_unit_selection_point();
  inline void set_has_unit_selection_rect();

  inline bool has_action() const;
  void clear_action();
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SC2APIProtocol::ActionSpatialUnitCommand* unit_command_;
    ::SC2APIProtocol::ActionSpatialCameraMove* camera_move_;
    ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point_;
    ::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect_;
  } action_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static ActionSpatial* default_instance_;
};
// -------------------------------------------------------------------

class ActionSpatialUnitCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitCommand) */ {
 public:
  ActionSpatialUnitCommand();
  virtual ~ActionSpatialUnitCommand();

  ActionSpatialUnitCommand(const ActionSpatialUnitCommand& from);

  inline ActionSpatialUnitCommand& operator=(const ActionSpatialUnitCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatialUnitCommand& default_instance();

  enum TargetCase {
    kTargetScreenCoord = 2,
    kTargetMinimapCoord = 3,
    TARGET_NOT_SET = 0,
  };

  void Swap(ActionSpatialUnitCommand* other);

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitCommand* New() const { return New(NULL); }

  ActionSpatialUnitCommand* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionSpatialUnitCommand& from);
  void MergeFrom(const ActionSpatialUnitCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionSpatialUnitCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  ::google::protobuf::int32 ability_id() const;
  void set_ability_id(::google::protobuf::int32 value);

  // optional .SC2APIProtocol.PointI target_screen_coord = 2;
  bool has_target_screen_coord() const;
  void clear_target_screen_coord();
  static const int kTargetScreenCoordFieldNumber = 2;
  const ::SC2APIProtocol::PointI& target_screen_coord() const;
  ::SC2APIProtocol::PointI* mutable_target_screen_coord();
  ::SC2APIProtocol::PointI* release_target_screen_coord();
  void set_allocated_target_screen_coord(::SC2APIProtocol::PointI* target_screen_coord);

  // optional .SC2APIProtocol.PointI target_minimap_coord = 3;
  bool has_target_minimap_coord() const;
  void clear_target_minimap_coord();
  static const int kTargetMinimapCoordFieldNumber = 3;
  const ::SC2APIProtocol::PointI& target_minimap_coord() const;
  ::SC2APIProtocol::PointI* mutable_target_minimap_coord();
  ::SC2APIProtocol::PointI* release_target_minimap_coord();
  void set_allocated_target_minimap_coord(::SC2APIProtocol::PointI* target_minimap_coord);

  // optional bool queue_command = 4;
  bool has_queue_command() const;
  void clear_queue_command();
  static const int kQueueCommandFieldNumber = 4;
  bool queue_command() const;
  void set_queue_command(bool value);

  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitCommand)
 private:
  inline void set_has_ability_id();
  inline void clear_has_ability_id();
  inline void set_has_target_screen_coord();
  inline void set_has_target_minimap_coord();
  inline void set_has_queue_command();
  inline void clear_has_queue_command();

  inline bool has_target() const;
  void clear_target();
  inline void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ability_id_;
  bool queue_command_;
  union TargetUnion {
    TargetUnion() {}
    ::SC2APIProtocol::PointI* target_screen_coord_;
    ::SC2APIProtocol::PointI* target_minimap_coord_;
  } target_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static ActionSpatialUnitCommand* default_instance_;
};
// -------------------------------------------------------------------

class ActionSpatialCameraMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialCameraMove) */ {
 public:
  ActionSpatialCameraMove();
  virtual ~ActionSpatialCameraMove();

  ActionSpatialCameraMove(const ActionSpatialCameraMove& from);

  inline ActionSpatialCameraMove& operator=(const ActionSpatialCameraMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatialCameraMove& default_instance();

  void Swap(ActionSpatialCameraMove* other);

  // implements Message ----------------------------------------------

  inline ActionSpatialCameraMove* New() const { return New(NULL); }

  ActionSpatialCameraMove* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionSpatialCameraMove& from);
  void MergeFrom(const ActionSpatialCameraMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionSpatialCameraMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.PointI center_minimap = 1;
  bool has_center_minimap() const;
  void clear_center_minimap();
  static const int kCenterMinimapFieldNumber = 1;
  const ::SC2APIProtocol::PointI& center_minimap() const;
  ::SC2APIProtocol::PointI* mutable_center_minimap();
  ::SC2APIProtocol::PointI* release_center_minimap();
  void set_allocated_center_minimap(::SC2APIProtocol::PointI* center_minimap);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialCameraMove)
 private:
  inline void set_has_center_minimap();
  inline void clear_has_center_minimap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::PointI* center_minimap_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static ActionSpatialCameraMove* default_instance_;
};
// -------------------------------------------------------------------

class ActionSpatialUnitSelectionPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitSelectionPoint) */ {
 public:
  ActionSpatialUnitSelectionPoint();
  virtual ~ActionSpatialUnitSelectionPoint();

  ActionSpatialUnitSelectionPoint(const ActionSpatialUnitSelectionPoint& from);

  inline ActionSpatialUnitSelectionPoint& operator=(const ActionSpatialUnitSelectionPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatialUnitSelectionPoint& default_instance();

  void Swap(ActionSpatialUnitSelectionPoint* other);

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitSelectionPoint* New() const { return New(NULL); }

  ActionSpatialUnitSelectionPoint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionSpatialUnitSelectionPoint& from);
  void MergeFrom(const ActionSpatialUnitSelectionPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionSpatialUnitSelectionPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ActionSpatialUnitSelectionPoint_Type Type;
  static const Type Select =
    ActionSpatialUnitSelectionPoint_Type_Select;
  static const Type Toggle =
    ActionSpatialUnitSelectionPoint_Type_Toggle;
  static const Type AllType =
    ActionSpatialUnitSelectionPoint_Type_AllType;
  static const Type AddAllType =
    ActionSpatialUnitSelectionPoint_Type_AddAllType;
  static inline bool Type_IsValid(int value) {
    return ActionSpatialUnitSelectionPoint_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ActionSpatialUnitSelectionPoint_Type_Type_MIN;
  static const Type Type_MAX =
    ActionSpatialUnitSelectionPoint_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ActionSpatialUnitSelectionPoint_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ActionSpatialUnitSelectionPoint_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ActionSpatialUnitSelectionPoint_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ActionSpatialUnitSelectionPoint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.PointI selection_screen_coord = 1;
  bool has_selection_screen_coord() const;
  void clear_selection_screen_coord();
  static const int kSelectionScreenCoordFieldNumber = 1;
  const ::SC2APIProtocol::PointI& selection_screen_coord() const;
  ::SC2APIProtocol::PointI* mutable_selection_screen_coord();
  ::SC2APIProtocol::PointI* release_selection_screen_coord();
  void set_allocated_selection_screen_coord(::SC2APIProtocol::PointI* selection_screen_coord);

  // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type type() const;
  void set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitSelectionPoint)
 private:
  inline void set_has_selection_screen_coord();
  inline void clear_has_selection_screen_coord();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SC2APIProtocol::PointI* selection_screen_coord_;
  int type_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static ActionSpatialUnitSelectionPoint* default_instance_;
};
// -------------------------------------------------------------------

class ActionSpatialUnitSelectionRect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitSelectionRect) */ {
 public:
  ActionSpatialUnitSelectionRect();
  virtual ~ActionSpatialUnitSelectionRect();

  ActionSpatialUnitSelectionRect(const ActionSpatialUnitSelectionRect& from);

  inline ActionSpatialUnitSelectionRect& operator=(const ActionSpatialUnitSelectionRect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSpatialUnitSelectionRect& default_instance();

  void Swap(ActionSpatialUnitSelectionRect* other);

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitSelectionRect* New() const { return New(NULL); }

  ActionSpatialUnitSelectionRect* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionSpatialUnitSelectionRect& from);
  void MergeFrom(const ActionSpatialUnitSelectionRect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionSpatialUnitSelectionRect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.RectangleI selection_screen_coord = 1;
  int selection_screen_coord_size() const;
  void clear_selection_screen_coord();
  static const int kSelectionScreenCoordFieldNumber = 1;
  const ::SC2APIProtocol::RectangleI& selection_screen_coord(int index) const;
  ::SC2APIProtocol::RectangleI* mutable_selection_screen_coord(int index);
  ::SC2APIProtocol::RectangleI* add_selection_screen_coord();
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::RectangleI >*
      mutable_selection_screen_coord();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::RectangleI >&
      selection_screen_coord() const;

  // optional bool selection_add = 2;
  bool has_selection_add() const;
  void clear_selection_add();
  static const int kSelectionAddFieldNumber = 2;
  bool selection_add() const;
  void set_selection_add(bool value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitSelectionRect)
 private:
  inline void set_has_selection_add();
  inline void clear_has_selection_add();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::RectangleI > selection_screen_coord_;
  bool selection_add_;
  friend void  protobuf_AddDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_AssignDesc_s2clientprotocol_2fspatial_2eproto();
  friend void protobuf_ShutdownFile_s2clientprotocol_2fspatial_2eproto();

  void InitAsDefaultInstance();
  static ActionSpatialUnitSelectionRect* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ObservationFeatureLayer

// optional .SC2APIProtocol.FeatureLayers renders = 1;
inline bool ObservationFeatureLayer::has_renders() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservationFeatureLayer::set_has_renders() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservationFeatureLayer::clear_has_renders() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservationFeatureLayer::clear_renders() {
  if (renders_ != NULL) renders_->::SC2APIProtocol::FeatureLayers::Clear();
  clear_has_renders();
}
inline const ::SC2APIProtocol::FeatureLayers& ObservationFeatureLayer::renders() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationFeatureLayer.renders)
  return renders_ != NULL ? *renders_ : *default_instance_->renders_;
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::mutable_renders() {
  set_has_renders();
  if (renders_ == NULL) {
    renders_ = new ::SC2APIProtocol::FeatureLayers;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationFeatureLayer.renders)
  return renders_;
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::release_renders() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationFeatureLayer.renders)
  clear_has_renders();
  ::SC2APIProtocol::FeatureLayers* temp = renders_;
  renders_ = NULL;
  return temp;
}
inline void ObservationFeatureLayer::set_allocated_renders(::SC2APIProtocol::FeatureLayers* renders) {
  delete renders_;
  renders_ = renders;
  if (renders) {
    set_has_renders();
  } else {
    clear_has_renders();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationFeatureLayer.renders)
}

// optional .SC2APIProtocol.FeatureLayersMinimap minimap_renders = 2;
inline bool ObservationFeatureLayer::has_minimap_renders() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservationFeatureLayer::set_has_minimap_renders() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservationFeatureLayer::clear_has_minimap_renders() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObservationFeatureLayer::clear_minimap_renders() {
  if (minimap_renders_ != NULL) minimap_renders_->::SC2APIProtocol::FeatureLayersMinimap::Clear();
  clear_has_minimap_renders();
}
inline const ::SC2APIProtocol::FeatureLayersMinimap& ObservationFeatureLayer::minimap_renders() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  return minimap_renders_ != NULL ? *minimap_renders_ : *default_instance_->minimap_renders_;
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::mutable_minimap_renders() {
  set_has_minimap_renders();
  if (minimap_renders_ == NULL) {
    minimap_renders_ = new ::SC2APIProtocol::FeatureLayersMinimap;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  return minimap_renders_;
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::release_minimap_renders() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  clear_has_minimap_renders();
  ::SC2APIProtocol::FeatureLayersMinimap* temp = minimap_renders_;
  minimap_renders_ = NULL;
  return temp;
}
inline void ObservationFeatureLayer::set_allocated_minimap_renders(::SC2APIProtocol::FeatureLayersMinimap* minimap_renders) {
  delete minimap_renders_;
  minimap_renders_ = minimap_renders;
  if (minimap_renders) {
    set_has_minimap_renders();
  } else {
    clear_has_minimap_renders();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
}

// -------------------------------------------------------------------

// FeatureLayers

// optional .SC2APIProtocol.ImageData height_map = 1;
inline bool FeatureLayers::has_height_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureLayers::set_has_height_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureLayers::clear_has_height_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureLayers::clear_height_map() {
  if (height_map_ != NULL) height_map_->::SC2APIProtocol::ImageData::Clear();
  clear_has_height_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::height_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.height_map)
  return height_map_ != NULL ? *height_map_ : *default_instance_->height_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_height_map() {
  set_has_height_map();
  if (height_map_ == NULL) {
    height_map_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.height_map)
  return height_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_height_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.height_map)
  clear_has_height_map();
  ::SC2APIProtocol::ImageData* temp = height_map_;
  height_map_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_height_map(::SC2APIProtocol::ImageData* height_map) {
  delete height_map_;
  height_map_ = height_map;
  if (height_map) {
    set_has_height_map();
  } else {
    clear_has_height_map();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.height_map)
}

// optional .SC2APIProtocol.ImageData visibility_map = 2;
inline bool FeatureLayers::has_visibility_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureLayers::set_has_visibility_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureLayers::clear_has_visibility_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureLayers::clear_visibility_map() {
  if (visibility_map_ != NULL) visibility_map_->::SC2APIProtocol::ImageData::Clear();
  clear_has_visibility_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::visibility_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.visibility_map)
  return visibility_map_ != NULL ? *visibility_map_ : *default_instance_->visibility_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_visibility_map() {
  set_has_visibility_map();
  if (visibility_map_ == NULL) {
    visibility_map_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.visibility_map)
  return visibility_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_visibility_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.visibility_map)
  clear_has_visibility_map();
  ::SC2APIProtocol::ImageData* temp = visibility_map_;
  visibility_map_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map) {
  delete visibility_map_;
  visibility_map_ = visibility_map;
  if (visibility_map) {
    set_has_visibility_map();
  } else {
    clear_has_visibility_map();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.visibility_map)
}

// optional .SC2APIProtocol.ImageData creep = 3;
inline bool FeatureLayers::has_creep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureLayers::set_has_creep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureLayers::clear_has_creep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeatureLayers::clear_creep() {
  if (creep_ != NULL) creep_->::SC2APIProtocol::ImageData::Clear();
  clear_has_creep();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::creep() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.creep)
  return creep_ != NULL ? *creep_ : *default_instance_->creep_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_creep() {
  set_has_creep();
  if (creep_ == NULL) {
    creep_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.creep)
  return creep_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_creep() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.creep)
  clear_has_creep();
  ::SC2APIProtocol::ImageData* temp = creep_;
  creep_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_creep(::SC2APIProtocol::ImageData* creep) {
  delete creep_;
  creep_ = creep;
  if (creep) {
    set_has_creep();
  } else {
    clear_has_creep();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.creep)
}

// optional .SC2APIProtocol.ImageData power = 4;
inline bool FeatureLayers::has_power() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeatureLayers::set_has_power() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeatureLayers::clear_has_power() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeatureLayers::clear_power() {
  if (power_ != NULL) power_->::SC2APIProtocol::ImageData::Clear();
  clear_has_power();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::power() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.power)
  return power_ != NULL ? *power_ : *default_instance_->power_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_power() {
  set_has_power();
  if (power_ == NULL) {
    power_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.power)
  return power_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_power() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.power)
  clear_has_power();
  ::SC2APIProtocol::ImageData* temp = power_;
  power_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_power(::SC2APIProtocol::ImageData* power) {
  delete power_;
  power_ = power;
  if (power) {
    set_has_power();
  } else {
    clear_has_power();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.power)
}

// optional .SC2APIProtocol.ImageData player_id = 5;
inline bool FeatureLayers::has_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeatureLayers::set_has_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeatureLayers::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeatureLayers::clear_player_id() {
  if (player_id_ != NULL) player_id_->::SC2APIProtocol::ImageData::Clear();
  clear_has_player_id();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.player_id)
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) {
    player_id_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.player_id)
  return player_id_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_player_id() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.player_id)
  clear_has_player_id();
  ::SC2APIProtocol::ImageData* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_player_id(::SC2APIProtocol::ImageData* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.player_id)
}

// optional .SC2APIProtocol.ImageData unit_type = 6;
inline bool FeatureLayers::has_unit_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeatureLayers::set_has_unit_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeatureLayers::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FeatureLayers::clear_unit_type() {
  if (unit_type_ != NULL) unit_type_->::SC2APIProtocol::ImageData::Clear();
  clear_has_unit_type();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_type)
  return unit_type_ != NULL ? *unit_type_ : *default_instance_->unit_type_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_type() {
  set_has_unit_type();
  if (unit_type_ == NULL) {
    unit_type_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_type)
  return unit_type_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_type() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_type)
  clear_has_unit_type();
  ::SC2APIProtocol::ImageData* temp = unit_type_;
  unit_type_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type) {
  delete unit_type_;
  unit_type_ = unit_type;
  if (unit_type) {
    set_has_unit_type();
  } else {
    clear_has_unit_type();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_type)
}

// optional .SC2APIProtocol.ImageData selected = 7;
inline bool FeatureLayers::has_selected() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FeatureLayers::set_has_selected() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FeatureLayers::clear_has_selected() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FeatureLayers::clear_selected() {
  if (selected_ != NULL) selected_->::SC2APIProtocol::ImageData::Clear();
  clear_has_selected();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::selected() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.selected)
  return selected_ != NULL ? *selected_ : *default_instance_->selected_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_selected() {
  set_has_selected();
  if (selected_ == NULL) {
    selected_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.selected)
  return selected_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_selected() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.selected)
  clear_has_selected();
  ::SC2APIProtocol::ImageData* temp = selected_;
  selected_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_selected(::SC2APIProtocol::ImageData* selected) {
  delete selected_;
  selected_ = selected;
  if (selected) {
    set_has_selected();
  } else {
    clear_has_selected();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.selected)
}

// optional .SC2APIProtocol.ImageData unit_hit_points = 8;
inline bool FeatureLayers::has_unit_hit_points() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FeatureLayers::set_has_unit_hit_points() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FeatureLayers::clear_has_unit_hit_points() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FeatureLayers::clear_unit_hit_points() {
  if (unit_hit_points_ != NULL) unit_hit_points_->::SC2APIProtocol::ImageData::Clear();
  clear_has_unit_hit_points();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_hit_points() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_hit_points)
  return unit_hit_points_ != NULL ? *unit_hit_points_ : *default_instance_->unit_hit_points_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_hit_points() {
  set_has_unit_hit_points();
  if (unit_hit_points_ == NULL) {
    unit_hit_points_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_hit_points)
  return unit_hit_points_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_hit_points() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_hit_points)
  clear_has_unit_hit_points();
  ::SC2APIProtocol::ImageData* temp = unit_hit_points_;
  unit_hit_points_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_unit_hit_points(::SC2APIProtocol::ImageData* unit_hit_points) {
  delete unit_hit_points_;
  unit_hit_points_ = unit_hit_points;
  if (unit_hit_points) {
    set_has_unit_hit_points();
  } else {
    clear_has_unit_hit_points();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_hit_points)
}

// optional .SC2APIProtocol.ImageData unit_hit_points_ratio = 17;
inline bool FeatureLayers::has_unit_hit_points_ratio() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FeatureLayers::set_has_unit_hit_points_ratio() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FeatureLayers::clear_has_unit_hit_points_ratio() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FeatureLayers::clear_unit_hit_points_ratio() {
  if (unit_hit_points_ratio_ != NULL) unit_hit_points_ratio_->::SC2APIProtocol::ImageData::Clear();
  clear_has_unit_hit_points_ratio();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_hit_points_ratio() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  return unit_hit_points_ratio_ != NULL ? *unit_hit_points_ratio_ : *default_instance_->unit_hit_points_ratio_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_hit_points_ratio() {
  set_has_unit_hit_points_ratio();
  if (unit_hit_points_ratio_ == NULL) {
    unit_hit_points_ratio_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  return unit_hit_points_ratio_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_hit_points_ratio() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  clear_has_unit_hit_points_ratio();
  ::SC2APIProtocol::ImageData* temp = unit_hit_points_ratio_;
  unit_hit_points_ratio_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_unit_hit_points_ratio(::SC2APIProtocol::ImageData* unit_hit_points_ratio) {
  delete unit_hit_points_ratio_;
  unit_hit_points_ratio_ = unit_hit_points_ratio;
  if (unit_hit_points_ratio) {
    set_has_unit_hit_points_ratio();
  } else {
    clear_has_unit_hit_points_ratio();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
}

// optional .SC2APIProtocol.ImageData unit_energy = 9;
inline bool FeatureLayers::has_unit_energy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FeatureLayers::set_has_unit_energy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FeatureLayers::clear_has_unit_energy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FeatureLayers::clear_unit_energy() {
  if (unit_energy_ != NULL) unit_energy_->::SC2APIProtocol::ImageData::Clear();
  clear_has_unit_energy();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_energy() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_energy)
  return unit_energy_ != NULL ? *unit_energy_ : *default_instance_->unit_energy_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_energy() {
  set_has_unit_energy();
  if (unit_energy_ == NULL) {
    unit_energy_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_energy)
  return unit_energy_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_energy() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_energy)
  clear_has_unit_energy();
  ::SC2APIProtocol::ImageData* temp = unit_energy_;
  unit_energy_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_unit_energy(::SC2APIProtocol::ImageData* unit_energy) {
  delete unit_energy_;
  unit_energy_ = unit_energy;
  if (unit_energy) {
    set_has_unit_energy();
  } else {
    clear_has_unit_energy();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_energy)
}

// optional .SC2APIProtocol.ImageData unit_shields = 10;
inline bool FeatureLayers::has_unit_shields() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FeatureLayers::set_has_unit_shields() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FeatureLayers::clear_has_unit_shields() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FeatureLayers::clear_unit_shields() {
  if (unit_shields_ != NULL) unit_shields_->::SC2APIProtocol::ImageData::Clear();
  clear_has_unit_shields();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_shields() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_shields)
  return unit_shields_ != NULL ? *unit_shields_ : *default_instance_->unit_shields_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_shields() {
  set_has_unit_shields();
  if (unit_shields_ == NULL) {
    unit_shields_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_shields)
  return unit_shields_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_shields() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_shields)
  clear_has_unit_shields();
  ::SC2APIProtocol::ImageData* temp = unit_shields_;
  unit_shields_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_unit_shields(::SC2APIProtocol::ImageData* unit_shields) {
  delete unit_shields_;
  unit_shields_ = unit_shields;
  if (unit_shields) {
    set_has_unit_shields();
  } else {
    clear_has_unit_shields();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_shields)
}

// optional .SC2APIProtocol.ImageData player_relative = 11;
inline bool FeatureLayers::has_player_relative() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FeatureLayers::set_has_player_relative() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FeatureLayers::clear_has_player_relative() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FeatureLayers::clear_player_relative() {
  if (player_relative_ != NULL) player_relative_->::SC2APIProtocol::ImageData::Clear();
  clear_has_player_relative();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::player_relative() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.player_relative)
  return player_relative_ != NULL ? *player_relative_ : *default_instance_->player_relative_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_player_relative() {
  set_has_player_relative();
  if (player_relative_ == NULL) {
    player_relative_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.player_relative)
  return player_relative_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_player_relative() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.player_relative)
  clear_has_player_relative();
  ::SC2APIProtocol::ImageData* temp = player_relative_;
  player_relative_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative) {
  delete player_relative_;
  player_relative_ = player_relative;
  if (player_relative) {
    set_has_player_relative();
  } else {
    clear_has_player_relative();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.player_relative)
}

// optional .SC2APIProtocol.ImageData unit_density_aa = 14;
inline bool FeatureLayers::has_unit_density_aa() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FeatureLayers::set_has_unit_density_aa() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FeatureLayers::clear_has_unit_density_aa() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FeatureLayers::clear_unit_density_aa() {
  if (unit_density_aa_ != NULL) unit_density_aa_->::SC2APIProtocol::ImageData::Clear();
  clear_has_unit_density_aa();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_density_aa() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_density_aa)
  return unit_density_aa_ != NULL ? *unit_density_aa_ : *default_instance_->unit_density_aa_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_density_aa() {
  set_has_unit_density_aa();
  if (unit_density_aa_ == NULL) {
    unit_density_aa_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_density_aa)
  return unit_density_aa_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_density_aa() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_density_aa)
  clear_has_unit_density_aa();
  ::SC2APIProtocol::ImageData* temp = unit_density_aa_;
  unit_density_aa_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_unit_density_aa(::SC2APIProtocol::ImageData* unit_density_aa) {
  delete unit_density_aa_;
  unit_density_aa_ = unit_density_aa;
  if (unit_density_aa) {
    set_has_unit_density_aa();
  } else {
    clear_has_unit_density_aa();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_density_aa)
}

// optional .SC2APIProtocol.ImageData unit_density = 15;
inline bool FeatureLayers::has_unit_density() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FeatureLayers::set_has_unit_density() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FeatureLayers::clear_has_unit_density() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FeatureLayers::clear_unit_density() {
  if (unit_density_ != NULL) unit_density_->::SC2APIProtocol::ImageData::Clear();
  clear_has_unit_density();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_density() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_density)
  return unit_density_ != NULL ? *unit_density_ : *default_instance_->unit_density_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_density() {
  set_has_unit_density();
  if (unit_density_ == NULL) {
    unit_density_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_density)
  return unit_density_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_density() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_density)
  clear_has_unit_density();
  ::SC2APIProtocol::ImageData* temp = unit_density_;
  unit_density_ = NULL;
  return temp;
}
inline void FeatureLayers::set_allocated_unit_density(::SC2APIProtocol::ImageData* unit_density) {
  delete unit_density_;
  unit_density_ = unit_density;
  if (unit_density) {
    set_has_unit_density();
  } else {
    clear_has_unit_density();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_density)
}

// -------------------------------------------------------------------

// FeatureLayersMinimap

// optional .SC2APIProtocol.ImageData height_map = 1;
inline bool FeatureLayersMinimap::has_height_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureLayersMinimap::set_has_height_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureLayersMinimap::clear_has_height_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureLayersMinimap::clear_height_map() {
  if (height_map_ != NULL) height_map_->::SC2APIProtocol::ImageData::Clear();
  clear_has_height_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::height_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.height_map)
  return height_map_ != NULL ? *height_map_ : *default_instance_->height_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_height_map() {
  set_has_height_map();
  if (height_map_ == NULL) {
    height_map_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.height_map)
  return height_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_height_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.height_map)
  clear_has_height_map();
  ::SC2APIProtocol::ImageData* temp = height_map_;
  height_map_ = NULL;
  return temp;
}
inline void FeatureLayersMinimap::set_allocated_height_map(::SC2APIProtocol::ImageData* height_map) {
  delete height_map_;
  height_map_ = height_map;
  if (height_map) {
    set_has_height_map();
  } else {
    clear_has_height_map();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.height_map)
}

// optional .SC2APIProtocol.ImageData visibility_map = 2;
inline bool FeatureLayersMinimap::has_visibility_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureLayersMinimap::set_has_visibility_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureLayersMinimap::clear_has_visibility_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureLayersMinimap::clear_visibility_map() {
  if (visibility_map_ != NULL) visibility_map_->::SC2APIProtocol::ImageData::Clear();
  clear_has_visibility_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::visibility_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  return visibility_map_ != NULL ? *visibility_map_ : *default_instance_->visibility_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_visibility_map() {
  set_has_visibility_map();
  if (visibility_map_ == NULL) {
    visibility_map_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  return visibility_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_visibility_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  clear_has_visibility_map();
  ::SC2APIProtocol::ImageData* temp = visibility_map_;
  visibility_map_ = NULL;
  return temp;
}
inline void FeatureLayersMinimap::set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map) {
  delete visibility_map_;
  visibility_map_ = visibility_map;
  if (visibility_map) {
    set_has_visibility_map();
  } else {
    clear_has_visibility_map();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
}

// optional .SC2APIProtocol.ImageData creep = 3;
inline bool FeatureLayersMinimap::has_creep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureLayersMinimap::set_has_creep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureLayersMinimap::clear_has_creep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeatureLayersMinimap::clear_creep() {
  if (creep_ != NULL) creep_->::SC2APIProtocol::ImageData::Clear();
  clear_has_creep();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::creep() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.creep)
  return creep_ != NULL ? *creep_ : *default_instance_->creep_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_creep() {
  set_has_creep();
  if (creep_ == NULL) {
    creep_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.creep)
  return creep_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_creep() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.creep)
  clear_has_creep();
  ::SC2APIProtocol::ImageData* temp = creep_;
  creep_ = NULL;
  return temp;
}
inline void FeatureLayersMinimap::set_allocated_creep(::SC2APIProtocol::ImageData* creep) {
  delete creep_;
  creep_ = creep;
  if (creep) {
    set_has_creep();
  } else {
    clear_has_creep();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.creep)
}

// optional .SC2APIProtocol.ImageData camera = 4;
inline bool FeatureLayersMinimap::has_camera() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeatureLayersMinimap::set_has_camera() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeatureLayersMinimap::clear_has_camera() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeatureLayersMinimap::clear_camera() {
  if (camera_ != NULL) camera_->::SC2APIProtocol::ImageData::Clear();
  clear_has_camera();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::camera() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.camera)
  return camera_ != NULL ? *camera_ : *default_instance_->camera_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_camera() {
  set_has_camera();
  if (camera_ == NULL) {
    camera_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.camera)
  return camera_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_camera() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.camera)
  clear_has_camera();
  ::SC2APIProtocol::ImageData* temp = camera_;
  camera_ = NULL;
  return temp;
}
inline void FeatureLayersMinimap::set_allocated_camera(::SC2APIProtocol::ImageData* camera) {
  delete camera_;
  camera_ = camera;
  if (camera) {
    set_has_camera();
  } else {
    clear_has_camera();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.camera)
}

// optional .SC2APIProtocol.ImageData player_id = 5;
inline bool FeatureLayersMinimap::has_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeatureLayersMinimap::set_has_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeatureLayersMinimap::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeatureLayersMinimap::clear_player_id() {
  if (player_id_ != NULL) player_id_->::SC2APIProtocol::ImageData::Clear();
  clear_has_player_id();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.player_id)
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) {
    player_id_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.player_id)
  return player_id_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_player_id() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.player_id)
  clear_has_player_id();
  ::SC2APIProtocol::ImageData* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void FeatureLayersMinimap::set_allocated_player_id(::SC2APIProtocol::ImageData* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.player_id)
}

// optional .SC2APIProtocol.ImageData player_relative = 6;
inline bool FeatureLayersMinimap::has_player_relative() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeatureLayersMinimap::set_has_player_relative() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeatureLayersMinimap::clear_has_player_relative() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FeatureLayersMinimap::clear_player_relative() {
  if (player_relative_ != NULL) player_relative_->::SC2APIProtocol::ImageData::Clear();
  clear_has_player_relative();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::player_relative() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  return player_relative_ != NULL ? *player_relative_ : *default_instance_->player_relative_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_player_relative() {
  set_has_player_relative();
  if (player_relative_ == NULL) {
    player_relative_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  return player_relative_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_player_relative() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  clear_has_player_relative();
  ::SC2APIProtocol::ImageData* temp = player_relative_;
  player_relative_ = NULL;
  return temp;
}
inline void FeatureLayersMinimap::set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative) {
  delete player_relative_;
  player_relative_ = player_relative;
  if (player_relative) {
    set_has_player_relative();
  } else {
    clear_has_player_relative();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.player_relative)
}

// optional .SC2APIProtocol.ImageData selected = 7;
inline bool FeatureLayersMinimap::has_selected() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FeatureLayersMinimap::set_has_selected() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FeatureLayersMinimap::clear_has_selected() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FeatureLayersMinimap::clear_selected() {
  if (selected_ != NULL) selected_->::SC2APIProtocol::ImageData::Clear();
  clear_has_selected();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::selected() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.selected)
  return selected_ != NULL ? *selected_ : *default_instance_->selected_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_selected() {
  set_has_selected();
  if (selected_ == NULL) {
    selected_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.selected)
  return selected_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_selected() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.selected)
  clear_has_selected();
  ::SC2APIProtocol::ImageData* temp = selected_;
  selected_ = NULL;
  return temp;
}
inline void FeatureLayersMinimap::set_allocated_selected(::SC2APIProtocol::ImageData* selected) {
  delete selected_;
  selected_ = selected;
  if (selected) {
    set_has_selected();
  } else {
    clear_has_selected();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.selected)
}

// optional .SC2APIProtocol.ImageData unit_type = 8;
inline bool FeatureLayersMinimap::has_unit_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FeatureLayersMinimap::set_has_unit_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FeatureLayersMinimap::clear_has_unit_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FeatureLayersMinimap::clear_unit_type() {
  if (unit_type_ != NULL) unit_type_->::SC2APIProtocol::ImageData::Clear();
  clear_has_unit_type();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  return unit_type_ != NULL ? *unit_type_ : *default_instance_->unit_type_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_unit_type() {
  set_has_unit_type();
  if (unit_type_ == NULL) {
    unit_type_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  return unit_type_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_unit_type() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  clear_has_unit_type();
  ::SC2APIProtocol::ImageData* temp = unit_type_;
  unit_type_ = NULL;
  return temp;
}
inline void FeatureLayersMinimap::set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type) {
  delete unit_type_;
  unit_type_ = unit_type;
  if (unit_type) {
    set_has_unit_type();
  } else {
    clear_has_unit_type();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.unit_type)
}

// -------------------------------------------------------------------

// ObservationRender

// optional .SC2APIProtocol.ImageData map = 1;
inline bool ObservationRender::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservationRender::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservationRender::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservationRender::clear_map() {
  if (map_ != NULL) map_->::SC2APIProtocol::ImageData::Clear();
  clear_has_map();
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRender.map)
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::mutable_map() {
  set_has_map();
  if (map_ == NULL) {
    map_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRender.map)
  return map_;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::release_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRender.map)
  clear_has_map();
  ::SC2APIProtocol::ImageData* temp = map_;
  map_ = NULL;
  return temp;
}
inline void ObservationRender::set_allocated_map(::SC2APIProtocol::ImageData* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRender.map)
}

// optional .SC2APIProtocol.ImageData minimap = 2;
inline bool ObservationRender::has_minimap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservationRender::set_has_minimap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservationRender::clear_has_minimap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObservationRender::clear_minimap() {
  if (minimap_ != NULL) minimap_->::SC2APIProtocol::ImageData::Clear();
  clear_has_minimap();
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::minimap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRender.minimap)
  return minimap_ != NULL ? *minimap_ : *default_instance_->minimap_;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::mutable_minimap() {
  set_has_minimap();
  if (minimap_ == NULL) {
    minimap_ = new ::SC2APIProtocol::ImageData;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRender.minimap)
  return minimap_;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::release_minimap() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRender.minimap)
  clear_has_minimap();
  ::SC2APIProtocol::ImageData* temp = minimap_;
  minimap_ = NULL;
  return temp;
}
inline void ObservationRender::set_allocated_minimap(::SC2APIProtocol::ImageData* minimap) {
  delete minimap_;
  minimap_ = minimap;
  if (minimap) {
    set_has_minimap();
  } else {
    clear_has_minimap();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRender.minimap)
}

// -------------------------------------------------------------------

// ActionSpatial

// optional .SC2APIProtocol.ActionSpatialUnitCommand unit_command = 1;
inline bool ActionSpatial::has_unit_command() const {
  return action_case() == kUnitCommand;
}
inline void ActionSpatial::set_has_unit_command() {
  _oneof_case_[0] = kUnitCommand;
}
inline void ActionSpatial::clear_unit_command() {
  if (has_unit_command()) {
    delete action_.unit_command_;
    clear_has_action();
  }
}
inline  const ::SC2APIProtocol::ActionSpatialUnitCommand& ActionSpatial::unit_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_command)
  return has_unit_command()
      ? *action_.unit_command_
      : ::SC2APIProtocol::ActionSpatialUnitCommand::default_instance();
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::mutable_unit_command() {
  if (!has_unit_command()) {
    clear_action();
    set_has_unit_command();
    action_.unit_command_ = new ::SC2APIProtocol::ActionSpatialUnitCommand;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_command)
  return action_.unit_command_;
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::release_unit_command() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_command)
  if (has_unit_command()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitCommand* temp = action_.unit_command_;
    action_.unit_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionSpatial::set_allocated_unit_command(::SC2APIProtocol::ActionSpatialUnitCommand* unit_command) {
  clear_action();
  if (unit_command) {
    set_has_unit_command();
    action_.unit_command_ = unit_command;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatial.unit_command)
}

// optional .SC2APIProtocol.ActionSpatialCameraMove camera_move = 2;
inline bool ActionSpatial::has_camera_move() const {
  return action_case() == kCameraMove;
}
inline void ActionSpatial::set_has_camera_move() {
  _oneof_case_[0] = kCameraMove;
}
inline void ActionSpatial::clear_camera_move() {
  if (has_camera_move()) {
    delete action_.camera_move_;
    clear_has_action();
  }
}
inline  const ::SC2APIProtocol::ActionSpatialCameraMove& ActionSpatial::camera_move() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.camera_move)
  return has_camera_move()
      ? *action_.camera_move_
      : ::SC2APIProtocol::ActionSpatialCameraMove::default_instance();
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::mutable_camera_move() {
  if (!has_camera_move()) {
    clear_action();
    set_has_camera_move();
    action_.camera_move_ = new ::SC2APIProtocol::ActionSpatialCameraMove;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.camera_move)
  return action_.camera_move_;
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::release_camera_move() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.camera_move)
  if (has_camera_move()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialCameraMove* temp = action_.camera_move_;
    action_.camera_move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionSpatial::set_allocated_camera_move(::SC2APIProtocol::ActionSpatialCameraMove* camera_move) {
  clear_action();
  if (camera_move) {
    set_has_camera_move();
    action_.camera_move_ = camera_move;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatial.camera_move)
}

// optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;
inline bool ActionSpatial::has_unit_selection_point() const {
  return action_case() == kUnitSelectionPoint;
}
inline void ActionSpatial::set_has_unit_selection_point() {
  _oneof_case_[0] = kUnitSelectionPoint;
}
inline void ActionSpatial::clear_unit_selection_point() {
  if (has_unit_selection_point()) {
    delete action_.unit_selection_point_;
    clear_has_action();
  }
}
inline  const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& ActionSpatial::unit_selection_point() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_selection_point)
  return has_unit_selection_point()
      ? *action_.unit_selection_point_
      : ::SC2APIProtocol::ActionSpatialUnitSelectionPoint::default_instance();
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::mutable_unit_selection_point() {
  if (!has_unit_selection_point()) {
    clear_action();
    set_has_unit_selection_point();
    action_.unit_selection_point_ = new ::SC2APIProtocol::ActionSpatialUnitSelectionPoint;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_selection_point)
  return action_.unit_selection_point_;
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::release_unit_selection_point() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_selection_point)
  if (has_unit_selection_point()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* temp = action_.unit_selection_point_;
    action_.unit_selection_point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionSpatial::set_allocated_unit_selection_point(::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point) {
  clear_action();
  if (unit_selection_point) {
    set_has_unit_selection_point();
    action_.unit_selection_point_ = unit_selection_point;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatial.unit_selection_point)
}

// optional .SC2APIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;
inline bool ActionSpatial::has_unit_selection_rect() const {
  return action_case() == kUnitSelectionRect;
}
inline void ActionSpatial::set_has_unit_selection_rect() {
  _oneof_case_[0] = kUnitSelectionRect;
}
inline void ActionSpatial::clear_unit_selection_rect() {
  if (has_unit_selection_rect()) {
    delete action_.unit_selection_rect_;
    clear_has_action();
  }
}
inline  const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& ActionSpatial::unit_selection_rect() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  return has_unit_selection_rect()
      ? *action_.unit_selection_rect_
      : ::SC2APIProtocol::ActionSpatialUnitSelectionRect::default_instance();
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::mutable_unit_selection_rect() {
  if (!has_unit_selection_rect()) {
    clear_action();
    set_has_unit_selection_rect();
    action_.unit_selection_rect_ = new ::SC2APIProtocol::ActionSpatialUnitSelectionRect;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  return action_.unit_selection_rect_;
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::release_unit_selection_rect() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  if (has_unit_selection_rect()) {
    clear_has_action();
    ::SC2APIProtocol::ActionSpatialUnitSelectionRect* temp = action_.unit_selection_rect_;
    action_.unit_selection_rect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionSpatial::set_allocated_unit_selection_rect(::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect) {
  clear_action();
  if (unit_selection_rect) {
    set_has_unit_selection_rect();
    action_.unit_selection_rect_ = unit_selection_rect;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatial.unit_selection_rect)
}

inline bool ActionSpatial::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionSpatial::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionSpatial::ActionCase ActionSpatial::action_case() const {
  return ActionSpatial::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpatialUnitCommand

// optional int32 ability_id = 1;
inline bool ActionSpatialUnitCommand::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSpatialUnitCommand::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSpatialUnitCommand::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSpatialUnitCommand::clear_ability_id() {
  ability_id_ = 0;
  clear_has_ability_id();
}
inline ::google::protobuf::int32 ActionSpatialUnitCommand::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.ability_id)
  return ability_id_;
}
inline void ActionSpatialUnitCommand::set_ability_id(::google::protobuf::int32 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitCommand.ability_id)
}

// optional .SC2APIProtocol.PointI target_screen_coord = 2;
inline bool ActionSpatialUnitCommand::has_target_screen_coord() const {
  return target_case() == kTargetScreenCoord;
}
inline void ActionSpatialUnitCommand::set_has_target_screen_coord() {
  _oneof_case_[0] = kTargetScreenCoord;
}
inline void ActionSpatialUnitCommand::clear_target_screen_coord() {
  if (has_target_screen_coord()) {
    delete target_.target_screen_coord_;
    clear_has_target();
  }
}
inline  const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::target_screen_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  return has_target_screen_coord()
      ? *target_.target_screen_coord_
      : ::SC2APIProtocol::PointI::default_instance();
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::mutable_target_screen_coord() {
  if (!has_target_screen_coord()) {
    clear_target();
    set_has_target_screen_coord();
    target_.target_screen_coord_ = new ::SC2APIProtocol::PointI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  return target_.target_screen_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::release_target_screen_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  if (has_target_screen_coord()) {
    clear_has_target();
    ::SC2APIProtocol::PointI* temp = target_.target_screen_coord_;
    target_.target_screen_coord_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionSpatialUnitCommand::set_allocated_target_screen_coord(::SC2APIProtocol::PointI* target_screen_coord) {
  clear_target();
  if (target_screen_coord) {
    set_has_target_screen_coord();
    target_.target_screen_coord_ = target_screen_coord;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
}

// optional .SC2APIProtocol.PointI target_minimap_coord = 3;
inline bool ActionSpatialUnitCommand::has_target_minimap_coord() const {
  return target_case() == kTargetMinimapCoord;
}
inline void ActionSpatialUnitCommand::set_has_target_minimap_coord() {
  _oneof_case_[0] = kTargetMinimapCoord;
}
inline void ActionSpatialUnitCommand::clear_target_minimap_coord() {
  if (has_target_minimap_coord()) {
    delete target_.target_minimap_coord_;
    clear_has_target();
  }
}
inline  const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::target_minimap_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  return has_target_minimap_coord()
      ? *target_.target_minimap_coord_
      : ::SC2APIProtocol::PointI::default_instance();
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::mutable_target_minimap_coord() {
  if (!has_target_minimap_coord()) {
    clear_target();
    set_has_target_minimap_coord();
    target_.target_minimap_coord_ = new ::SC2APIProtocol::PointI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  return target_.target_minimap_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::release_target_minimap_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  if (has_target_minimap_coord()) {
    clear_has_target();
    ::SC2APIProtocol::PointI* temp = target_.target_minimap_coord_;
    target_.target_minimap_coord_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActionSpatialUnitCommand::set_allocated_target_minimap_coord(::SC2APIProtocol::PointI* target_minimap_coord) {
  clear_target();
  if (target_minimap_coord) {
    set_has_target_minimap_coord();
    target_.target_minimap_coord_ = target_minimap_coord;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
}

// optional bool queue_command = 4;
inline bool ActionSpatialUnitCommand::has_queue_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActionSpatialUnitCommand::set_has_queue_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActionSpatialUnitCommand::clear_has_queue_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActionSpatialUnitCommand::clear_queue_command() {
  queue_command_ = false;
  clear_has_queue_command();
}
inline bool ActionSpatialUnitCommand::queue_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.queue_command)
  return queue_command_;
}
inline void ActionSpatialUnitCommand::set_queue_command(bool value) {
  set_has_queue_command();
  queue_command_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitCommand.queue_command)
}

inline bool ActionSpatialUnitCommand::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ActionSpatialUnitCommand::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline ActionSpatialUnitCommand::TargetCase ActionSpatialUnitCommand::target_case() const {
  return ActionSpatialUnitCommand::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpatialCameraMove

// optional .SC2APIProtocol.PointI center_minimap = 1;
inline bool ActionSpatialCameraMove::has_center_minimap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSpatialCameraMove::set_has_center_minimap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSpatialCameraMove::clear_has_center_minimap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSpatialCameraMove::clear_center_minimap() {
  if (center_minimap_ != NULL) center_minimap_->::SC2APIProtocol::PointI::Clear();
  clear_has_center_minimap();
}
inline const ::SC2APIProtocol::PointI& ActionSpatialCameraMove::center_minimap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  return center_minimap_ != NULL ? *center_minimap_ : *default_instance_->center_minimap_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::mutable_center_minimap() {
  set_has_center_minimap();
  if (center_minimap_ == NULL) {
    center_minimap_ = new ::SC2APIProtocol::PointI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  return center_minimap_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::release_center_minimap() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  clear_has_center_minimap();
  ::SC2APIProtocol::PointI* temp = center_minimap_;
  center_minimap_ = NULL;
  return temp;
}
inline void ActionSpatialCameraMove::set_allocated_center_minimap(::SC2APIProtocol::PointI* center_minimap) {
  delete center_minimap_;
  center_minimap_ = center_minimap;
  if (center_minimap) {
    set_has_center_minimap();
  } else {
    clear_has_center_minimap();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
}

// -------------------------------------------------------------------

// ActionSpatialUnitSelectionPoint

// optional .SC2APIProtocol.PointI selection_screen_coord = 1;
inline bool ActionSpatialUnitSelectionPoint::has_selection_screen_coord() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSpatialUnitSelectionPoint::set_has_selection_screen_coord() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSpatialUnitSelectionPoint::clear_has_selection_screen_coord() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSpatialUnitSelectionPoint::clear_selection_screen_coord() {
  if (selection_screen_coord_ != NULL) selection_screen_coord_->::SC2APIProtocol::PointI::Clear();
  clear_has_selection_screen_coord();
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitSelectionPoint::selection_screen_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  return selection_screen_coord_ != NULL ? *selection_screen_coord_ : *default_instance_->selection_screen_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::mutable_selection_screen_coord() {
  set_has_selection_screen_coord();
  if (selection_screen_coord_ == NULL) {
    selection_screen_coord_ = new ::SC2APIProtocol::PointI;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  return selection_screen_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::release_selection_screen_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  clear_has_selection_screen_coord();
  ::SC2APIProtocol::PointI* temp = selection_screen_coord_;
  selection_screen_coord_ = NULL;
  return temp;
}
inline void ActionSpatialUnitSelectionPoint::set_allocated_selection_screen_coord(::SC2APIProtocol::PointI* selection_screen_coord) {
  delete selection_screen_coord_;
  selection_screen_coord_ = selection_screen_coord;
  if (selection_screen_coord) {
    set_has_selection_screen_coord();
  } else {
    clear_has_selection_screen_coord();
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
}

// optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;
inline bool ActionSpatialUnitSelectionPoint::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionSpatialUnitSelectionPoint::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionSpatialUnitSelectionPoint::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionSpatialUnitSelectionPoint::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionPoint.type)
  return static_cast< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type >(type_);
}
inline void ActionSpatialUnitSelectionPoint::set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value) {
  assert(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitSelectionPoint.type)
}

// -------------------------------------------------------------------

// ActionSpatialUnitSelectionRect

// repeated .SC2APIProtocol.RectangleI selection_screen_coord = 1;
inline int ActionSpatialUnitSelectionRect::selection_screen_coord_size() const {
  return selection_screen_coord_.size();
}
inline void ActionSpatialUnitSelectionRect::clear_selection_screen_coord() {
  selection_screen_coord_.Clear();
}
inline const ::SC2APIProtocol::RectangleI& ActionSpatialUnitSelectionRect::selection_screen_coord(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_.Get(index);
}
inline ::SC2APIProtocol::RectangleI* ActionSpatialUnitSelectionRect::mutable_selection_screen_coord(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_.Mutable(index);
}
inline ::SC2APIProtocol::RectangleI* ActionSpatialUnitSelectionRect::add_selection_screen_coord() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::RectangleI >*
ActionSpatialUnitSelectionRect::mutable_selection_screen_coord() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return &selection_screen_coord_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::RectangleI >&
ActionSpatialUnitSelectionRect::selection_screen_coord() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_;
}

// optional bool selection_add = 2;
inline bool ActionSpatialUnitSelectionRect::has_selection_add() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionSpatialUnitSelectionRect::set_has_selection_add() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionSpatialUnitSelectionRect::clear_has_selection_add() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionSpatialUnitSelectionRect::clear_selection_add() {
  selection_add_ = false;
  clear_has_selection_add();
}
inline bool ActionSpatialUnitSelectionRect::selection_add() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_add)
  return selection_add_;
}
inline void ActionSpatialUnitSelectionRect::set_selection_add(bool value) {
  set_has_selection_add();
  selection_add_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_add)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type>() {
  return ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_s2clientprotocol_2fspatial_2eproto__INCLUDED
